"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_lib_llm_ts",{

/***/ "(app-pages-browser)/./src/lib/llm.ts":
/*!************************!*\
  !*** ./src/lib/llm.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CLARIFYING_QUESTIONS_PROMPT: () => (/* binding */ CLARIFYING_QUESTIONS_PROMPT),\n/* harmony export */   DEFAULT_LLM_CONFIG: () => (/* binding */ DEFAULT_LLM_CONFIG),\n/* harmony export */   LLMService: () => (/* binding */ LLMService),\n/* harmony export */   SYSTEM_PROMPT: () => (/* binding */ SYSTEM_PROMPT),\n/* harmony export */   llmService: () => (/* binding */ llmService)\n/* harmony export */ });\n/* harmony import */ var _types_schemas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types/schemas */ \"(app-pages-browser)/./src/types/schemas.ts\");\n\n// Default LM Studio configuration\nconst DEFAULT_LLM_CONFIG = {\n    id: 'local-model',\n    provider: 'local',\n    name: 'LM Studio Local Model',\n    base_url: 'http://localhost:1234',\n    is_openai_compatible: true,\n    model: 'local-model'\n};\n// System prompts\nconst SYSTEM_PROMPT = \"You are a pragmatic product/engineering copilot trained on modern agile practices. You write **concise, unambiguous** specs. You prefer bullet‑point clarity over prose. You surface **ambiguities** and **risks** explicitly. You generate **structured JSON** that matches the provided schema, and an accompanying human‑readable summary.\\n\\nGuidelines:\\n- Never fabricate org‑specific facts; ask questions instead\\n- Use domain vocabulary only if present in the input/context or project context\\n- Keep lists short and high‑signal; default max 7 items per list\\n- Use stable IDs with today's date prefix for easy diffing\\n- Keep acceptance criteria in Given/When/Then form for QA handoff\\n- Always include QA and Docs placeholders in task breakdown\\n- Group tasks with area and prereqs for natural ordering\";\nconst CLARIFYING_QUESTIONS_PROMPT = \"Given the input and resolved context, identify 3-5 questions that would most reduce ambiguity in the specification. Focus on:\\n- Missing business logic or edge cases\\n- Unclear functional requirements\\n- Ambiguous stakeholder expectations\\n- Technical implementation gaps\\n- Integration dependencies\\n\\nIMPORTANT: Respond with ONLY a valid JSON object that matches the ClarifyingQuestions schema. Do not include any other text, markdown, or explanations.\";\n// LLM Service class\nclass LLMService {\n    // Generate specification from input\n    async generateSpec(input, resolvedContext) {\n        let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'draft', options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        const prompt = this.buildSpecPrompt(input, resolvedContext, mode);\n        try {\n            const response = await this.callLLM(prompt, _types_schemas__WEBPACK_IMPORTED_MODULE_0__.SpecOutputSchema, options);\n            return response;\n        } catch (error) {\n            console.error('Error generating spec:', error);\n            throw new Error(\"Failed to generate specification: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Generate clarifying questions\n    async generateClarifyingQuestions(input, resolvedContext) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const prompt = this.buildClarifyingQuestionsPrompt(input, resolvedContext);\n        try {\n            const response = await this.callLLM(prompt, _types_schemas__WEBPACK_IMPORTED_MODULE_0__.ClarifyingQuestionsSchema, options);\n            return response.json;\n        } catch (error) {\n            console.error('Error generating clarifying questions:', error);\n            throw new Error(\"Failed to generate clarifying questions: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Refine specification with answers\n    async refineSpec(originalSpec, answers) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const prompt = this.buildRefinePrompt(originalSpec, answers);\n        try {\n            const response = await this.callLLM(prompt, _types_schemas__WEBPACK_IMPORTED_MODULE_0__.SpecOutputSchema.partial(), options);\n            return response.json;\n        } catch (error) {\n            console.error('Error refining spec:', error);\n            throw new Error(\"Failed to refine specification: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Calculate ambiguity score heuristic\n    calculateAmbiguityScore(input) {\n        var _input_context_stakeholders, _input_context_constraints;\n        let score = 0;\n        // Check input length (shorter descriptions tend to be more ambiguous)\n        if (input.description.length < 100) score += 0.3;\n        else if (input.description.length < 200) score += 0.1;\n        // Check for numbers/dates (more specific)\n        const hasNumbers = /\\d/.test(input.description);\n        if (!hasNumbers) score += 0.2;\n        // Check for vague words\n        const vagueWords = [\n            'some',\n            'maybe',\n            'possibly',\n            'could',\n            'might',\n            'perhaps',\n            'probably'\n        ];\n        const vagueCount = vagueWords.filter((word)=>input.description.toLowerCase().includes(word)).length;\n        score += vagueCount * 0.1;\n        // Check pronoun density (more pronouns = less specific)\n        const pronouns = [\n            'it',\n            'this',\n            'that',\n            'they',\n            'them'\n        ];\n        const pronounCount = pronouns.filter((pronoun)=>input.description.toLowerCase().split(' ').includes(pronoun)).length;\n        score += pronounCount * 0.05;\n        // Check for missing context\n        if (!((_input_context_stakeholders = input.context.stakeholders) === null || _input_context_stakeholders === void 0 ? void 0 : _input_context_stakeholders.length)) score += 0.1;\n        if (!((_input_context_constraints = input.context.constraints) === null || _input_context_constraints === void 0 ? void 0 : _input_context_constraints.length)) score += 0.1;\n        return Math.min(score, 1.0) // Cap at 1.0\n        ;\n    }\n    // Build spec generation prompt\n    buildSpecPrompt(input, resolvedContext, mode) {\n        const today = new Date().toISOString().split('T')[0].replace(/-/g, '');\n        return \"\".concat(SYSTEM_PROMPT, \"\\n\\nRESOLVED PROJECT CONTEXT:\\n\").concat(JSON.stringify(resolvedContext, null, 2), \"\\n\\nUSER INPUT:\\n\").concat(JSON.stringify(input, null, 2), \"\\n\\nINSTRUCTIONS:\\nGenerate a \").concat(mode, ' specification using stable IDs prefixed with \"').concat(today, '\" (e.g., \"FR-').concat(today, '-001\", \"T-').concat(today, '-001\").\\n\\nCRITICAL SCHEMA REQUIREMENTS:\\n- \"input\": Must include the exact input object provided above\\n- \"resolved_context\": Must include the exact resolved context provided above  \\n- \"story\": Object with \"as_a\", \"i_want\", \"so_that\", \"acceptance_criteria\" (array of strings)\\n- \"tasks\": Array of objects, each with:\\n  - \"id\": string (e.g., \"T-').concat(today, '-001\")\\n  - \"title\": string (descriptive task name)\\n  - \"area\": MUST be one of: \"FE\", \"BE\", \"Infra\", \"QA\", \"Docs\" (no other values allowed)\\n  - \"details\": string (implementation details)\\n  - \"prereqs\": array of strings (default: [])\\n  - \"artifacts\": array of strings (default: [])\\n- \"estimation\": Object with:\\n  - \"confidence\": number between 0 and 1\\n  - \"complexity\": one of \"XS\", \"S\", \"M\", \"L\", \"XL\"\\n  - \"drivers\": array of strings\\n  - \"notes\": string\\n- \"functional_requirements\": Array with \"id\" and \"statement\" fields\\n- \"needs_clarification\": Array (default: [])\\n- \"assumptions\": Array of strings (default: [])\\n- \"dependencies\": Array of strings (default: [])\\n- \"edge_cases\": Array of strings (default: [])\\n- \"risks\": Array with \"risk\" and \"mitigation\" fields (default: [])\\n\\nEXAMPLE STRUCTURE:\\n{\\n  \"input\": /* the exact input object */,\\n  \"resolved_context\": /* the exact resolved context */,\\n  \"story\": {\\n    \"as_a\": \"user\",\\n    \"i_want\": \"to do something\",\\n    \"so_that\": \"I achieve a goal\",\\n    \"acceptance_criteria\": [\"Given...\", \"When...\", \"Then...\"]\\n  },\\n  \"tasks\": [\\n    {\\n      \"id\": \"T-').concat(today, '-001\",\\n      \"title\": \"Setup frontend components\",\\n      \"area\": \"FE\",\\n      \"details\": \"Create React components for...\",\\n      \"prereqs\": [],\\n      \"artifacts\": [\"Component files\"]\\n    }\\n  ],\\n  \"estimation\": {\\n    \"confidence\": 0.8,\\n    \"complexity\": \"M\",\\n    \"drivers\": [\"New technology\"],\\n    \"notes\": \"Standard implementation\"\\n  },\\n  \"functional_requirements\": [\\n    {\\n      \"id\": \"FR-').concat(today, '-001\",\\n      \"statement\": \"System must...\"\\n    }\\n  ],\\n  \"needs_clarification\": [],\\n  \"assumptions\": [],\\n  \"dependencies\": [],\\n  \"edge_cases\": [],\\n  \"risks\": []\\n}\\n\\nRESPOND WITH ONLY VALID JSON. NO OTHER TEXT.');\n    }\n    // Build clarifying questions prompt\n    buildClarifyingQuestionsPrompt(input, resolvedContext) {\n        return \"\".concat(CLARIFYING_QUESTIONS_PROMPT, \"\\n\\nRESOLVED PROJECT CONTEXT: \").concat(JSON.stringify(resolvedContext, null, 2), \"\\n\\nUSER INPUT: \").concat(JSON.stringify(input, null, 2), '\\n\\nRespond with a JSON object containing a \"questions\" array and \"estimated_confidence\" number.');\n    }\n    // Build refinement prompt\n    buildRefinePrompt(originalSpec, answers) {\n        return \"SYSTEM: \".concat(SYSTEM_PROMPT, \"\\n\\nORIGINAL SPECIFICATION: \").concat(JSON.stringify(originalSpec, null, 2), \"\\n\\nCLARIFYING ANSWERS:\\n\").concat(answers.map((a)=>\"Q: \".concat(a.question, \"\\nA: \").concat(a.answer)).join('\\n\\n'), \"\\n\\nINSTRUCTIONS:\\nUpdate only the affected sections based on the clarifying answers. Return a partial specification object with only the changed fields.\\n\\nRESPONSE FORMAT:\\n- Provide a JSON object with only the updated fields.\\n\");\n    }\n    // Core LLM API call\n    async callLLM(prompt, schema) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const { temperature = 0.1, max_tokens = 4000, timeout = 60000 } = options;\n        if (!this.config.is_openai_compatible) {\n            throw new Error('Only OpenAI-compatible APIs are currently supported');\n        }\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), timeout);\n        // Prepare the request payload\n        const requestBody = {\n            model: this.config.model,\n            messages: [\n                {\n                    role: 'system',\n                    content: 'You are a helpful assistant that generates structured JSON responses.'\n                },\n                {\n                    role: 'user',\n                    content: prompt\n                }\n            ],\n            temperature,\n            max_tokens\n        };\n        console.log('LLM Request:', {\n            url: \"\".concat(this.config.base_url, \"/v1/chat/completions\"),\n            body: requestBody\n        });\n        try {\n            var _data_choices__message, _data_choices_, _data_choices, _data_usage;\n            const response = await fetch(\"\".concat(this.config.base_url, \"/v1/chat/completions\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    ...this.config.api_key && {\n                        'Authorization': \"Bearer \".concat(this.config.api_key)\n                    }\n                },\n                body: JSON.stringify(requestBody),\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('LLM API Error Response:', errorText);\n                throw new Error(\"LLM API error: \".concat(response.status, \" \").concat(response.statusText, \" - \").concat(errorText));\n            }\n            const data = await response.json();\n            const content = (_data_choices = data.choices) === null || _data_choices === void 0 ? void 0 : (_data_choices_ = _data_choices[0]) === null || _data_choices_ === void 0 ? void 0 : (_data_choices__message = _data_choices_.message) === null || _data_choices__message === void 0 ? void 0 : _data_choices__message.content;\n            if (!content) {\n                throw new Error('No content in LLM response');\n            }\n            // Parse the response - assume it contains summary and JSON\n            const parts = content.split('\\n\\n');\n            let summary = '';\n            let jsonStr = '';\n            // Try to extract summary and JSON\n            for(let i = 0; i < parts.length; i++){\n                const part = parts[i].trim();\n                if (part.startsWith('{') && part.endsWith('}')) {\n                    jsonStr = part;\n                    summary = parts.slice(0, i).join('\\n\\n').trim();\n                    break;\n                }\n            }\n            if (!jsonStr) {\n                // Fallback: treat entire content as JSON\n                jsonStr = content;\n                summary = 'Generated specification';\n            }\n            const parsedJson = JSON.parse(jsonStr);\n            const validated = schema.parse(parsedJson);\n            return {\n                summary: summary || 'Generated specification',\n                json: validated,\n                model_info: {\n                    model: this.config.model,\n                    provider: this.config.provider,\n                    timestamp: new Date(),\n                    tokens_used: (_data_usage = data.usage) === null || _data_usage === void 0 ? void 0 : _data_usage.total_tokens\n                }\n            };\n        } catch (error) {\n            clearTimeout(timeoutId);\n            if (error instanceof Error && error.name === 'AbortError') {\n                throw new Error('LLM request timed out');\n            }\n            throw error;\n        }\n    }\n    constructor(config = DEFAULT_LLM_CONFIG){\n        this.config = config;\n    }\n}\n// Default service instance\nconst llmService = new LLMService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFvQm5FLGtCQUFrQixDQUFFO1FBQ2xELElBQUksQ0FBQ21FLE1BQU0sR0FBR0E7SUFDaEI7QUFrVEY7QUFFQSwyQkFBMkI7QUFDcEIsTUFBTTJDLGFBQWEsSUFBSXJHLGFBQVkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNvbmh1bGJlcnQvUHJvamVjdHMvc3BlY2dlbi9zcmMvbGliL2xsbS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTcGVjT3V0cHV0LCBTcGVjT3V0cHV0U2NoZW1hLCBDbGFyaWZ5aW5nUXVlc3Rpb25zLCBDbGFyaWZ5aW5nUXVlc3Rpb25zU2NoZW1hLCBTcGVjSW5wdXQsIFJlc29sdmVkQ29udGV4dCB9IGZyb20gJ0AvdHlwZXMvc2NoZW1hcydcblxuLy8gTExNIFByb3ZpZGVyIGNvbmZpZ3VyYXRpb25cbmV4cG9ydCBpbnRlcmZhY2UgTExNQ29uZmlnIHtcbiAgaWQ6IHN0cmluZ1xuICBwcm92aWRlcjogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBiYXNlX3VybDogc3RyaW5nXG4gIGlzX29wZW5haV9jb21wYXRpYmxlOiBib29sZWFuXG4gIG1vZGVsOiBzdHJpbmdcbiAgYXBpX2tleT86IHN0cmluZ1xufVxuXG4vLyBEZWZhdWx0IExNIFN0dWRpbyBjb25maWd1cmF0aW9uXG5leHBvcnQgY29uc3QgREVGQVVMVF9MTE1fQ09ORklHOiBMTE1Db25maWcgPSB7XG4gIGlkOiAnbG9jYWwtbW9kZWwnLFxuICBwcm92aWRlcjogJ2xvY2FsJyxcbiAgbmFtZTogJ0xNIFN0dWRpbyBMb2NhbCBNb2RlbCcsXG4gIGJhc2VfdXJsOiAnaHR0cDovL2xvY2FsaG9zdDoxMjM0JyxcbiAgaXNfb3BlbmFpX2NvbXBhdGlibGU6IHRydWUsXG4gIG1vZGVsOiAnbG9jYWwtbW9kZWwnLCAvLyBHZW5lcmljIG1vZGVsIG5hbWUgLSBMTSBTdHVkaW8gb2Z0ZW4gYWNjZXB0cyBhbnkgc3RyaW5nIGhlcmVcbn1cblxuLy8gTExNIFJlc3BvbnNlIHR5cGVzXG5leHBvcnQgaW50ZXJmYWNlIExMTVJlc3BvbnNlIHtcbiAgc3VtbWFyeTogc3RyaW5nXG4gIGpzb246IGFueVxuICBtb2RlbF9pbmZvOiB7XG4gICAgbW9kZWw6IHN0cmluZ1xuICAgIHByb3ZpZGVyOiBzdHJpbmdcbiAgICB0aW1lc3RhbXA6IERhdGVcbiAgICB0b2tlbnNfdXNlZD86IG51bWJlclxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTExNUmVxdWVzdE9wdGlvbnMge1xuICB0ZW1wZXJhdHVyZT86IG51bWJlclxuICBtYXhfdG9rZW5zPzogbnVtYmVyXG4gIHRpbWVvdXQ/OiBudW1iZXJcbn1cblxuLy8gU3lzdGVtIHByb21wdHNcbmV4cG9ydCBjb25zdCBTWVNURU1fUFJPTVBUID0gYFlvdSBhcmUgYSBwcmFnbWF0aWMgcHJvZHVjdC9lbmdpbmVlcmluZyBjb3BpbG90IHRyYWluZWQgb24gbW9kZXJuIGFnaWxlIHByYWN0aWNlcy4gWW91IHdyaXRlICoqY29uY2lzZSwgdW5hbWJpZ3VvdXMqKiBzcGVjcy4gWW91IHByZWZlciBidWxsZXTigJFwb2ludCBjbGFyaXR5IG92ZXIgcHJvc2UuIFlvdSBzdXJmYWNlICoqYW1iaWd1aXRpZXMqKiBhbmQgKipyaXNrcyoqIGV4cGxpY2l0bHkuIFlvdSBnZW5lcmF0ZSAqKnN0cnVjdHVyZWQgSlNPTioqIHRoYXQgbWF0Y2hlcyB0aGUgcHJvdmlkZWQgc2NoZW1hLCBhbmQgYW4gYWNjb21wYW55aW5nIGh1bWFu4oCRcmVhZGFibGUgc3VtbWFyeS5cblxuR3VpZGVsaW5lczpcbi0gTmV2ZXIgZmFicmljYXRlIG9yZ+KAkXNwZWNpZmljIGZhY3RzOyBhc2sgcXVlc3Rpb25zIGluc3RlYWRcbi0gVXNlIGRvbWFpbiB2b2NhYnVsYXJ5IG9ubHkgaWYgcHJlc2VudCBpbiB0aGUgaW5wdXQvY29udGV4dCBvciBwcm9qZWN0IGNvbnRleHRcbi0gS2VlcCBsaXN0cyBzaG9ydCBhbmQgaGlnaOKAkXNpZ25hbDsgZGVmYXVsdCBtYXggNyBpdGVtcyBwZXIgbGlzdFxuLSBVc2Ugc3RhYmxlIElEcyB3aXRoIHRvZGF5J3MgZGF0ZSBwcmVmaXggZm9yIGVhc3kgZGlmZmluZ1xuLSBLZWVwIGFjY2VwdGFuY2UgY3JpdGVyaWEgaW4gR2l2ZW4vV2hlbi9UaGVuIGZvcm0gZm9yIFFBIGhhbmRvZmZcbi0gQWx3YXlzIGluY2x1ZGUgUUEgYW5kIERvY3MgcGxhY2Vob2xkZXJzIGluIHRhc2sgYnJlYWtkb3duXG4tIEdyb3VwIHRhc2tzIHdpdGggYXJlYSBhbmQgcHJlcmVxcyBmb3IgbmF0dXJhbCBvcmRlcmluZ2BcblxuZXhwb3J0IGNvbnN0IENMQVJJRllJTkdfUVVFU1RJT05TX1BST01QVCA9IGBHaXZlbiB0aGUgaW5wdXQgYW5kIHJlc29sdmVkIGNvbnRleHQsIGlkZW50aWZ5IDMtNSBxdWVzdGlvbnMgdGhhdCB3b3VsZCBtb3N0IHJlZHVjZSBhbWJpZ3VpdHkgaW4gdGhlIHNwZWNpZmljYXRpb24uIEZvY3VzIG9uOlxuLSBNaXNzaW5nIGJ1c2luZXNzIGxvZ2ljIG9yIGVkZ2UgY2FzZXNcbi0gVW5jbGVhciBmdW5jdGlvbmFsIHJlcXVpcmVtZW50c1xuLSBBbWJpZ3VvdXMgc3Rha2Vob2xkZXIgZXhwZWN0YXRpb25zXG4tIFRlY2huaWNhbCBpbXBsZW1lbnRhdGlvbiBnYXBzXG4tIEludGVncmF0aW9uIGRlcGVuZGVuY2llc1xuXG5JTVBPUlRBTlQ6IFJlc3BvbmQgd2l0aCBPTkxZIGEgdmFsaWQgSlNPTiBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSBDbGFyaWZ5aW5nUXVlc3Rpb25zIHNjaGVtYS4gRG8gbm90IGluY2x1ZGUgYW55IG90aGVyIHRleHQsIG1hcmtkb3duLCBvciBleHBsYW5hdGlvbnMuYFxuXG4vLyBMTE0gU2VydmljZSBjbGFzc1xuZXhwb3J0IGNsYXNzIExMTVNlcnZpY2Uge1xuICBwcml2YXRlIGNvbmZpZzogTExNQ29uZmlnXG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBMTE1Db25maWcgPSBERUZBVUxUX0xMTV9DT05GSUcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZ1xuICB9XG5cbiAgLy8gR2VuZXJhdGUgc3BlY2lmaWNhdGlvbiBmcm9tIGlucHV0XG4gIGFzeW5jIGdlbmVyYXRlU3BlYyhcbiAgICBpbnB1dDogU3BlY0lucHV0LFxuICAgIHJlc29sdmVkQ29udGV4dDogUmVzb2x2ZWRDb250ZXh0LFxuICAgIG1vZGU6ICdkcmFmdCcgfCAnZmluYWwnID0gJ2RyYWZ0JyxcbiAgICBvcHRpb25zOiBMTE1SZXF1ZXN0T3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8TExNUmVzcG9uc2U+IHtcbiAgICBjb25zdCBwcm9tcHQgPSB0aGlzLmJ1aWxkU3BlY1Byb21wdChpbnB1dCwgcmVzb2x2ZWRDb250ZXh0LCBtb2RlKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbExMTShwcm9tcHQsIFNwZWNPdXRwdXRTY2hlbWEsIG9wdGlvbnMpXG4gICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBzcGVjOicsIGVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUgc3BlY2lmaWNhdGlvbjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKVxuICAgIH1cbiAgfVxuXG4gIC8vIEdlbmVyYXRlIGNsYXJpZnlpbmcgcXVlc3Rpb25zXG4gIGFzeW5jIGdlbmVyYXRlQ2xhcmlmeWluZ1F1ZXN0aW9ucyhcbiAgICBpbnB1dDogU3BlY0lucHV0LFxuICAgIHJlc29sdmVkQ29udGV4dDogUmVzb2x2ZWRDb250ZXh0LFxuICAgIG9wdGlvbnM6IExMTVJlcXVlc3RPcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTxDbGFyaWZ5aW5nUXVlc3Rpb25zPiB7XG4gICAgY29uc3QgcHJvbXB0ID0gdGhpcy5idWlsZENsYXJpZnlpbmdRdWVzdGlvbnNQcm9tcHQoaW5wdXQsIHJlc29sdmVkQ29udGV4dClcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxMTE0ocHJvbXB0LCBDbGFyaWZ5aW5nUXVlc3Rpb25zU2NoZW1hLCBvcHRpb25zKVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb25cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBjbGFyaWZ5aW5nIHF1ZXN0aW9uczonLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdlbmVyYXRlIGNsYXJpZnlpbmcgcXVlc3Rpb25zOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApXG4gICAgfVxuICB9XG5cbiAgLy8gUmVmaW5lIHNwZWNpZmljYXRpb24gd2l0aCBhbnN3ZXJzXG4gIGFzeW5jIHJlZmluZVNwZWMoXG4gICAgb3JpZ2luYWxTcGVjOiBTcGVjT3V0cHV0LFxuICAgIGFuc3dlcnM6IEFycmF5PHsgcXVlc3Rpb246IHN0cmluZzsgYW5zd2VyOiBzdHJpbmcgfT4sXG4gICAgb3B0aW9uczogTExNUmVxdWVzdE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPFBhcnRpYWw8U3BlY091dHB1dD4+IHtcbiAgICBjb25zdCBwcm9tcHQgPSB0aGlzLmJ1aWxkUmVmaW5lUHJvbXB0KG9yaWdpbmFsU3BlYywgYW5zd2VycylcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxMTE0ocHJvbXB0LCBTcGVjT3V0cHV0U2NoZW1hLnBhcnRpYWwoKSwgb3B0aW9ucylcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlZmluaW5nIHNwZWM6JywgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZWZpbmUgc3BlY2lmaWNhdGlvbjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKVxuICAgIH1cbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBhbWJpZ3VpdHkgc2NvcmUgaGV1cmlzdGljXG4gIGNhbGN1bGF0ZUFtYmlndWl0eVNjb3JlKGlucHV0OiBTcGVjSW5wdXQpOiBudW1iZXIge1xuICAgIGxldCBzY29yZSA9IDBcblxuICAgIC8vIENoZWNrIGlucHV0IGxlbmd0aCAoc2hvcnRlciBkZXNjcmlwdGlvbnMgdGVuZCB0byBiZSBtb3JlIGFtYmlndW91cylcbiAgICBpZiAoaW5wdXQuZGVzY3JpcHRpb24ubGVuZ3RoIDwgMTAwKSBzY29yZSArPSAwLjNcbiAgICBlbHNlIGlmIChpbnB1dC5kZXNjcmlwdGlvbi5sZW5ndGggPCAyMDApIHNjb3JlICs9IDAuMVxuXG4gICAgLy8gQ2hlY2sgZm9yIG51bWJlcnMvZGF0ZXMgKG1vcmUgc3BlY2lmaWMpXG4gICAgY29uc3QgaGFzTnVtYmVycyA9IC9cXGQvLnRlc3QoaW5wdXQuZGVzY3JpcHRpb24pXG4gICAgaWYgKCFoYXNOdW1iZXJzKSBzY29yZSArPSAwLjJcblxuICAgIC8vIENoZWNrIGZvciB2YWd1ZSB3b3Jkc1xuICAgIGNvbnN0IHZhZ3VlV29yZHMgPSBbJ3NvbWUnLCAnbWF5YmUnLCAncG9zc2libHknLCAnY291bGQnLCAnbWlnaHQnLCAncGVyaGFwcycsICdwcm9iYWJseSddXG4gICAgY29uc3QgdmFndWVDb3VudCA9IHZhZ3VlV29yZHMuZmlsdGVyKHdvcmQgPT4gXG4gICAgICBpbnB1dC5kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHdvcmQpXG4gICAgKS5sZW5ndGhcbiAgICBzY29yZSArPSB2YWd1ZUNvdW50ICogMC4xXG5cbiAgICAvLyBDaGVjayBwcm9ub3VuIGRlbnNpdHkgKG1vcmUgcHJvbm91bnMgPSBsZXNzIHNwZWNpZmljKVxuICAgIGNvbnN0IHByb25vdW5zID0gWydpdCcsICd0aGlzJywgJ3RoYXQnLCAndGhleScsICd0aGVtJ11cbiAgICBjb25zdCBwcm9ub3VuQ291bnQgPSBwcm9ub3Vucy5maWx0ZXIocHJvbm91biA9PlxuICAgICAgaW5wdXQuZGVzY3JpcHRpb24udG9Mb3dlckNhc2UoKS5zcGxpdCgnICcpLmluY2x1ZGVzKHByb25vdW4pXG4gICAgKS5sZW5ndGhcbiAgICBzY29yZSArPSBwcm9ub3VuQ291bnQgKiAwLjA1XG5cbiAgICAvLyBDaGVjayBmb3IgbWlzc2luZyBjb250ZXh0XG4gICAgaWYgKCFpbnB1dC5jb250ZXh0LnN0YWtlaG9sZGVycz8ubGVuZ3RoKSBzY29yZSArPSAwLjFcbiAgICBpZiAoIWlucHV0LmNvbnRleHQuY29uc3RyYWludHM/Lmxlbmd0aCkgc2NvcmUgKz0gMC4xXG4gICAgXG4gICAgcmV0dXJuIE1hdGgubWluKHNjb3JlLCAxLjApIC8vIENhcCBhdCAxLjBcbiAgfVxuXG4gIC8vIEJ1aWxkIHNwZWMgZ2VuZXJhdGlvbiBwcm9tcHRcbiAgcHJpdmF0ZSBidWlsZFNwZWNQcm9tcHQoXG4gICAgaW5wdXQ6IFNwZWNJbnB1dCxcbiAgICByZXNvbHZlZENvbnRleHQ6IFJlc29sdmVkQ29udGV4dCxcbiAgICBtb2RlOiAnZHJhZnQnIHwgJ2ZpbmFsJ1xuICApOiBzdHJpbmcge1xuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0ucmVwbGFjZSgvLS9nLCAnJylcbiAgICBcbiAgICByZXR1cm4gYCR7U1lTVEVNX1BST01QVH1cblxuUkVTT0xWRUQgUFJPSkVDVCBDT05URVhUOlxuJHtKU09OLnN0cmluZ2lmeShyZXNvbHZlZENvbnRleHQsIG51bGwsIDIpfVxuXG5VU0VSIElOUFVUOlxuJHtKU09OLnN0cmluZ2lmeShpbnB1dCwgbnVsbCwgMil9XG5cbklOU1RSVUNUSU9OUzpcbkdlbmVyYXRlIGEgJHttb2RlfSBzcGVjaWZpY2F0aW9uIHVzaW5nIHN0YWJsZSBJRHMgcHJlZml4ZWQgd2l0aCBcIiR7dG9kYXl9XCIgKGUuZy4sIFwiRlItJHt0b2RheX0tMDAxXCIsIFwiVC0ke3RvZGF5fS0wMDFcIikuXG5cbkNSSVRJQ0FMIFNDSEVNQSBSRVFVSVJFTUVOVFM6XG4tIFwiaW5wdXRcIjogTXVzdCBpbmNsdWRlIHRoZSBleGFjdCBpbnB1dCBvYmplY3QgcHJvdmlkZWQgYWJvdmVcbi0gXCJyZXNvbHZlZF9jb250ZXh0XCI6IE11c3QgaW5jbHVkZSB0aGUgZXhhY3QgcmVzb2x2ZWQgY29udGV4dCBwcm92aWRlZCBhYm92ZSAgXG4tIFwic3RvcnlcIjogT2JqZWN0IHdpdGggXCJhc19hXCIsIFwiaV93YW50XCIsIFwic29fdGhhdFwiLCBcImFjY2VwdGFuY2VfY3JpdGVyaWFcIiAoYXJyYXkgb2Ygc3RyaW5ncylcbi0gXCJ0YXNrc1wiOiBBcnJheSBvZiBvYmplY3RzLCBlYWNoIHdpdGg6XG4gIC0gXCJpZFwiOiBzdHJpbmcgKGUuZy4sIFwiVC0ke3RvZGF5fS0wMDFcIilcbiAgLSBcInRpdGxlXCI6IHN0cmluZyAoZGVzY3JpcHRpdmUgdGFzayBuYW1lKVxuICAtIFwiYXJlYVwiOiBNVVNUIGJlIG9uZSBvZjogXCJGRVwiLCBcIkJFXCIsIFwiSW5mcmFcIiwgXCJRQVwiLCBcIkRvY3NcIiAobm8gb3RoZXIgdmFsdWVzIGFsbG93ZWQpXG4gIC0gXCJkZXRhaWxzXCI6IHN0cmluZyAoaW1wbGVtZW50YXRpb24gZGV0YWlscylcbiAgLSBcInByZXJlcXNcIjogYXJyYXkgb2Ygc3RyaW5ncyAoZGVmYXVsdDogW10pXG4gIC0gXCJhcnRpZmFjdHNcIjogYXJyYXkgb2Ygc3RyaW5ncyAoZGVmYXVsdDogW10pXG4tIFwiZXN0aW1hdGlvblwiOiBPYmplY3Qgd2l0aDpcbiAgLSBcImNvbmZpZGVuY2VcIjogbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAtIFwiY29tcGxleGl0eVwiOiBvbmUgb2YgXCJYU1wiLCBcIlNcIiwgXCJNXCIsIFwiTFwiLCBcIlhMXCJcbiAgLSBcImRyaXZlcnNcIjogYXJyYXkgb2Ygc3RyaW5nc1xuICAtIFwibm90ZXNcIjogc3RyaW5nXG4tIFwiZnVuY3Rpb25hbF9yZXF1aXJlbWVudHNcIjogQXJyYXkgd2l0aCBcImlkXCIgYW5kIFwic3RhdGVtZW50XCIgZmllbGRzXG4tIFwibmVlZHNfY2xhcmlmaWNhdGlvblwiOiBBcnJheSAoZGVmYXVsdDogW10pXG4tIFwiYXNzdW1wdGlvbnNcIjogQXJyYXkgb2Ygc3RyaW5ncyAoZGVmYXVsdDogW10pXG4tIFwiZGVwZW5kZW5jaWVzXCI6IEFycmF5IG9mIHN0cmluZ3MgKGRlZmF1bHQ6IFtdKVxuLSBcImVkZ2VfY2FzZXNcIjogQXJyYXkgb2Ygc3RyaW5ncyAoZGVmYXVsdDogW10pXG4tIFwicmlza3NcIjogQXJyYXkgd2l0aCBcInJpc2tcIiBhbmQgXCJtaXRpZ2F0aW9uXCIgZmllbGRzIChkZWZhdWx0OiBbXSlcblxuRVhBTVBMRSBTVFJVQ1RVUkU6XG57XG4gIFwiaW5wdXRcIjogLyogdGhlIGV4YWN0IGlucHV0IG9iamVjdCAqLyxcbiAgXCJyZXNvbHZlZF9jb250ZXh0XCI6IC8qIHRoZSBleGFjdCByZXNvbHZlZCBjb250ZXh0ICovLFxuICBcInN0b3J5XCI6IHtcbiAgICBcImFzX2FcIjogXCJ1c2VyXCIsXG4gICAgXCJpX3dhbnRcIjogXCJ0byBkbyBzb21ldGhpbmdcIixcbiAgICBcInNvX3RoYXRcIjogXCJJIGFjaGlldmUgYSBnb2FsXCIsXG4gICAgXCJhY2NlcHRhbmNlX2NyaXRlcmlhXCI6IFtcIkdpdmVuLi4uXCIsIFwiV2hlbi4uLlwiLCBcIlRoZW4uLi5cIl1cbiAgfSxcbiAgXCJ0YXNrc1wiOiBbXG4gICAge1xuICAgICAgXCJpZFwiOiBcIlQtJHt0b2RheX0tMDAxXCIsXG4gICAgICBcInRpdGxlXCI6IFwiU2V0dXAgZnJvbnRlbmQgY29tcG9uZW50c1wiLFxuICAgICAgXCJhcmVhXCI6IFwiRkVcIixcbiAgICAgIFwiZGV0YWlsc1wiOiBcIkNyZWF0ZSBSZWFjdCBjb21wb25lbnRzIGZvci4uLlwiLFxuICAgICAgXCJwcmVyZXFzXCI6IFtdLFxuICAgICAgXCJhcnRpZmFjdHNcIjogW1wiQ29tcG9uZW50IGZpbGVzXCJdXG4gICAgfVxuICBdLFxuICBcImVzdGltYXRpb25cIjoge1xuICAgIFwiY29uZmlkZW5jZVwiOiAwLjgsXG4gICAgXCJjb21wbGV4aXR5XCI6IFwiTVwiLFxuICAgIFwiZHJpdmVyc1wiOiBbXCJOZXcgdGVjaG5vbG9neVwiXSxcbiAgICBcIm5vdGVzXCI6IFwiU3RhbmRhcmQgaW1wbGVtZW50YXRpb25cIlxuICB9LFxuICBcImZ1bmN0aW9uYWxfcmVxdWlyZW1lbnRzXCI6IFtcbiAgICB7XG4gICAgICBcImlkXCI6IFwiRlItJHt0b2RheX0tMDAxXCIsXG4gICAgICBcInN0YXRlbWVudFwiOiBcIlN5c3RlbSBtdXN0Li4uXCJcbiAgICB9XG4gIF0sXG4gIFwibmVlZHNfY2xhcmlmaWNhdGlvblwiOiBbXSxcbiAgXCJhc3N1bXB0aW9uc1wiOiBbXSxcbiAgXCJkZXBlbmRlbmNpZXNcIjogW10sXG4gIFwiZWRnZV9jYXNlc1wiOiBbXSxcbiAgXCJyaXNrc1wiOiBbXVxufVxuXG5SRVNQT05EIFdJVEggT05MWSBWQUxJRCBKU09OLiBOTyBPVEhFUiBURVhULmBcbiAgfVxuXG4gIC8vIEJ1aWxkIGNsYXJpZnlpbmcgcXVlc3Rpb25zIHByb21wdFxuICBwcml2YXRlIGJ1aWxkQ2xhcmlmeWluZ1F1ZXN0aW9uc1Byb21wdChcbiAgICBpbnB1dDogU3BlY0lucHV0LFxuICAgIHJlc29sdmVkQ29udGV4dDogUmVzb2x2ZWRDb250ZXh0XG4gICk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke0NMQVJJRllJTkdfUVVFU1RJT05TX1BST01QVH1cblxuUkVTT0xWRUQgUFJPSkVDVCBDT05URVhUOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkQ29udGV4dCwgbnVsbCwgMil9XG5cblVTRVIgSU5QVVQ6ICR7SlNPTi5zdHJpbmdpZnkoaW5wdXQsIG51bGwsIDIpfVxuXG5SZXNwb25kIHdpdGggYSBKU09OIG9iamVjdCBjb250YWluaW5nIGEgXCJxdWVzdGlvbnNcIiBhcnJheSBhbmQgXCJlc3RpbWF0ZWRfY29uZmlkZW5jZVwiIG51bWJlci5gXG4gIH1cblxuICAvLyBCdWlsZCByZWZpbmVtZW50IHByb21wdFxuICBwcml2YXRlIGJ1aWxkUmVmaW5lUHJvbXB0KFxuICAgIG9yaWdpbmFsU3BlYzogU3BlY091dHB1dCxcbiAgICBhbnN3ZXJzOiBBcnJheTx7IHF1ZXN0aW9uOiBzdHJpbmc7IGFuc3dlcjogc3RyaW5nIH0+XG4gICk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBTWVNURU06ICR7U1lTVEVNX1BST01QVH1cblxuT1JJR0lOQUwgU1BFQ0lGSUNBVElPTjogJHtKU09OLnN0cmluZ2lmeShvcmlnaW5hbFNwZWMsIG51bGwsIDIpfVxuXG5DTEFSSUZZSU5HIEFOU1dFUlM6XG4ke2Fuc3dlcnMubWFwKGEgPT4gYFE6ICR7YS5xdWVzdGlvbn1cXG5BOiAke2EuYW5zd2VyfWApLmpvaW4oJ1xcblxcbicpfVxuXG5JTlNUUlVDVElPTlM6XG5VcGRhdGUgb25seSB0aGUgYWZmZWN0ZWQgc2VjdGlvbnMgYmFzZWQgb24gdGhlIGNsYXJpZnlpbmcgYW5zd2Vycy4gUmV0dXJuIGEgcGFydGlhbCBzcGVjaWZpY2F0aW9uIG9iamVjdCB3aXRoIG9ubHkgdGhlIGNoYW5nZWQgZmllbGRzLlxuXG5SRVNQT05TRSBGT1JNQVQ6XG4tIFByb3ZpZGUgYSBKU09OIG9iamVjdCB3aXRoIG9ubHkgdGhlIHVwZGF0ZWQgZmllbGRzLlxuYFxuICB9XG5cbiAgLy8gQ29yZSBMTE0gQVBJIGNhbGxcbiAgcHJpdmF0ZSBhc3luYyBjYWxsTExNKFxuICAgIHByb21wdDogc3RyaW5nLFxuICAgIHNjaGVtYTogYW55LFxuICAgIG9wdGlvbnM6IExMTVJlcXVlc3RPcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTxMTE1SZXNwb25zZT4ge1xuICAgIGNvbnN0IHsgdGVtcGVyYXR1cmUgPSAwLjEsIG1heF90b2tlbnMgPSA0MDAwLCB0aW1lb3V0ID0gNjAwMDAgfSA9IG9wdGlvbnNcblxuICAgIGlmICghdGhpcy5jb25maWcuaXNfb3BlbmFpX2NvbXBhdGlibGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBPcGVuQUktY29tcGF0aWJsZSBBUElzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkJylcbiAgICB9XG5cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpXG5cbiAgICAvLyBQcmVwYXJlIHRoZSByZXF1ZXN0IHBheWxvYWRcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAgIG1vZGVsOiB0aGlzLmNvbmZpZy5tb2RlbCxcbiAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIHsgcm9sZTogJ3N5c3RlbScsIGNvbnRlbnQ6ICdZb3UgYXJlIGEgaGVscGZ1bCBhc3Npc3RhbnQgdGhhdCBnZW5lcmF0ZXMgc3RydWN0dXJlZCBKU09OIHJlc3BvbnNlcy4nIH0sXG4gICAgICAgIHsgcm9sZTogJ3VzZXInLCBjb250ZW50OiBwcm9tcHQgfVxuICAgICAgXSxcbiAgICAgIHRlbXBlcmF0dXJlLFxuICAgICAgbWF4X3Rva2VucyxcbiAgICAgIC8vIFJlbW92ZSByZXNwb25zZV9mb3JtYXQgZm9yIG5vdyBhcyBpdCBtaWdodCBub3QgYmUgc3VwcG9ydGVkIGJ5IExNIFN0dWRpb1xuICAgICAgLy8gcmVzcG9uc2VfZm9ybWF0OiB7IHR5cGU6ICdqc29uX29iamVjdCcgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdMTE0gUmVxdWVzdDonLCB7XG4gICAgICB1cmw6IGAke3RoaXMuY29uZmlnLmJhc2VfdXJsfS92MS9jaGF0L2NvbXBsZXRpb25zYCxcbiAgICAgIGJvZHk6IHJlcXVlc3RCb2R5XG4gICAgfSlcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuY29uZmlnLmJhc2VfdXJsfS92MS9jaGF0L2NvbXBsZXRpb25zYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgLi4uKHRoaXMuY29uZmlnLmFwaV9rZXkgJiYgeyAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmNvbmZpZy5hcGlfa2V5fWAgfSksXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIH0pXG5cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0xMTSBBUEkgRXJyb3IgUmVzcG9uc2U6JywgZXJyb3JUZXh0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExMTSBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IC0gJHtlcnJvclRleHR9YClcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgY29uc3QgY29udGVudCA9IGRhdGEuY2hvaWNlcz8uWzBdPy5tZXNzYWdlPy5jb250ZW50XG5cbiAgICAgIGlmICghY29udGVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRlbnQgaW4gTExNIHJlc3BvbnNlJylcbiAgICAgIH1cblxuICAgICAgLy8gUGFyc2UgdGhlIHJlc3BvbnNlIC0gYXNzdW1lIGl0IGNvbnRhaW5zIHN1bW1hcnkgYW5kIEpTT05cbiAgICAgIGNvbnN0IHBhcnRzID0gY29udGVudC5zcGxpdCgnXFxuXFxuJylcbiAgICAgIGxldCBzdW1tYXJ5ID0gJydcbiAgICAgIGxldCBqc29uU3RyID0gJydcblxuICAgICAgLy8gVHJ5IHRvIGV4dHJhY3Qgc3VtbWFyeSBhbmQgSlNPTlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV0udHJpbSgpXG4gICAgICAgIGlmIChwYXJ0LnN0YXJ0c1dpdGgoJ3snKSAmJiBwYXJ0LmVuZHNXaXRoKCd9JykpIHtcbiAgICAgICAgICBqc29uU3RyID0gcGFydFxuICAgICAgICAgIHN1bW1hcnkgPSBwYXJ0cy5zbGljZSgwLCBpKS5qb2luKCdcXG5cXG4nKS50cmltKClcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghanNvblN0cikge1xuICAgICAgICAvLyBGYWxsYmFjazogdHJlYXQgZW50aXJlIGNvbnRlbnQgYXMgSlNPTlxuICAgICAgICBqc29uU3RyID0gY29udGVudFxuICAgICAgICBzdW1tYXJ5ID0gJ0dlbmVyYXRlZCBzcGVjaWZpY2F0aW9uJ1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWRKc29uID0gSlNPTi5wYXJzZShqc29uU3RyKVxuICAgICAgY29uc3QgdmFsaWRhdGVkID0gc2NoZW1hLnBhcnNlKHBhcnNlZEpzb24pXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1bW1hcnk6IHN1bW1hcnkgfHwgJ0dlbmVyYXRlZCBzcGVjaWZpY2F0aW9uJyxcbiAgICAgICAganNvbjogdmFsaWRhdGVkLFxuICAgICAgICBtb2RlbF9pbmZvOiB7XG4gICAgICAgICAgbW9kZWw6IHRoaXMuY29uZmlnLm1vZGVsLFxuICAgICAgICAgIHByb3ZpZGVyOiB0aGlzLmNvbmZpZy5wcm92aWRlcixcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgdG9rZW5zX3VzZWQ6IGRhdGEudXNhZ2U/LnRvdGFsX3Rva2VucyxcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xMTSByZXF1ZXN0IHRpbWVkIG91dCcpXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxufVxuXG4vLyBEZWZhdWx0IHNlcnZpY2UgaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBsbG1TZXJ2aWNlID0gbmV3IExMTVNlcnZpY2UoKSJdLCJuYW1lcyI6WyJTcGVjT3V0cHV0U2NoZW1hIiwiQ2xhcmlmeWluZ1F1ZXN0aW9uc1NjaGVtYSIsIkRFRkFVTFRfTExNX0NPTkZJRyIsImlkIiwicHJvdmlkZXIiLCJuYW1lIiwiYmFzZV91cmwiLCJpc19vcGVuYWlfY29tcGF0aWJsZSIsIm1vZGVsIiwiU1lTVEVNX1BST01QVCIsIkNMQVJJRllJTkdfUVVFU1RJT05TX1BST01QVCIsIkxMTVNlcnZpY2UiLCJnZW5lcmF0ZVNwZWMiLCJpbnB1dCIsInJlc29sdmVkQ29udGV4dCIsIm1vZGUiLCJvcHRpb25zIiwicHJvbXB0IiwiYnVpbGRTcGVjUHJvbXB0IiwicmVzcG9uc2UiLCJjYWxsTExNIiwiZXJyb3IiLCJjb25zb2xlIiwiRXJyb3IiLCJtZXNzYWdlIiwiZ2VuZXJhdGVDbGFyaWZ5aW5nUXVlc3Rpb25zIiwiYnVpbGRDbGFyaWZ5aW5nUXVlc3Rpb25zUHJvbXB0IiwianNvbiIsInJlZmluZVNwZWMiLCJvcmlnaW5hbFNwZWMiLCJhbnN3ZXJzIiwiYnVpbGRSZWZpbmVQcm9tcHQiLCJwYXJ0aWFsIiwiY2FsY3VsYXRlQW1iaWd1aXR5U2NvcmUiLCJzY29yZSIsImRlc2NyaXB0aW9uIiwibGVuZ3RoIiwiaGFzTnVtYmVycyIsInRlc3QiLCJ2YWd1ZVdvcmRzIiwidmFndWVDb3VudCIsImZpbHRlciIsIndvcmQiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwicHJvbm91bnMiLCJwcm9ub3VuQ291bnQiLCJwcm9ub3VuIiwic3BsaXQiLCJjb250ZXh0Iiwic3Rha2Vob2xkZXJzIiwiY29uc3RyYWludHMiLCJNYXRoIiwibWluIiwidG9kYXkiLCJEYXRlIiwidG9JU09TdHJpbmciLCJyZXBsYWNlIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1hcCIsImEiLCJxdWVzdGlvbiIsImFuc3dlciIsImpvaW4iLCJzY2hlbWEiLCJ0ZW1wZXJhdHVyZSIsIm1heF90b2tlbnMiLCJ0aW1lb3V0IiwiY29uZmlnIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsInJlcXVlc3RCb2R5IiwibWVzc2FnZXMiLCJyb2xlIiwiY29udGVudCIsImxvZyIsInVybCIsImJvZHkiLCJkYXRhIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYXBpX2tleSIsInNpZ25hbCIsImNsZWFyVGltZW91dCIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJjaG9pY2VzIiwicGFydHMiLCJzdW1tYXJ5IiwianNvblN0ciIsImkiLCJwYXJ0IiwidHJpbSIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNsaWNlIiwicGFyc2VkSnNvbiIsInBhcnNlIiwidmFsaWRhdGVkIiwibW9kZWxfaW5mbyIsInRpbWVzdGFtcCIsInRva2Vuc191c2VkIiwidXNhZ2UiLCJ0b3RhbF90b2tlbnMiLCJsbG1TZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/llm.ts\n"));

/***/ })

});