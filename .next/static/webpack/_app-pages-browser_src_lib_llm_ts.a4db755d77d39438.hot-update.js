"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_lib_llm_ts",{

/***/ "(app-pages-browser)/./src/lib/llm.ts":
/*!************************!*\
  !*** ./src/lib/llm.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CLARIFYING_QUESTIONS_PROMPT: () => (/* binding */ CLARIFYING_QUESTIONS_PROMPT),\n/* harmony export */   DEFAULT_LLM_CONFIG: () => (/* binding */ DEFAULT_LLM_CONFIG),\n/* harmony export */   LLMService: () => (/* binding */ LLMService),\n/* harmony export */   SYSTEM_PROMPT: () => (/* binding */ SYSTEM_PROMPT),\n/* harmony export */   llmService: () => (/* binding */ llmService)\n/* harmony export */ });\n/* harmony import */ var _types_schemas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types/schemas */ \"(app-pages-browser)/./src/types/schemas.ts\");\n\n// Default LM Studio configuration\nconst DEFAULT_LLM_CONFIG = {\n    id: 'local-model',\n    provider: 'local',\n    name: 'LM Studio Local Model',\n    base_url: 'http://localhost:1234',\n    is_openai_compatible: true,\n    model: 'local-model'\n};\n// System prompts\nconst SYSTEM_PROMPT = \"You are a pragmatic product/engineering copilot trained on modern agile practices. You write **concise, unambiguous** specs. You prefer bullet‑point clarity over prose. You surface **ambiguities** and **risks** explicitly. You generate **structured JSON** that matches the provided schema, and an accompanying human‑readable summary.\\n\\nGuidelines:\\n- Never fabricate org‑specific facts; ask questions instead\\n- Use domain vocabulary only if present in the input/context or project context\\n- Keep lists short and high‑signal; default max 7 items per list\\n- Use stable IDs with today's date prefix for easy diffing\\n- Keep acceptance criteria in Given/When/Then form for QA handoff\\n- Always include QA and Docs placeholders in task breakdown\\n- Group tasks with area and prereqs for natural ordering\";\nconst CLARIFYING_QUESTIONS_PROMPT = \"Given the input and resolved context, identify 3-5 questions that would most reduce ambiguity in the specification. Focus on:\\n- Missing business logic or edge cases\\n- Unclear functional requirements\\n- Ambiguous stakeholder expectations\\n- Technical implementation gaps\\n- Integration dependencies\\n\\nIMPORTANT: Respond with ONLY a valid JSON object that matches the ClarifyingQuestions schema. Do not include any other text, markdown, or explanations.\";\n// LLM Service class\nclass LLMService {\n    // Generate specification from input\n    async generateSpec(input, resolvedContext) {\n        let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'draft', options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        const prompt = this.buildSpecPrompt(input, resolvedContext, mode);\n        try {\n            const response = await this.callLLM(prompt, _types_schemas__WEBPACK_IMPORTED_MODULE_0__.SpecOutputSchema, options);\n            return response;\n        } catch (error) {\n            console.error('Error generating spec:', error);\n            throw new Error(\"Failed to generate specification: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Generate clarifying questions\n    async generateClarifyingQuestions(input, resolvedContext) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const prompt = this.buildClarifyingQuestionsPrompt(input, resolvedContext);\n        try {\n            const response = await this.callLLM(prompt, _types_schemas__WEBPACK_IMPORTED_MODULE_0__.ClarifyingQuestionsSchema, options);\n            return response.json;\n        } catch (error) {\n            console.error('Error generating clarifying questions:', error);\n            throw new Error(\"Failed to generate clarifying questions: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Refine specification with answers\n    async refineSpec(originalSpec, answers) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const prompt = this.buildRefinePrompt(originalSpec, answers);\n        try {\n            const response = await this.callLLM(prompt, _types_schemas__WEBPACK_IMPORTED_MODULE_0__.SpecOutputSchema.partial(), options);\n            return response.json;\n        } catch (error) {\n            console.error('Error refining spec:', error);\n            throw new Error(\"Failed to refine specification: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Calculate ambiguity score heuristic\n    calculateAmbiguityScore(input) {\n        var _input_context_stakeholders, _input_context_constraints;\n        let score = 0;\n        // Check input length (shorter descriptions tend to be more ambiguous)\n        if (input.description.length < 100) score += 0.3;\n        else if (input.description.length < 200) score += 0.1;\n        // Check for numbers/dates (more specific)\n        const hasNumbers = /\\d/.test(input.description);\n        if (!hasNumbers) score += 0.2;\n        // Check for vague words\n        const vagueWords = [\n            'some',\n            'maybe',\n            'possibly',\n            'could',\n            'might',\n            'perhaps',\n            'probably'\n        ];\n        const vagueCount = vagueWords.filter((word)=>input.description.toLowerCase().includes(word)).length;\n        score += vagueCount * 0.1;\n        // Check pronoun density (more pronouns = less specific)\n        const pronouns = [\n            'it',\n            'this',\n            'that',\n            'they',\n            'them'\n        ];\n        const pronounCount = pronouns.filter((pronoun)=>input.description.toLowerCase().split(' ').includes(pronoun)).length;\n        score += pronounCount * 0.05;\n        // Check for missing context\n        if (!((_input_context_stakeholders = input.context.stakeholders) === null || _input_context_stakeholders === void 0 ? void 0 : _input_context_stakeholders.length)) score += 0.1;\n        if (!((_input_context_constraints = input.context.constraints) === null || _input_context_constraints === void 0 ? void 0 : _input_context_constraints.length)) score += 0.1;\n        return Math.min(score, 1.0) // Cap at 1.0\n        ;\n    }\n    // Build spec generation prompt\n    buildSpecPrompt(input, resolvedContext, mode) {\n        const today = new Date().toISOString().split('T')[0].replace(/-/g, '');\n        return \"\".concat(SYSTEM_PROMPT, \"\\n\\nRESOLVED PROJECT CONTEXT:\\n\").concat(JSON.stringify(resolvedContext, null, 2), \"\\n\\nUSER INPUT:\\n\").concat(JSON.stringify(input, null, 2), \"\\n\\nINSTRUCTIONS:\\nGenerate a \").concat(mode, ' specification using stable IDs prefixed with \"').concat(today, '\" (e.g., \"FR-').concat(today, '-001\", \"T-').concat(today, '-001\").\\n\\nCRITICAL SCHEMA REQUIREMENTS:\\n- \"input\": Must include the exact input object provided above\\n- \"resolved_context\": Must include the exact resolved context provided above  \\n- \"story\": Object with \"as_a\", \"i_want\", \"so_that\", \"acceptance_criteria\" (array of strings)\\n- \"tasks\": Array of objects, each with:\\n  - \"id\": string (e.g., \"T-').concat(today, '-001\")\\n  - \"title\": string (descriptive task name)\\n  - \"area\": MUST be one of: \"FE\", \"BE\", \"Infra\", \"QA\", \"Docs\" (no other values allowed)\\n  - \"details\": string (implementation details)\\n  - \"prereqs\": array of strings (default: [])\\n  - \"artifacts\": array of strings (default: [])\\n- \"estimation\": Object with:\\n  - \"confidence\": number between 0 and 1\\n  - \"complexity\": one of \"XS\", \"S\", \"M\", \"L\", \"XL\"\\n  - \"drivers\": array of strings\\n  - \"notes\": string\\n- \"functional_requirements\": Array with \"id\" and \"statement\" fields\\n- \"needs_clarification\": Array (default: [])\\n- \"assumptions\": Array of strings (default: [])\\n- \"dependencies\": Array of strings (default: [])\\n- \"edge_cases\": Array of strings (default: [])\\n- \"risks\": Array with \"risk\" and \"mitigation\" fields (default: [])\\n\\nEXAMPLE STRUCTURE:\\n{\\n  \"input\": /* the exact input object */,\\n  \"resolved_context\": /* the exact resolved context */,\\n  \"story\": {\\n    \"as_a\": \"user\",\\n    \"i_want\": \"to do something\",\\n    \"so_that\": \"I achieve a goal\",\\n    \"acceptance_criteria\": [\"Given...\", \"When...\", \"Then...\"]\\n  },\\n  \"tasks\": [\\n    {\\n      \"id\": \"T-').concat(today, '-001\",\\n      \"title\": \"Setup frontend components\",\\n      \"area\": \"FE\",\\n      \"details\": \"Create React components for...\",\\n      \"prereqs\": [],\\n      \"artifacts\": [\"Component files\"]\\n    }\\n  ],\\n  \"estimation\": {\\n    \"confidence\": 0.8,\\n    \"complexity\": \"M\",\\n    \"drivers\": [\"New technology\"],\\n    \"notes\": \"Standard implementation\"\\n  },\\n  \"functional_requirements\": [\\n    {\\n      \"id\": \"FR-').concat(today, '-001\",\\n      \"statement\": \"System must...\"\\n    }\\n  ],\\n  \"needs_clarification\": [],\\n  \"assumptions\": [],\\n  \"dependencies\": [],\\n  \"edge_cases\": [],\\n  \"risks\": []\\n}\\n\\nRESPOND WITH ONLY VALID JSON. NO OTHER TEXT.');\n    }\n    // Build clarifying questions prompt\n    buildClarifyingQuestionsPrompt(input, resolvedContext) {\n        return \"\".concat(CLARIFYING_QUESTIONS_PROMPT, \"\\n\\nRESOLVED PROJECT CONTEXT: \").concat(JSON.stringify(resolvedContext, null, 2), \"\\n\\nUSER INPUT: \").concat(JSON.stringify(input, null, 2), '\\n\\nRespond with a JSON object containing a \"questions\" array and \"estimated_confidence\" number.');\n    }\n    // Build refinement prompt\n    buildRefinePrompt(originalSpec, answers) {\n        return \"SYSTEM: \".concat(SYSTEM_PROMPT, \"\\n\\nORIGINAL SPECIFICATION: \").concat(JSON.stringify(originalSpec, null, 2), \"\\n\\nCLARIFYING ANSWERS:\\n\").concat(answers.map((a)=>\"Q: \".concat(a.question, \"\\nA: \").concat(a.answer)).join('\\n\\n'), \"\\n\\nINSTRUCTIONS:\\nUpdate only the affected sections based on the clarifying answers. Return a partial specification object with only the changed fields.\\n\\nRESPONSE FORMAT:\\n- Provide a JSON object with only the updated fields.\\n\");\n    }\n    // Core LLM API call\n    async callLLM(prompt, schema) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const { temperature = 0.1, max_tokens = 4000, timeout = 60000 } = options;\n        if (!this.config.is_openai_compatible) {\n            throw new Error('Only OpenAI-compatible APIs are currently supported');\n        }\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), timeout);\n        // Prepare the request payload\n        const requestBody = {\n            model: this.config.model,\n            messages: [\n                {\n                    role: 'system',\n                    content: 'You are a helpful assistant that generates structured JSON responses.'\n                },\n                {\n                    role: 'user',\n                    content: prompt\n                }\n            ],\n            temperature,\n            max_tokens\n        };\n        console.log('LLM Request:', {\n            url: \"\".concat(this.config.base_url, \"/v1/chat/completions\"),\n            body: requestBody\n        });\n        try {\n            var _data_choices__message, _data_choices_, _data_choices, _data_usage;\n            const response = await fetch(\"\".concat(this.config.base_url, \"/v1/chat/completions\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    ...this.config.api_key && {\n                        'Authorization': \"Bearer \".concat(this.config.api_key)\n                    }\n                },\n                body: JSON.stringify(requestBody),\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('LLM API Error Response:', errorText);\n                throw new Error(\"LLM API error: \".concat(response.status, \" \").concat(response.statusText, \" - \").concat(errorText));\n            }\n            const data = await response.json();\n            const content = (_data_choices = data.choices) === null || _data_choices === void 0 ? void 0 : (_data_choices_ = _data_choices[0]) === null || _data_choices_ === void 0 ? void 0 : (_data_choices__message = _data_choices_.message) === null || _data_choices__message === void 0 ? void 0 : _data_choices__message.content;\n            if (!content) {\n                throw new Error('No content in LLM response');\n            }\n            console.log('Raw LLM Response:', content);\n            // Try to parse as direct JSON first\n            let parsedJson;\n            let summary = 'Generated specification';\n            try {\n                // First try to parse the entire content as JSON\n                parsedJson = JSON.parse(content.trim());\n            } catch (jsonError) {\n                // If that fails, try to extract JSON from the content\n                const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n                if (jsonMatch) {\n                    try {\n                        parsedJson = JSON.parse(jsonMatch[0]);\n                        // Extract summary from content before the JSON\n                        const summaryPart = content.substring(0, jsonMatch.index).trim();\n                        if (summaryPart) {\n                            summary = summaryPart;\n                        }\n                    } catch (extractError) {\n                        console.error('Failed to parse extracted JSON:', extractError);\n                        throw new Error(\"Failed to parse LLM response as JSON: \".concat(jsonError));\n                    }\n                } else {\n                    console.error('No JSON found in response:', content);\n                    throw new Error('No valid JSON found in LLM response');\n                }\n            }\n            console.log('Parsed JSON:', parsedJson);\n            // Validate against schema\n            const validated = schema.parse(parsedJson);\n            return {\n                summary: summary,\n                json: validated,\n                model_info: {\n                    model: this.config.model,\n                    provider: this.config.provider,\n                    timestamp: new Date(),\n                    tokens_used: (_data_usage = data.usage) === null || _data_usage === void 0 ? void 0 : _data_usage.total_tokens\n                }\n            };\n        } catch (error) {\n            clearTimeout(timeoutId);\n            if (error instanceof Error && error.name === 'AbortError') {\n                throw new Error('LLM request timed out');\n            }\n            throw error;\n        }\n    }\n    constructor(config = DEFAULT_LLM_CONFIG){\n        this.config = config;\n    }\n}\n// Default service instance\nconst llmService = new LLMService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFBWTZCLFlBQVk7Z0JBQ3ZDO1lBQ0Y7UUFDRixFQUFFLE9BQU8xRixPQUFPO1lBQ2RtRSxhQUFhaEI7WUFDYixJQUFJbkQsaUJBQWlCRSxTQUFTRixNQUFNaEIsSUFBSSxLQUFLLGNBQWM7Z0JBQ3pELE1BQU0sSUFBSWtCLE1BQU07WUFDbEI7WUFDQSxNQUFNRjtRQUNSO0lBQ0Y7SUE5VEEsWUFBWWdELFNBQW9CbkUsa0JBQWtCLENBQUU7UUFDbEQsSUFBSSxDQUFDbUUsTUFBTSxHQUFHQTtJQUNoQjtBQTZURjtBQUVBLDJCQUEyQjtBQUNwQixNQUFNMkMsYUFBYSxJQUFJckcsYUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL2phc29uaHVsYmVydC9Qcm9qZWN0cy9zcGVjZ2VuL3NyYy9saWIvbGxtLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNwZWNPdXRwdXQsIFNwZWNPdXRwdXRTY2hlbWEsIENsYXJpZnlpbmdRdWVzdGlvbnMsIENsYXJpZnlpbmdRdWVzdGlvbnNTY2hlbWEsIFNwZWNJbnB1dCwgUmVzb2x2ZWRDb250ZXh0IH0gZnJvbSAnQC90eXBlcy9zY2hlbWFzJ1xuXG4vLyBMTE0gUHJvdmlkZXIgY29uZmlndXJhdGlvblxuZXhwb3J0IGludGVyZmFjZSBMTE1Db25maWcge1xuICBpZDogc3RyaW5nXG4gIHByb3ZpZGVyOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIGJhc2VfdXJsOiBzdHJpbmdcbiAgaXNfb3BlbmFpX2NvbXBhdGlibGU6IGJvb2xlYW5cbiAgbW9kZWw6IHN0cmluZ1xuICBhcGlfa2V5Pzogc3RyaW5nXG59XG5cbi8vIERlZmF1bHQgTE0gU3R1ZGlvIGNvbmZpZ3VyYXRpb25cbmV4cG9ydCBjb25zdCBERUZBVUxUX0xMTV9DT05GSUc6IExMTUNvbmZpZyA9IHtcbiAgaWQ6ICdsb2NhbC1tb2RlbCcsXG4gIHByb3ZpZGVyOiAnbG9jYWwnLFxuICBuYW1lOiAnTE0gU3R1ZGlvIExvY2FsIE1vZGVsJyxcbiAgYmFzZV91cmw6ICdodHRwOi8vbG9jYWxob3N0OjEyMzQnLFxuICBpc19vcGVuYWlfY29tcGF0aWJsZTogdHJ1ZSxcbiAgbW9kZWw6ICdsb2NhbC1tb2RlbCcsIC8vIEdlbmVyaWMgbW9kZWwgbmFtZSAtIExNIFN0dWRpbyBvZnRlbiBhY2NlcHRzIGFueSBzdHJpbmcgaGVyZVxufVxuXG4vLyBMTE0gUmVzcG9uc2UgdHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgTExNUmVzcG9uc2Uge1xuICBzdW1tYXJ5OiBzdHJpbmdcbiAganNvbjogYW55XG4gIG1vZGVsX2luZm86IHtcbiAgICBtb2RlbDogc3RyaW5nXG4gICAgcHJvdmlkZXI6IHN0cmluZ1xuICAgIHRpbWVzdGFtcDogRGF0ZVxuICAgIHRva2Vuc191c2VkPzogbnVtYmVyXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMTE1SZXF1ZXN0T3B0aW9ucyB7XG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyXG4gIG1heF90b2tlbnM/OiBudW1iZXJcbiAgdGltZW91dD86IG51bWJlclxufVxuXG4vLyBTeXN0ZW0gcHJvbXB0c1xuZXhwb3J0IGNvbnN0IFNZU1RFTV9QUk9NUFQgPSBgWW91IGFyZSBhIHByYWdtYXRpYyBwcm9kdWN0L2VuZ2luZWVyaW5nIGNvcGlsb3QgdHJhaW5lZCBvbiBtb2Rlcm4gYWdpbGUgcHJhY3RpY2VzLiBZb3Ugd3JpdGUgKipjb25jaXNlLCB1bmFtYmlndW91cyoqIHNwZWNzLiBZb3UgcHJlZmVyIGJ1bGxldOKAkXBvaW50IGNsYXJpdHkgb3ZlciBwcm9zZS4gWW91IHN1cmZhY2UgKiphbWJpZ3VpdGllcyoqIGFuZCAqKnJpc2tzKiogZXhwbGljaXRseS4gWW91IGdlbmVyYXRlICoqc3RydWN0dXJlZCBKU09OKiogdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCBzY2hlbWEsIGFuZCBhbiBhY2NvbXBhbnlpbmcgaHVtYW7igJFyZWFkYWJsZSBzdW1tYXJ5LlxuXG5HdWlkZWxpbmVzOlxuLSBOZXZlciBmYWJyaWNhdGUgb3Jn4oCRc3BlY2lmaWMgZmFjdHM7IGFzayBxdWVzdGlvbnMgaW5zdGVhZFxuLSBVc2UgZG9tYWluIHZvY2FidWxhcnkgb25seSBpZiBwcmVzZW50IGluIHRoZSBpbnB1dC9jb250ZXh0IG9yIHByb2plY3QgY29udGV4dFxuLSBLZWVwIGxpc3RzIHNob3J0IGFuZCBoaWdo4oCRc2lnbmFsOyBkZWZhdWx0IG1heCA3IGl0ZW1zIHBlciBsaXN0XG4tIFVzZSBzdGFibGUgSURzIHdpdGggdG9kYXkncyBkYXRlIHByZWZpeCBmb3IgZWFzeSBkaWZmaW5nXG4tIEtlZXAgYWNjZXB0YW5jZSBjcml0ZXJpYSBpbiBHaXZlbi9XaGVuL1RoZW4gZm9ybSBmb3IgUUEgaGFuZG9mZlxuLSBBbHdheXMgaW5jbHVkZSBRQSBhbmQgRG9jcyBwbGFjZWhvbGRlcnMgaW4gdGFzayBicmVha2Rvd25cbi0gR3JvdXAgdGFza3Mgd2l0aCBhcmVhIGFuZCBwcmVyZXFzIGZvciBuYXR1cmFsIG9yZGVyaW5nYFxuXG5leHBvcnQgY29uc3QgQ0xBUklGWUlOR19RVUVTVElPTlNfUFJPTVBUID0gYEdpdmVuIHRoZSBpbnB1dCBhbmQgcmVzb2x2ZWQgY29udGV4dCwgaWRlbnRpZnkgMy01IHF1ZXN0aW9ucyB0aGF0IHdvdWxkIG1vc3QgcmVkdWNlIGFtYmlndWl0eSBpbiB0aGUgc3BlY2lmaWNhdGlvbi4gRm9jdXMgb246XG4tIE1pc3NpbmcgYnVzaW5lc3MgbG9naWMgb3IgZWRnZSBjYXNlc1xuLSBVbmNsZWFyIGZ1bmN0aW9uYWwgcmVxdWlyZW1lbnRzXG4tIEFtYmlndW91cyBzdGFrZWhvbGRlciBleHBlY3RhdGlvbnNcbi0gVGVjaG5pY2FsIGltcGxlbWVudGF0aW9uIGdhcHNcbi0gSW50ZWdyYXRpb24gZGVwZW5kZW5jaWVzXG5cbklNUE9SVEFOVDogUmVzcG9uZCB3aXRoIE9OTFkgYSB2YWxpZCBKU09OIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIENsYXJpZnlpbmdRdWVzdGlvbnMgc2NoZW1hLiBEbyBub3QgaW5jbHVkZSBhbnkgb3RoZXIgdGV4dCwgbWFya2Rvd24sIG9yIGV4cGxhbmF0aW9ucy5gXG5cbi8vIExMTSBTZXJ2aWNlIGNsYXNzXG5leHBvcnQgY2xhc3MgTExNU2VydmljZSB7XG4gIHByaXZhdGUgY29uZmlnOiBMTE1Db25maWdcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IExMTUNvbmZpZyA9IERFRkFVTFRfTExNX0NPTkZJRykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnXG4gIH1cblxuICAvLyBHZW5lcmF0ZSBzcGVjaWZpY2F0aW9uIGZyb20gaW5wdXRcbiAgYXN5bmMgZ2VuZXJhdGVTcGVjKFxuICAgIGlucHV0OiBTcGVjSW5wdXQsXG4gICAgcmVzb2x2ZWRDb250ZXh0OiBSZXNvbHZlZENvbnRleHQsXG4gICAgbW9kZTogJ2RyYWZ0JyB8ICdmaW5hbCcgPSAnZHJhZnQnLFxuICAgIG9wdGlvbnM6IExMTVJlcXVlc3RPcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTxMTE1SZXNwb25zZT4ge1xuICAgIGNvbnN0IHByb21wdCA9IHRoaXMuYnVpbGRTcGVjUHJvbXB0KGlucHV0LCByZXNvbHZlZENvbnRleHQsIG1vZGUpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsTExNKHByb21wdCwgU3BlY091dHB1dFNjaGVtYSwgb3B0aW9ucylcbiAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIHNwZWM6JywgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZW5lcmF0ZSBzcGVjaWZpY2F0aW9uOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApXG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgY2xhcmlmeWluZyBxdWVzdGlvbnNcbiAgYXN5bmMgZ2VuZXJhdGVDbGFyaWZ5aW5nUXVlc3Rpb25zKFxuICAgIGlucHV0OiBTcGVjSW5wdXQsXG4gICAgcmVzb2x2ZWRDb250ZXh0OiBSZXNvbHZlZENvbnRleHQsXG4gICAgb3B0aW9uczogTExNUmVxdWVzdE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPENsYXJpZnlpbmdRdWVzdGlvbnM+IHtcbiAgICBjb25zdCBwcm9tcHQgPSB0aGlzLmJ1aWxkQ2xhcmlmeWluZ1F1ZXN0aW9uc1Byb21wdChpbnB1dCwgcmVzb2x2ZWRDb250ZXh0KVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbExMTShwcm9tcHQsIENsYXJpZnlpbmdRdWVzdGlvbnNTY2hlbWEsIG9wdGlvbnMpXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIGNsYXJpZnlpbmcgcXVlc3Rpb25zOicsIGVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUgY2xhcmlmeWluZyBxdWVzdGlvbnM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YClcbiAgICB9XG4gIH1cblxuICAvLyBSZWZpbmUgc3BlY2lmaWNhdGlvbiB3aXRoIGFuc3dlcnNcbiAgYXN5bmMgcmVmaW5lU3BlYyhcbiAgICBvcmlnaW5hbFNwZWM6IFNwZWNPdXRwdXQsXG4gICAgYW5zd2VyczogQXJyYXk8eyBxdWVzdGlvbjogc3RyaW5nOyBhbnN3ZXI6IHN0cmluZyB9PixcbiAgICBvcHRpb25zOiBMTE1SZXF1ZXN0T3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8UGFydGlhbDxTcGVjT3V0cHV0Pj4ge1xuICAgIGNvbnN0IHByb21wdCA9IHRoaXMuYnVpbGRSZWZpbmVQcm9tcHQob3JpZ2luYWxTcGVjLCBhbnN3ZXJzKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbExMTShwcm9tcHQsIFNwZWNPdXRwdXRTY2hlbWEucGFydGlhbCgpLCBvcHRpb25zKVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb25cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVmaW5pbmcgc3BlYzonLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlZmluZSBzcGVjaWZpY2F0aW9uOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApXG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGFtYmlndWl0eSBzY29yZSBoZXVyaXN0aWNcbiAgY2FsY3VsYXRlQW1iaWd1aXR5U2NvcmUoaW5wdXQ6IFNwZWNJbnB1dCk6IG51bWJlciB7XG4gICAgbGV0IHNjb3JlID0gMFxuXG4gICAgLy8gQ2hlY2sgaW5wdXQgbGVuZ3RoIChzaG9ydGVyIGRlc2NyaXB0aW9ucyB0ZW5kIHRvIGJlIG1vcmUgYW1iaWd1b3VzKVxuICAgIGlmIChpbnB1dC5kZXNjcmlwdGlvbi5sZW5ndGggPCAxMDApIHNjb3JlICs9IDAuM1xuICAgIGVsc2UgaWYgKGlucHV0LmRlc2NyaXB0aW9uLmxlbmd0aCA8IDIwMCkgc2NvcmUgKz0gMC4xXG5cbiAgICAvLyBDaGVjayBmb3IgbnVtYmVycy9kYXRlcyAobW9yZSBzcGVjaWZpYylcbiAgICBjb25zdCBoYXNOdW1iZXJzID0gL1xcZC8udGVzdChpbnB1dC5kZXNjcmlwdGlvbilcbiAgICBpZiAoIWhhc051bWJlcnMpIHNjb3JlICs9IDAuMlxuXG4gICAgLy8gQ2hlY2sgZm9yIHZhZ3VlIHdvcmRzXG4gICAgY29uc3QgdmFndWVXb3JkcyA9IFsnc29tZScsICdtYXliZScsICdwb3NzaWJseScsICdjb3VsZCcsICdtaWdodCcsICdwZXJoYXBzJywgJ3Byb2JhYmx5J11cbiAgICBjb25zdCB2YWd1ZUNvdW50ID0gdmFndWVXb3Jkcy5maWx0ZXIod29yZCA9PiBcbiAgICAgIGlucHV0LmRlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMod29yZClcbiAgICApLmxlbmd0aFxuICAgIHNjb3JlICs9IHZhZ3VlQ291bnQgKiAwLjFcblxuICAgIC8vIENoZWNrIHByb25vdW4gZGVuc2l0eSAobW9yZSBwcm9ub3VucyA9IGxlc3Mgc3BlY2lmaWMpXG4gICAgY29uc3QgcHJvbm91bnMgPSBbJ2l0JywgJ3RoaXMnLCAndGhhdCcsICd0aGV5JywgJ3RoZW0nXVxuICAgIGNvbnN0IHByb25vdW5Db3VudCA9IHByb25vdW5zLmZpbHRlcihwcm9ub3VuID0+XG4gICAgICBpbnB1dC5kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpLnNwbGl0KCcgJykuaW5jbHVkZXMocHJvbm91bilcbiAgICApLmxlbmd0aFxuICAgIHNjb3JlICs9IHByb25vdW5Db3VudCAqIDAuMDVcblxuICAgIC8vIENoZWNrIGZvciBtaXNzaW5nIGNvbnRleHRcbiAgICBpZiAoIWlucHV0LmNvbnRleHQuc3Rha2Vob2xkZXJzPy5sZW5ndGgpIHNjb3JlICs9IDAuMVxuICAgIGlmICghaW5wdXQuY29udGV4dC5jb25zdHJhaW50cz8ubGVuZ3RoKSBzY29yZSArPSAwLjFcbiAgICBcbiAgICByZXR1cm4gTWF0aC5taW4oc2NvcmUsIDEuMCkgLy8gQ2FwIGF0IDEuMFxuICB9XG5cbiAgLy8gQnVpbGQgc3BlYyBnZW5lcmF0aW9uIHByb21wdFxuICBwcml2YXRlIGJ1aWxkU3BlY1Byb21wdChcbiAgICBpbnB1dDogU3BlY0lucHV0LFxuICAgIHJlc29sdmVkQ29udGV4dDogUmVzb2x2ZWRDb250ZXh0LFxuICAgIG1vZGU6ICdkcmFmdCcgfCAnZmluYWwnXG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXS5yZXBsYWNlKC8tL2csICcnKVxuICAgIFxuICAgIHJldHVybiBgJHtTWVNURU1fUFJPTVBUfVxuXG5SRVNPTFZFRCBQUk9KRUNUIENPTlRFWFQ6XG4ke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkQ29udGV4dCwgbnVsbCwgMil9XG5cblVTRVIgSU5QVVQ6XG4ke0pTT04uc3RyaW5naWZ5KGlucHV0LCBudWxsLCAyKX1cblxuSU5TVFJVQ1RJT05TOlxuR2VuZXJhdGUgYSAke21vZGV9IHNwZWNpZmljYXRpb24gdXNpbmcgc3RhYmxlIElEcyBwcmVmaXhlZCB3aXRoIFwiJHt0b2RheX1cIiAoZS5nLiwgXCJGUi0ke3RvZGF5fS0wMDFcIiwgXCJULSR7dG9kYXl9LTAwMVwiKS5cblxuQ1JJVElDQUwgU0NIRU1BIFJFUVVJUkVNRU5UUzpcbi0gXCJpbnB1dFwiOiBNdXN0IGluY2x1ZGUgdGhlIGV4YWN0IGlucHV0IG9iamVjdCBwcm92aWRlZCBhYm92ZVxuLSBcInJlc29sdmVkX2NvbnRleHRcIjogTXVzdCBpbmNsdWRlIHRoZSBleGFjdCByZXNvbHZlZCBjb250ZXh0IHByb3ZpZGVkIGFib3ZlICBcbi0gXCJzdG9yeVwiOiBPYmplY3Qgd2l0aCBcImFzX2FcIiwgXCJpX3dhbnRcIiwgXCJzb190aGF0XCIsIFwiYWNjZXB0YW5jZV9jcml0ZXJpYVwiIChhcnJheSBvZiBzdHJpbmdzKVxuLSBcInRhc2tzXCI6IEFycmF5IG9mIG9iamVjdHMsIGVhY2ggd2l0aDpcbiAgLSBcImlkXCI6IHN0cmluZyAoZS5nLiwgXCJULSR7dG9kYXl9LTAwMVwiKVxuICAtIFwidGl0bGVcIjogc3RyaW5nIChkZXNjcmlwdGl2ZSB0YXNrIG5hbWUpXG4gIC0gXCJhcmVhXCI6IE1VU1QgYmUgb25lIG9mOiBcIkZFXCIsIFwiQkVcIiwgXCJJbmZyYVwiLCBcIlFBXCIsIFwiRG9jc1wiIChubyBvdGhlciB2YWx1ZXMgYWxsb3dlZClcbiAgLSBcImRldGFpbHNcIjogc3RyaW5nIChpbXBsZW1lbnRhdGlvbiBkZXRhaWxzKVxuICAtIFwicHJlcmVxc1wiOiBhcnJheSBvZiBzdHJpbmdzIChkZWZhdWx0OiBbXSlcbiAgLSBcImFydGlmYWN0c1wiOiBhcnJheSBvZiBzdHJpbmdzIChkZWZhdWx0OiBbXSlcbi0gXCJlc3RpbWF0aW9uXCI6IE9iamVjdCB3aXRoOlxuICAtIFwiY29uZmlkZW5jZVwiOiBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gIC0gXCJjb21wbGV4aXR5XCI6IG9uZSBvZiBcIlhTXCIsIFwiU1wiLCBcIk1cIiwgXCJMXCIsIFwiWExcIlxuICAtIFwiZHJpdmVyc1wiOiBhcnJheSBvZiBzdHJpbmdzXG4gIC0gXCJub3Rlc1wiOiBzdHJpbmdcbi0gXCJmdW5jdGlvbmFsX3JlcXVpcmVtZW50c1wiOiBBcnJheSB3aXRoIFwiaWRcIiBhbmQgXCJzdGF0ZW1lbnRcIiBmaWVsZHNcbi0gXCJuZWVkc19jbGFyaWZpY2F0aW9uXCI6IEFycmF5IChkZWZhdWx0OiBbXSlcbi0gXCJhc3N1bXB0aW9uc1wiOiBBcnJheSBvZiBzdHJpbmdzIChkZWZhdWx0OiBbXSlcbi0gXCJkZXBlbmRlbmNpZXNcIjogQXJyYXkgb2Ygc3RyaW5ncyAoZGVmYXVsdDogW10pXG4tIFwiZWRnZV9jYXNlc1wiOiBBcnJheSBvZiBzdHJpbmdzIChkZWZhdWx0OiBbXSlcbi0gXCJyaXNrc1wiOiBBcnJheSB3aXRoIFwicmlza1wiIGFuZCBcIm1pdGlnYXRpb25cIiBmaWVsZHMgKGRlZmF1bHQ6IFtdKVxuXG5FWEFNUExFIFNUUlVDVFVSRTpcbntcbiAgXCJpbnB1dFwiOiAvKiB0aGUgZXhhY3QgaW5wdXQgb2JqZWN0ICovLFxuICBcInJlc29sdmVkX2NvbnRleHRcIjogLyogdGhlIGV4YWN0IHJlc29sdmVkIGNvbnRleHQgKi8sXG4gIFwic3RvcnlcIjoge1xuICAgIFwiYXNfYVwiOiBcInVzZXJcIixcbiAgICBcImlfd2FudFwiOiBcInRvIGRvIHNvbWV0aGluZ1wiLFxuICAgIFwic29fdGhhdFwiOiBcIkkgYWNoaWV2ZSBhIGdvYWxcIixcbiAgICBcImFjY2VwdGFuY2VfY3JpdGVyaWFcIjogW1wiR2l2ZW4uLi5cIiwgXCJXaGVuLi4uXCIsIFwiVGhlbi4uLlwiXVxuICB9LFxuICBcInRhc2tzXCI6IFtcbiAgICB7XG4gICAgICBcImlkXCI6IFwiVC0ke3RvZGF5fS0wMDFcIixcbiAgICAgIFwidGl0bGVcIjogXCJTZXR1cCBmcm9udGVuZCBjb21wb25lbnRzXCIsXG4gICAgICBcImFyZWFcIjogXCJGRVwiLFxuICAgICAgXCJkZXRhaWxzXCI6IFwiQ3JlYXRlIFJlYWN0IGNvbXBvbmVudHMgZm9yLi4uXCIsXG4gICAgICBcInByZXJlcXNcIjogW10sXG4gICAgICBcImFydGlmYWN0c1wiOiBbXCJDb21wb25lbnQgZmlsZXNcIl1cbiAgICB9XG4gIF0sXG4gIFwiZXN0aW1hdGlvblwiOiB7XG4gICAgXCJjb25maWRlbmNlXCI6IDAuOCxcbiAgICBcImNvbXBsZXhpdHlcIjogXCJNXCIsXG4gICAgXCJkcml2ZXJzXCI6IFtcIk5ldyB0ZWNobm9sb2d5XCJdLFxuICAgIFwibm90ZXNcIjogXCJTdGFuZGFyZCBpbXBsZW1lbnRhdGlvblwiXG4gIH0sXG4gIFwiZnVuY3Rpb25hbF9yZXF1aXJlbWVudHNcIjogW1xuICAgIHtcbiAgICAgIFwiaWRcIjogXCJGUi0ke3RvZGF5fS0wMDFcIixcbiAgICAgIFwic3RhdGVtZW50XCI6IFwiU3lzdGVtIG11c3QuLi5cIlxuICAgIH1cbiAgXSxcbiAgXCJuZWVkc19jbGFyaWZpY2F0aW9uXCI6IFtdLFxuICBcImFzc3VtcHRpb25zXCI6IFtdLFxuICBcImRlcGVuZGVuY2llc1wiOiBbXSxcbiAgXCJlZGdlX2Nhc2VzXCI6IFtdLFxuICBcInJpc2tzXCI6IFtdXG59XG5cblJFU1BPTkQgV0lUSCBPTkxZIFZBTElEIEpTT04uIE5PIE9USEVSIFRFWFQuYFxuICB9XG5cbiAgLy8gQnVpbGQgY2xhcmlmeWluZyBxdWVzdGlvbnMgcHJvbXB0XG4gIHByaXZhdGUgYnVpbGRDbGFyaWZ5aW5nUXVlc3Rpb25zUHJvbXB0KFxuICAgIGlucHV0OiBTcGVjSW5wdXQsXG4gICAgcmVzb2x2ZWRDb250ZXh0OiBSZXNvbHZlZENvbnRleHRcbiAgKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7Q0xBUklGWUlOR19RVUVTVElPTlNfUFJPTVBUfVxuXG5SRVNPTFZFRCBQUk9KRUNUIENPTlRFWFQ6ICR7SlNPTi5zdHJpbmdpZnkocmVzb2x2ZWRDb250ZXh0LCBudWxsLCAyKX1cblxuVVNFUiBJTlBVVDogJHtKU09OLnN0cmluZ2lmeShpbnB1dCwgbnVsbCwgMil9XG5cblJlc3BvbmQgd2l0aCBhIEpTT04gb2JqZWN0IGNvbnRhaW5pbmcgYSBcInF1ZXN0aW9uc1wiIGFycmF5IGFuZCBcImVzdGltYXRlZF9jb25maWRlbmNlXCIgbnVtYmVyLmBcbiAgfVxuXG4gIC8vIEJ1aWxkIHJlZmluZW1lbnQgcHJvbXB0XG4gIHByaXZhdGUgYnVpbGRSZWZpbmVQcm9tcHQoXG4gICAgb3JpZ2luYWxTcGVjOiBTcGVjT3V0cHV0LFxuICAgIGFuc3dlcnM6IEFycmF5PHsgcXVlc3Rpb246IHN0cmluZzsgYW5zd2VyOiBzdHJpbmcgfT5cbiAgKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYFNZU1RFTTogJHtTWVNURU1fUFJPTVBUfVxuXG5PUklHSU5BTCBTUEVDSUZJQ0FUSU9OOiAke0pTT04uc3RyaW5naWZ5KG9yaWdpbmFsU3BlYywgbnVsbCwgMil9XG5cbkNMQVJJRllJTkcgQU5TV0VSUzpcbiR7YW5zd2Vycy5tYXAoYSA9PiBgUTogJHthLnF1ZXN0aW9ufVxcbkE6ICR7YS5hbnN3ZXJ9YCkuam9pbignXFxuXFxuJyl9XG5cbklOU1RSVUNUSU9OUzpcblVwZGF0ZSBvbmx5IHRoZSBhZmZlY3RlZCBzZWN0aW9ucyBiYXNlZCBvbiB0aGUgY2xhcmlmeWluZyBhbnN3ZXJzLiBSZXR1cm4gYSBwYXJ0aWFsIHNwZWNpZmljYXRpb24gb2JqZWN0IHdpdGggb25seSB0aGUgY2hhbmdlZCBmaWVsZHMuXG5cblJFU1BPTlNFIEZPUk1BVDpcbi0gUHJvdmlkZSBhIEpTT04gb2JqZWN0IHdpdGggb25seSB0aGUgdXBkYXRlZCBmaWVsZHMuXG5gXG4gIH1cblxuICAvLyBDb3JlIExMTSBBUEkgY2FsbFxuICBwcml2YXRlIGFzeW5jIGNhbGxMTE0oXG4gICAgcHJvbXB0OiBzdHJpbmcsXG4gICAgc2NoZW1hOiBhbnksXG4gICAgb3B0aW9uczogTExNUmVxdWVzdE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPExMTVJlc3BvbnNlPiB7XG4gICAgY29uc3QgeyB0ZW1wZXJhdHVyZSA9IDAuMSwgbWF4X3Rva2VucyA9IDQwMDAsIHRpbWVvdXQgPSA2MDAwMCB9ID0gb3B0aW9uc1xuXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5pc19vcGVuYWlfY29tcGF0aWJsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IE9wZW5BSS1jb21wYXRpYmxlIEFQSXMgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dClcblxuICAgIC8vIFByZXBhcmUgdGhlIHJlcXVlc3QgcGF5bG9hZFxuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgbW9kZWw6IHRoaXMuY29uZmlnLm1vZGVsLFxuICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgeyByb2xlOiAnc3lzdGVtJywgY29udGVudDogJ1lvdSBhcmUgYSBoZWxwZnVsIGFzc2lzdGFudCB0aGF0IGdlbmVyYXRlcyBzdHJ1Y3R1cmVkIEpTT04gcmVzcG9uc2VzLicgfSxcbiAgICAgICAgeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6IHByb21wdCB9XG4gICAgICBdLFxuICAgICAgdGVtcGVyYXR1cmUsXG4gICAgICBtYXhfdG9rZW5zLFxuICAgICAgLy8gUmVtb3ZlIHJlc3BvbnNlX2Zvcm1hdCBmb3Igbm93IGFzIGl0IG1pZ2h0IG5vdCBiZSBzdXBwb3J0ZWQgYnkgTE0gU3R1ZGlvXG4gICAgICAvLyByZXNwb25zZV9mb3JtYXQ6IHsgdHlwZTogJ2pzb25fb2JqZWN0JyB9XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ0xMTSBSZXF1ZXN0OicsIHtcbiAgICAgIHVybDogYCR7dGhpcy5jb25maWcuYmFzZV91cmx9L3YxL2NoYXQvY29tcGxldGlvbnNgLFxuICAgICAgYm9keTogcmVxdWVzdEJvZHlcbiAgICB9KVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5jb25maWcuYmFzZV91cmx9L3YxL2NoYXQvY29tcGxldGlvbnNgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAuLi4odGhpcy5jb25maWcuYXBpX2tleSAmJiB7ICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuY29uZmlnLmFwaV9rZXl9YCB9KSxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgfSlcblxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgICAgY29uc29sZS5lcnJvcignTExNIEFQSSBFcnJvciBSZXNwb25zZTonLCBlcnJvclRleHQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTExNIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gLSAke2Vycm9yVGV4dH1gKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICBjb25zdCBjb250ZW50ID0gZGF0YS5jaG9pY2VzPy5bMF0/Lm1lc3NhZ2U/LmNvbnRlbnRcblxuICAgICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29udGVudCBpbiBMTE0gcmVzcG9uc2UnKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnUmF3IExMTSBSZXNwb25zZTonLCBjb250ZW50KVxuXG4gICAgICAvLyBUcnkgdG8gcGFyc2UgYXMgZGlyZWN0IEpTT04gZmlyc3RcbiAgICAgIGxldCBwYXJzZWRKc29uOiBhbnlcbiAgICAgIGxldCBzdW1tYXJ5ID0gJ0dlbmVyYXRlZCBzcGVjaWZpY2F0aW9uJ1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBGaXJzdCB0cnkgdG8gcGFyc2UgdGhlIGVudGlyZSBjb250ZW50IGFzIEpTT05cbiAgICAgICAgcGFyc2VkSnNvbiA9IEpTT04ucGFyc2UoY29udGVudC50cmltKCkpXG4gICAgICB9IGNhdGNoIChqc29uRXJyb3IpIHtcbiAgICAgICAgLy8gSWYgdGhhdCBmYWlscywgdHJ5IHRvIGV4dHJhY3QgSlNPTiBmcm9tIHRoZSBjb250ZW50XG4gICAgICAgIGNvbnN0IGpzb25NYXRjaCA9IGNvbnRlbnQubWF0Y2goL1xce1tcXHNcXFNdKlxcfS8pXG4gICAgICAgIGlmIChqc29uTWF0Y2gpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VkSnNvbiA9IEpTT04ucGFyc2UoanNvbk1hdGNoWzBdKVxuICAgICAgICAgICAgLy8gRXh0cmFjdCBzdW1tYXJ5IGZyb20gY29udGVudCBiZWZvcmUgdGhlIEpTT05cbiAgICAgICAgICAgIGNvbnN0IHN1bW1hcnlQYXJ0ID0gY29udGVudC5zdWJzdHJpbmcoMCwganNvbk1hdGNoLmluZGV4KS50cmltKClcbiAgICAgICAgICAgIGlmIChzdW1tYXJ5UGFydCkge1xuICAgICAgICAgICAgICBzdW1tYXJ5ID0gc3VtbWFyeVBhcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChleHRyYWN0RXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBleHRyYWN0ZWQgSlNPTjonLCBleHRyYWN0RXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBMTE0gcmVzcG9uc2UgYXMgSlNPTjogJHtqc29uRXJyb3J9YClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignTm8gSlNPTiBmb3VuZCBpbiByZXNwb25zZTonLCBjb250ZW50KVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgSlNPTiBmb3VuZCBpbiBMTE0gcmVzcG9uc2UnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdQYXJzZWQgSlNPTjonLCBwYXJzZWRKc29uKVxuXG4gICAgICAvLyBWYWxpZGF0ZSBhZ2FpbnN0IHNjaGVtYVxuICAgICAgY29uc3QgdmFsaWRhdGVkID0gc2NoZW1hLnBhcnNlKHBhcnNlZEpzb24pXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1bW1hcnk6IHN1bW1hcnksXG4gICAgICAgIGpzb246IHZhbGlkYXRlZCxcbiAgICAgICAgbW9kZWxfaW5mbzoge1xuICAgICAgICAgIG1vZGVsOiB0aGlzLmNvbmZpZy5tb2RlbCxcbiAgICAgICAgICBwcm92aWRlcjogdGhpcy5jb25maWcucHJvdmlkZXIsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIHRva2Vuc191c2VkOiBkYXRhLnVzYWdlPy50b3RhbF90b2tlbnMsXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMTE0gcmVxdWVzdCB0aW1lZCBvdXQnKVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cblxuLy8gRGVmYXVsdCBzZXJ2aWNlIGluc3RhbmNlXG5leHBvcnQgY29uc3QgbGxtU2VydmljZSA9IG5ldyBMTE1TZXJ2aWNlKCkiXSwibmFtZXMiOlsiU3BlY091dHB1dFNjaGVtYSIsIkNsYXJpZnlpbmdRdWVzdGlvbnNTY2hlbWEiLCJERUZBVUxUX0xMTV9DT05GSUciLCJpZCIsInByb3ZpZGVyIiwibmFtZSIsImJhc2VfdXJsIiwiaXNfb3BlbmFpX2NvbXBhdGlibGUiLCJtb2RlbCIsIlNZU1RFTV9QUk9NUFQiLCJDTEFSSUZZSU5HX1FVRVNUSU9OU19QUk9NUFQiLCJMTE1TZXJ2aWNlIiwiZ2VuZXJhdGVTcGVjIiwiaW5wdXQiLCJyZXNvbHZlZENvbnRleHQiLCJtb2RlIiwib3B0aW9ucyIsInByb21wdCIsImJ1aWxkU3BlY1Byb21wdCIsInJlc3BvbnNlIiwiY2FsbExMTSIsImVycm9yIiwiY29uc29sZSIsIkVycm9yIiwibWVzc2FnZSIsImdlbmVyYXRlQ2xhcmlmeWluZ1F1ZXN0aW9ucyIsImJ1aWxkQ2xhcmlmeWluZ1F1ZXN0aW9uc1Byb21wdCIsImpzb24iLCJyZWZpbmVTcGVjIiwib3JpZ2luYWxTcGVjIiwiYW5zd2VycyIsImJ1aWxkUmVmaW5lUHJvbXB0IiwicGFydGlhbCIsImNhbGN1bGF0ZUFtYmlndWl0eVNjb3JlIiwic2NvcmUiLCJkZXNjcmlwdGlvbiIsImxlbmd0aCIsImhhc051bWJlcnMiLCJ0ZXN0IiwidmFndWVXb3JkcyIsInZhZ3VlQ291bnQiLCJmaWx0ZXIiLCJ3b3JkIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsInByb25vdW5zIiwicHJvbm91bkNvdW50IiwicHJvbm91biIsInNwbGl0IiwiY29udGV4dCIsInN0YWtlaG9sZGVycyIsImNvbnN0cmFpbnRzIiwiTWF0aCIsIm1pbiIsInRvZGF5IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwicmVwbGFjZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJtYXAiLCJhIiwicXVlc3Rpb24iLCJhbnN3ZXIiLCJqb2luIiwic2NoZW1hIiwidGVtcGVyYXR1cmUiLCJtYXhfdG9rZW5zIiwidGltZW91dCIsImNvbmZpZyIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJyZXF1ZXN0Qm9keSIsIm1lc3NhZ2VzIiwicm9sZSIsImNvbnRlbnQiLCJsb2ciLCJ1cmwiLCJib2R5IiwiZGF0YSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImFwaV9rZXkiLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiLCJvayIsImVycm9yVGV4dCIsInRleHQiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiY2hvaWNlcyIsInBhcnNlZEpzb24iLCJzdW1tYXJ5IiwicGFyc2UiLCJ0cmltIiwianNvbkVycm9yIiwianNvbk1hdGNoIiwibWF0Y2giLCJzdW1tYXJ5UGFydCIsInN1YnN0cmluZyIsImluZGV4IiwiZXh0cmFjdEVycm9yIiwidmFsaWRhdGVkIiwibW9kZWxfaW5mbyIsInRpbWVzdGFtcCIsInRva2Vuc191c2VkIiwidXNhZ2UiLCJ0b3RhbF90b2tlbnMiLCJsbG1TZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/llm.ts\n"));

/***/ })

});