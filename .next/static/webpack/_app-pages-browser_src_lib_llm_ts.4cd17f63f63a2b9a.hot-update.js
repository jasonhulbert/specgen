"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_lib_llm_ts",{

/***/ "(app-pages-browser)/./src/lib/llm.ts":
/*!************************!*\
  !*** ./src/lib/llm.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CLARIFYING_QUESTIONS_PROMPT: () => (/* binding */ CLARIFYING_QUESTIONS_PROMPT),\n/* harmony export */   DEFAULT_LLM_CONFIG: () => (/* binding */ DEFAULT_LLM_CONFIG),\n/* harmony export */   LLMService: () => (/* binding */ LLMService),\n/* harmony export */   SYSTEM_PROMPT: () => (/* binding */ SYSTEM_PROMPT),\n/* harmony export */   llmService: () => (/* binding */ llmService)\n/* harmony export */ });\n/* harmony import */ var _types_schemas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types/schemas */ \"(app-pages-browser)/./src/types/schemas.ts\");\n\n// Default LM Studio configuration\nconst DEFAULT_LLM_CONFIG = {\n    id: 'local-model',\n    provider: 'local',\n    name: 'LM Studio Local Model',\n    base_url: 'http://localhost:1234',\n    is_openai_compatible: true,\n    model: 'local-model'\n};\n// System prompts\nconst SYSTEM_PROMPT = \"You are a pragmatic product/engineering copilot trained on modern agile practices. You write **concise, unambiguous** specs. You prefer bullet‑point clarity over prose. You surface **ambiguities** and **risks** explicitly. You generate **structured JSON** that matches the provided schema, and an accompanying human‑readable summary.\\n\\nGuidelines:\\n- Never fabricate org‑specific facts; ask questions instead\\n- Use domain vocabulary only if present in the input/context or project context\\n- Keep lists short and high‑signal; default max 7 items per list\\n- Use stable IDs with today's date prefix for easy diffing\\n- Keep acceptance criteria in Given/When/Then form for QA handoff\\n- Always include QA and Docs placeholders in task breakdown\\n- Group tasks with area and prereqs for natural ordering\";\nconst CLARIFYING_QUESTIONS_PROMPT = \"Given the input and resolved context, identify 3-5 questions that would most reduce ambiguity in the specification. Focus on:\\n- Missing business logic or edge cases\\n- Unclear functional requirements\\n- Ambiguous stakeholder expectations\\n- Technical implementation gaps\\n- Integration dependencies\\n\\nIMPORTANT: Respond with ONLY a valid JSON object that matches the ClarifyingQuestions schema. Do not include any other text, markdown, or explanations.\";\n// LLM Service class\nclass LLMService {\n    // Generate specification from input\n    async generateSpec(input, resolvedContext) {\n        let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'draft', options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        const prompt = this.buildSpecPrompt(input, resolvedContext, mode);\n        try {\n            const response = await this.callLLM(prompt, _types_schemas__WEBPACK_IMPORTED_MODULE_0__.SpecOutputSchema, options);\n            return response;\n        } catch (error) {\n            console.error('Error generating spec:', error);\n            throw new Error(\"Failed to generate specification: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Generate clarifying questions\n    async generateClarifyingQuestions(input, resolvedContext) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const prompt = this.buildClarifyingQuestionsPrompt(input, resolvedContext);\n        try {\n            const response = await this.callLLM(prompt, _types_schemas__WEBPACK_IMPORTED_MODULE_0__.ClarifyingQuestionsSchema, options);\n            return response.json;\n        } catch (error) {\n            console.error('Error generating clarifying questions:', error);\n            throw new Error(\"Failed to generate clarifying questions: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Refine specification with answers\n    async refineSpec(originalSpec, answers) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const prompt = this.buildRefinePrompt(originalSpec, answers);\n        try {\n            const response = await this.callLLM(prompt, _types_schemas__WEBPACK_IMPORTED_MODULE_0__.SpecOutputSchema.partial(), options);\n            return response.json;\n        } catch (error) {\n            console.error('Error refining spec:', error);\n            throw new Error(\"Failed to refine specification: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Calculate ambiguity score heuristic\n    calculateAmbiguityScore(input) {\n        var _input_context_stakeholders, _input_context_constraints;\n        let score = 0;\n        // Check input length (shorter descriptions tend to be more ambiguous)\n        if (input.description.length < 100) score += 0.3;\n        else if (input.description.length < 200) score += 0.1;\n        // Check for numbers/dates (more specific)\n        const hasNumbers = /\\d/.test(input.description);\n        if (!hasNumbers) score += 0.2;\n        // Check for vague words\n        const vagueWords = [\n            'some',\n            'maybe',\n            'possibly',\n            'could',\n            'might',\n            'perhaps',\n            'probably'\n        ];\n        const vagueCount = vagueWords.filter((word)=>input.description.toLowerCase().includes(word)).length;\n        score += vagueCount * 0.1;\n        // Check pronoun density (more pronouns = less specific)\n        const pronouns = [\n            'it',\n            'this',\n            'that',\n            'they',\n            'them'\n        ];\n        const pronounCount = pronouns.filter((pronoun)=>input.description.toLowerCase().split(' ').includes(pronoun)).length;\n        score += pronounCount * 0.05;\n        // Check for missing context\n        if (!((_input_context_stakeholders = input.context.stakeholders) === null || _input_context_stakeholders === void 0 ? void 0 : _input_context_stakeholders.length)) score += 0.1;\n        if (!((_input_context_constraints = input.context.constraints) === null || _input_context_constraints === void 0 ? void 0 : _input_context_constraints.length)) score += 0.1;\n        return Math.min(score, 1.0) // Cap at 1.0\n        ;\n    }\n    // Build spec generation prompt\n    buildSpecPrompt(input, resolvedContext, mode) {\n        const today = new Date().toISOString().split('T')[0].replace(/-/g, '');\n        return \"SYSTEM: \".concat(SYSTEM_PROMPT, \"\\n\\nRESOLVED PROJECT CONTEXT (YAML):\\ncontext:\\n  glossary: \").concat(JSON.stringify(resolvedContext.glossary, null, 2), \"\\n  stakeholders: \").concat(JSON.stringify(resolvedContext.stakeholders, null, 2), \"\\n  constraints: \").concat(JSON.stringify(resolvedContext.constraints, null, 2), \"\\n  non_functional: \").concat(JSON.stringify(resolvedContext.non_functional, null, 2), \"\\n  api_catalog: \").concat(JSON.stringify(resolvedContext.api_catalog, null, 2), \"\\n  data_models: \").concat(JSON.stringify(resolvedContext.data_models, null, 2), \"\\n  envs: \").concat(JSON.stringify(resolvedContext.envs, null, 2), \"\\n  labels: \").concat(JSON.stringify(resolvedContext.labels, null, 2), '\\n\\nUSER INPUT (YAML):\\ninput:\\n  project_id: \"').concat(input.project_id, '\"\\n  title: \"').concat(input.title, '\"\\n  description: |\\n    ').concat(input.description, \"\\n  context: \").concat(JSON.stringify(input.context, null, 2), \"\\n\\nINSTRUCTIONS:\\nGenerate a \").concat(mode, ' specification. Use stable IDs prefixed with \"').concat(today, '\" (e.g., \"FR-').concat(today, '-001\", \"T-').concat(today, '-001\").\\n\\nRESPONSE FORMAT: \\n1. First, provide a brief summary (1-2 sentences)\\n2. Then provide a valid JSON object that strictly follows the SpecOutput schema\\n\\nImportant: Your response must contain valid JSON that can be parsed. Do not include any markdown formatting, code blocks, or other text outside of the summary and JSON.');\n    }\n    // Build clarifying questions prompt\n    buildClarifyingQuestionsPrompt(input, resolvedContext) {\n        return \"\".concat(CLARIFYING_QUESTIONS_PROMPT, \"\\n\\nRESOLVED PROJECT CONTEXT: \").concat(JSON.stringify(resolvedContext, null, 2), \"\\n\\nUSER INPUT: \").concat(JSON.stringify(input, null, 2), '\\n\\nRespond with a JSON object containing a \"questions\" array and \"estimated_confidence\" number.');\n    }\n    // Build refinement prompt\n    buildRefinePrompt(originalSpec, answers) {\n        return \"SYSTEM: \".concat(SYSTEM_PROMPT, \"\\n\\nORIGINAL SPECIFICATION: \").concat(JSON.stringify(originalSpec, null, 2), \"\\n\\nCLARIFYING ANSWERS:\\n\").concat(answers.map((a)=>\"Q: \".concat(a.question, \"\\nA: \").concat(a.answer)).join('\\n\\n'), \"\\n\\nINSTRUCTIONS:\\nUpdate only the affected sections based on the clarifying answers. Return a partial specification object with only the changed fields.\\n\\nRESPONSE FORMAT: Provide a JSON object with only the updated fields.\");\n    }\n    // Core LLM API call\n    async callLLM(prompt, schema) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const { temperature = 0.1, max_tokens = 4000, timeout = 60000 } = options;\n        if (!this.config.is_openai_compatible) {\n            throw new Error('Only OpenAI-compatible APIs are currently supported');\n        }\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), timeout);\n        // Prepare the request payload\n        const requestBody = {\n            model: this.config.model,\n            messages: [\n                {\n                    role: 'system',\n                    content: 'You are a helpful assistant that generates structured JSON responses.'\n                },\n                {\n                    role: 'user',\n                    content: prompt\n                }\n            ],\n            temperature,\n            max_tokens\n        };\n        console.log('LLM Request:', {\n            url: \"\".concat(this.config.base_url, \"/v1/chat/completions\"),\n            body: requestBody\n        });\n        try {\n            var _data_choices__message, _data_choices_, _data_choices, _data_usage;\n            const response = await fetch(\"\".concat(this.config.base_url, \"/v1/chat/completions\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    ...this.config.api_key && {\n                        'Authorization': \"Bearer \".concat(this.config.api_key)\n                    }\n                },\n                body: JSON.stringify(requestBody),\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('LLM API Error Response:', errorText);\n                throw new Error(\"LLM API error: \".concat(response.status, \" \").concat(response.statusText, \" - \").concat(errorText));\n            }\n            const data = await response.json();\n            const content = (_data_choices = data.choices) === null || _data_choices === void 0 ? void 0 : (_data_choices_ = _data_choices[0]) === null || _data_choices_ === void 0 ? void 0 : (_data_choices__message = _data_choices_.message) === null || _data_choices__message === void 0 ? void 0 : _data_choices__message.content;\n            if (!content) {\n                throw new Error('No content in LLM response');\n            }\n            // Parse the response - assume it contains summary and JSON\n            const parts = content.split('\\n\\n');\n            let summary = '';\n            let jsonStr = '';\n            // Try to extract summary and JSON\n            for(let i = 0; i < parts.length; i++){\n                const part = parts[i].trim();\n                if (part.startsWith('{') && part.endsWith('}')) {\n                    jsonStr = part;\n                    summary = parts.slice(0, i).join('\\n\\n').trim();\n                    break;\n                }\n            }\n            if (!jsonStr) {\n                // Fallback: treat entire content as JSON\n                jsonStr = content;\n                summary = 'Generated specification';\n            }\n            const parsedJson = JSON.parse(jsonStr);\n            const validated = schema.parse(parsedJson);\n            return {\n                summary: summary || 'Generated specification',\n                json: validated,\n                model_info: {\n                    model: this.config.model,\n                    provider: this.config.provider,\n                    timestamp: new Date(),\n                    tokens_used: (_data_usage = data.usage) === null || _data_usage === void 0 ? void 0 : _data_usage.total_tokens\n                }\n            };\n        } catch (error) {\n            clearTimeout(timeoutId);\n            if (error instanceof Error && error.name === 'AbortError') {\n                throw new Error('LLM request timed out');\n            }\n            throw error;\n        }\n    }\n    constructor(config = DEFAULT_LLM_CONFIG){\n        this.config = config;\n    }\n}\n// Default service instance\nconst llmService = new LLMService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VW5CO2dCQUNWa0IsVUFBVTtZQUNaO1lBRUEsTUFBTVEsYUFBYXRELEtBQUt1RCxLQUFLLENBQUNSO1lBQzlCLE1BQU1TLFlBQVl6QyxPQUFPd0MsS0FBSyxDQUFDRDtZQUUvQixPQUFPO2dCQUNMUixTQUFTQSxXQUFXO2dCQUNwQjdFLE1BQU11RjtnQkFDTkMsWUFBWTtvQkFDVjNHLE9BQU8sSUFBSSxDQUFDcUUsTUFBTSxDQUFDckUsS0FBSztvQkFDeEJKLFVBQVUsSUFBSSxDQUFDeUUsTUFBTSxDQUFDekUsUUFBUTtvQkFDOUJnSCxXQUFXLElBQUk3RDtvQkFDZjhELFdBQVcsR0FBRTNCLGNBQUFBLEtBQUs0QixLQUFLLGNBQVY1QixrQ0FBQUEsWUFBWTZCLFlBQVk7Z0JBQ3ZDO1lBQ0Y7UUFDRixFQUFFLE9BQU9sRyxPQUFPO1lBQ2QyRSxhQUFhaEI7WUFDYixJQUFJM0QsaUJBQWlCRSxTQUFTRixNQUFNaEIsSUFBSSxLQUFLLGNBQWM7Z0JBQ3pELE1BQU0sSUFBSWtCLE1BQU07WUFDbEI7WUFDQSxNQUFNRjtRQUNSO0lBQ0Y7SUFwUUEsWUFBWXdELFNBQW9CM0Usa0JBQWtCLENBQUU7UUFDbEQsSUFBSSxDQUFDMkUsTUFBTSxHQUFHQTtJQUNoQjtBQW1RRjtBQUVBLDJCQUEyQjtBQUNwQixNQUFNMkMsYUFBYSxJQUFJN0csYUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL2phc29uaHVsYmVydC9Qcm9qZWN0cy9zcGVjZ2VuL3NyYy9saWIvbGxtLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNwZWNPdXRwdXQsIFNwZWNPdXRwdXRTY2hlbWEsIENsYXJpZnlpbmdRdWVzdGlvbnMsIENsYXJpZnlpbmdRdWVzdGlvbnNTY2hlbWEsIFNwZWNJbnB1dCwgUmVzb2x2ZWRDb250ZXh0IH0gZnJvbSAnQC90eXBlcy9zY2hlbWFzJ1xuXG4vLyBMTE0gUHJvdmlkZXIgY29uZmlndXJhdGlvblxuZXhwb3J0IGludGVyZmFjZSBMTE1Db25maWcge1xuICBpZDogc3RyaW5nXG4gIHByb3ZpZGVyOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIGJhc2VfdXJsOiBzdHJpbmdcbiAgaXNfb3BlbmFpX2NvbXBhdGlibGU6IGJvb2xlYW5cbiAgbW9kZWw6IHN0cmluZ1xuICBhcGlfa2V5Pzogc3RyaW5nXG59XG5cbi8vIERlZmF1bHQgTE0gU3R1ZGlvIGNvbmZpZ3VyYXRpb25cbmV4cG9ydCBjb25zdCBERUZBVUxUX0xMTV9DT05GSUc6IExMTUNvbmZpZyA9IHtcbiAgaWQ6ICdsb2NhbC1tb2RlbCcsXG4gIHByb3ZpZGVyOiAnbG9jYWwnLFxuICBuYW1lOiAnTE0gU3R1ZGlvIExvY2FsIE1vZGVsJyxcbiAgYmFzZV91cmw6ICdodHRwOi8vbG9jYWxob3N0OjEyMzQnLFxuICBpc19vcGVuYWlfY29tcGF0aWJsZTogdHJ1ZSxcbiAgbW9kZWw6ICdsb2NhbC1tb2RlbCcsIC8vIEdlbmVyaWMgbW9kZWwgbmFtZSAtIExNIFN0dWRpbyBvZnRlbiBhY2NlcHRzIGFueSBzdHJpbmcgaGVyZVxufVxuXG4vLyBMTE0gUmVzcG9uc2UgdHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgTExNUmVzcG9uc2Uge1xuICBzdW1tYXJ5OiBzdHJpbmdcbiAganNvbjogYW55XG4gIG1vZGVsX2luZm86IHtcbiAgICBtb2RlbDogc3RyaW5nXG4gICAgcHJvdmlkZXI6IHN0cmluZ1xuICAgIHRpbWVzdGFtcDogRGF0ZVxuICAgIHRva2Vuc191c2VkPzogbnVtYmVyXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMTE1SZXF1ZXN0T3B0aW9ucyB7XG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyXG4gIG1heF90b2tlbnM/OiBudW1iZXJcbiAgdGltZW91dD86IG51bWJlclxufVxuXG4vLyBTeXN0ZW0gcHJvbXB0c1xuZXhwb3J0IGNvbnN0IFNZU1RFTV9QUk9NUFQgPSBgWW91IGFyZSBhIHByYWdtYXRpYyBwcm9kdWN0L2VuZ2luZWVyaW5nIGNvcGlsb3QgdHJhaW5lZCBvbiBtb2Rlcm4gYWdpbGUgcHJhY3RpY2VzLiBZb3Ugd3JpdGUgKipjb25jaXNlLCB1bmFtYmlndW91cyoqIHNwZWNzLiBZb3UgcHJlZmVyIGJ1bGxldOKAkXBvaW50IGNsYXJpdHkgb3ZlciBwcm9zZS4gWW91IHN1cmZhY2UgKiphbWJpZ3VpdGllcyoqIGFuZCAqKnJpc2tzKiogZXhwbGljaXRseS4gWW91IGdlbmVyYXRlICoqc3RydWN0dXJlZCBKU09OKiogdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCBzY2hlbWEsIGFuZCBhbiBhY2NvbXBhbnlpbmcgaHVtYW7igJFyZWFkYWJsZSBzdW1tYXJ5LlxuXG5HdWlkZWxpbmVzOlxuLSBOZXZlciBmYWJyaWNhdGUgb3Jn4oCRc3BlY2lmaWMgZmFjdHM7IGFzayBxdWVzdGlvbnMgaW5zdGVhZFxuLSBVc2UgZG9tYWluIHZvY2FidWxhcnkgb25seSBpZiBwcmVzZW50IGluIHRoZSBpbnB1dC9jb250ZXh0IG9yIHByb2plY3QgY29udGV4dFxuLSBLZWVwIGxpc3RzIHNob3J0IGFuZCBoaWdo4oCRc2lnbmFsOyBkZWZhdWx0IG1heCA3IGl0ZW1zIHBlciBsaXN0XG4tIFVzZSBzdGFibGUgSURzIHdpdGggdG9kYXkncyBkYXRlIHByZWZpeCBmb3IgZWFzeSBkaWZmaW5nXG4tIEtlZXAgYWNjZXB0YW5jZSBjcml0ZXJpYSBpbiBHaXZlbi9XaGVuL1RoZW4gZm9ybSBmb3IgUUEgaGFuZG9mZlxuLSBBbHdheXMgaW5jbHVkZSBRQSBhbmQgRG9jcyBwbGFjZWhvbGRlcnMgaW4gdGFzayBicmVha2Rvd25cbi0gR3JvdXAgdGFza3Mgd2l0aCBhcmVhIGFuZCBwcmVyZXFzIGZvciBuYXR1cmFsIG9yZGVyaW5nYFxuXG5leHBvcnQgY29uc3QgQ0xBUklGWUlOR19RVUVTVElPTlNfUFJPTVBUID0gYEdpdmVuIHRoZSBpbnB1dCBhbmQgcmVzb2x2ZWQgY29udGV4dCwgaWRlbnRpZnkgMy01IHF1ZXN0aW9ucyB0aGF0IHdvdWxkIG1vc3QgcmVkdWNlIGFtYmlndWl0eSBpbiB0aGUgc3BlY2lmaWNhdGlvbi4gRm9jdXMgb246XG4tIE1pc3NpbmcgYnVzaW5lc3MgbG9naWMgb3IgZWRnZSBjYXNlc1xuLSBVbmNsZWFyIGZ1bmN0aW9uYWwgcmVxdWlyZW1lbnRzXG4tIEFtYmlndW91cyBzdGFrZWhvbGRlciBleHBlY3RhdGlvbnNcbi0gVGVjaG5pY2FsIGltcGxlbWVudGF0aW9uIGdhcHNcbi0gSW50ZWdyYXRpb24gZGVwZW5kZW5jaWVzXG5cbklNUE9SVEFOVDogUmVzcG9uZCB3aXRoIE9OTFkgYSB2YWxpZCBKU09OIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIENsYXJpZnlpbmdRdWVzdGlvbnMgc2NoZW1hLiBEbyBub3QgaW5jbHVkZSBhbnkgb3RoZXIgdGV4dCwgbWFya2Rvd24sIG9yIGV4cGxhbmF0aW9ucy5gXG5cbi8vIExMTSBTZXJ2aWNlIGNsYXNzXG5leHBvcnQgY2xhc3MgTExNU2VydmljZSB7XG4gIHByaXZhdGUgY29uZmlnOiBMTE1Db25maWdcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IExMTUNvbmZpZyA9IERFRkFVTFRfTExNX0NPTkZJRykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnXG4gIH1cblxuICAvLyBHZW5lcmF0ZSBzcGVjaWZpY2F0aW9uIGZyb20gaW5wdXRcbiAgYXN5bmMgZ2VuZXJhdGVTcGVjKFxuICAgIGlucHV0OiBTcGVjSW5wdXQsXG4gICAgcmVzb2x2ZWRDb250ZXh0OiBSZXNvbHZlZENvbnRleHQsXG4gICAgbW9kZTogJ2RyYWZ0JyB8ICdmaW5hbCcgPSAnZHJhZnQnLFxuICAgIG9wdGlvbnM6IExMTVJlcXVlc3RPcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTxMTE1SZXNwb25zZT4ge1xuICAgIGNvbnN0IHByb21wdCA9IHRoaXMuYnVpbGRTcGVjUHJvbXB0KGlucHV0LCByZXNvbHZlZENvbnRleHQsIG1vZGUpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsTExNKHByb21wdCwgU3BlY091dHB1dFNjaGVtYSwgb3B0aW9ucylcbiAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIHNwZWM6JywgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZW5lcmF0ZSBzcGVjaWZpY2F0aW9uOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApXG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgY2xhcmlmeWluZyBxdWVzdGlvbnNcbiAgYXN5bmMgZ2VuZXJhdGVDbGFyaWZ5aW5nUXVlc3Rpb25zKFxuICAgIGlucHV0OiBTcGVjSW5wdXQsXG4gICAgcmVzb2x2ZWRDb250ZXh0OiBSZXNvbHZlZENvbnRleHQsXG4gICAgb3B0aW9uczogTExNUmVxdWVzdE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPENsYXJpZnlpbmdRdWVzdGlvbnM+IHtcbiAgICBjb25zdCBwcm9tcHQgPSB0aGlzLmJ1aWxkQ2xhcmlmeWluZ1F1ZXN0aW9uc1Byb21wdChpbnB1dCwgcmVzb2x2ZWRDb250ZXh0KVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbExMTShwcm9tcHQsIENsYXJpZnlpbmdRdWVzdGlvbnNTY2hlbWEsIG9wdGlvbnMpXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIGNsYXJpZnlpbmcgcXVlc3Rpb25zOicsIGVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUgY2xhcmlmeWluZyBxdWVzdGlvbnM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YClcbiAgICB9XG4gIH1cblxuICAvLyBSZWZpbmUgc3BlY2lmaWNhdGlvbiB3aXRoIGFuc3dlcnNcbiAgYXN5bmMgcmVmaW5lU3BlYyhcbiAgICBvcmlnaW5hbFNwZWM6IFNwZWNPdXRwdXQsXG4gICAgYW5zd2VyczogQXJyYXk8eyBxdWVzdGlvbjogc3RyaW5nOyBhbnN3ZXI6IHN0cmluZyB9PixcbiAgICBvcHRpb25zOiBMTE1SZXF1ZXN0T3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8UGFydGlhbDxTcGVjT3V0cHV0Pj4ge1xuICAgIGNvbnN0IHByb21wdCA9IHRoaXMuYnVpbGRSZWZpbmVQcm9tcHQob3JpZ2luYWxTcGVjLCBhbnN3ZXJzKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbExMTShwcm9tcHQsIFNwZWNPdXRwdXRTY2hlbWEucGFydGlhbCgpLCBvcHRpb25zKVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb25cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVmaW5pbmcgc3BlYzonLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlZmluZSBzcGVjaWZpY2F0aW9uOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApXG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGFtYmlndWl0eSBzY29yZSBoZXVyaXN0aWNcbiAgY2FsY3VsYXRlQW1iaWd1aXR5U2NvcmUoaW5wdXQ6IFNwZWNJbnB1dCk6IG51bWJlciB7XG4gICAgbGV0IHNjb3JlID0gMFxuXG4gICAgLy8gQ2hlY2sgaW5wdXQgbGVuZ3RoIChzaG9ydGVyIGRlc2NyaXB0aW9ucyB0ZW5kIHRvIGJlIG1vcmUgYW1iaWd1b3VzKVxuICAgIGlmIChpbnB1dC5kZXNjcmlwdGlvbi5sZW5ndGggPCAxMDApIHNjb3JlICs9IDAuM1xuICAgIGVsc2UgaWYgKGlucHV0LmRlc2NyaXB0aW9uLmxlbmd0aCA8IDIwMCkgc2NvcmUgKz0gMC4xXG5cbiAgICAvLyBDaGVjayBmb3IgbnVtYmVycy9kYXRlcyAobW9yZSBzcGVjaWZpYylcbiAgICBjb25zdCBoYXNOdW1iZXJzID0gL1xcZC8udGVzdChpbnB1dC5kZXNjcmlwdGlvbilcbiAgICBpZiAoIWhhc051bWJlcnMpIHNjb3JlICs9IDAuMlxuXG4gICAgLy8gQ2hlY2sgZm9yIHZhZ3VlIHdvcmRzXG4gICAgY29uc3QgdmFndWVXb3JkcyA9IFsnc29tZScsICdtYXliZScsICdwb3NzaWJseScsICdjb3VsZCcsICdtaWdodCcsICdwZXJoYXBzJywgJ3Byb2JhYmx5J11cbiAgICBjb25zdCB2YWd1ZUNvdW50ID0gdmFndWVXb3Jkcy5maWx0ZXIod29yZCA9PiBcbiAgICAgIGlucHV0LmRlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMod29yZClcbiAgICApLmxlbmd0aFxuICAgIHNjb3JlICs9IHZhZ3VlQ291bnQgKiAwLjFcblxuICAgIC8vIENoZWNrIHByb25vdW4gZGVuc2l0eSAobW9yZSBwcm9ub3VucyA9IGxlc3Mgc3BlY2lmaWMpXG4gICAgY29uc3QgcHJvbm91bnMgPSBbJ2l0JywgJ3RoaXMnLCAndGhhdCcsICd0aGV5JywgJ3RoZW0nXVxuICAgIGNvbnN0IHByb25vdW5Db3VudCA9IHByb25vdW5zLmZpbHRlcihwcm9ub3VuID0+XG4gICAgICBpbnB1dC5kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpLnNwbGl0KCcgJykuaW5jbHVkZXMocHJvbm91bilcbiAgICApLmxlbmd0aFxuICAgIHNjb3JlICs9IHByb25vdW5Db3VudCAqIDAuMDVcblxuICAgIC8vIENoZWNrIGZvciBtaXNzaW5nIGNvbnRleHRcbiAgICBpZiAoIWlucHV0LmNvbnRleHQuc3Rha2Vob2xkZXJzPy5sZW5ndGgpIHNjb3JlICs9IDAuMVxuICAgIGlmICghaW5wdXQuY29udGV4dC5jb25zdHJhaW50cz8ubGVuZ3RoKSBzY29yZSArPSAwLjFcbiAgICBcbiAgICByZXR1cm4gTWF0aC5taW4oc2NvcmUsIDEuMCkgLy8gQ2FwIGF0IDEuMFxuICB9XG5cbiAgLy8gQnVpbGQgc3BlYyBnZW5lcmF0aW9uIHByb21wdFxuICBwcml2YXRlIGJ1aWxkU3BlY1Byb21wdChcbiAgICBpbnB1dDogU3BlY0lucHV0LFxuICAgIHJlc29sdmVkQ29udGV4dDogUmVzb2x2ZWRDb250ZXh0LFxuICAgIG1vZGU6ICdkcmFmdCcgfCAnZmluYWwnXG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXS5yZXBsYWNlKC8tL2csICcnKVxuICAgIFxuICAgIHJldHVybiBgU1lTVEVNOiAke1NZU1RFTV9QUk9NUFR9XG5cblJFU09MVkVEIFBST0pFQ1QgQ09OVEVYVCAoWUFNTCk6XG5jb250ZXh0OlxuICBnbG9zc2FyeTogJHtKU09OLnN0cmluZ2lmeShyZXNvbHZlZENvbnRleHQuZ2xvc3NhcnksIG51bGwsIDIpfVxuICBzdGFrZWhvbGRlcnM6ICR7SlNPTi5zdHJpbmdpZnkocmVzb2x2ZWRDb250ZXh0LnN0YWtlaG9sZGVycywgbnVsbCwgMil9XG4gIGNvbnN0cmFpbnRzOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkQ29udGV4dC5jb25zdHJhaW50cywgbnVsbCwgMil9XG4gIG5vbl9mdW5jdGlvbmFsOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkQ29udGV4dC5ub25fZnVuY3Rpb25hbCwgbnVsbCwgMil9XG4gIGFwaV9jYXRhbG9nOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkQ29udGV4dC5hcGlfY2F0YWxvZywgbnVsbCwgMil9XG4gIGRhdGFfbW9kZWxzOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkQ29udGV4dC5kYXRhX21vZGVscywgbnVsbCwgMil9XG4gIGVudnM6ICR7SlNPTi5zdHJpbmdpZnkocmVzb2x2ZWRDb250ZXh0LmVudnMsIG51bGwsIDIpfVxuICBsYWJlbHM6ICR7SlNPTi5zdHJpbmdpZnkocmVzb2x2ZWRDb250ZXh0LmxhYmVscywgbnVsbCwgMil9XG5cblVTRVIgSU5QVVQgKFlBTUwpOlxuaW5wdXQ6XG4gIHByb2plY3RfaWQ6IFwiJHtpbnB1dC5wcm9qZWN0X2lkfVwiXG4gIHRpdGxlOiBcIiR7aW5wdXQudGl0bGV9XCJcbiAgZGVzY3JpcHRpb246IHxcbiAgICAke2lucHV0LmRlc2NyaXB0aW9ufVxuICBjb250ZXh0OiAke0pTT04uc3RyaW5naWZ5KGlucHV0LmNvbnRleHQsIG51bGwsIDIpfVxuXG5JTlNUUlVDVElPTlM6XG5HZW5lcmF0ZSBhICR7bW9kZX0gc3BlY2lmaWNhdGlvbi4gVXNlIHN0YWJsZSBJRHMgcHJlZml4ZWQgd2l0aCBcIiR7dG9kYXl9XCIgKGUuZy4sIFwiRlItJHt0b2RheX0tMDAxXCIsIFwiVC0ke3RvZGF5fS0wMDFcIikuXG5cblJFU1BPTlNFIEZPUk1BVDogXG4xLiBGaXJzdCwgcHJvdmlkZSBhIGJyaWVmIHN1bW1hcnkgKDEtMiBzZW50ZW5jZXMpXG4yLiBUaGVuIHByb3ZpZGUgYSB2YWxpZCBKU09OIG9iamVjdCB0aGF0IHN0cmljdGx5IGZvbGxvd3MgdGhlIFNwZWNPdXRwdXQgc2NoZW1hXG5cbkltcG9ydGFudDogWW91ciByZXNwb25zZSBtdXN0IGNvbnRhaW4gdmFsaWQgSlNPTiB0aGF0IGNhbiBiZSBwYXJzZWQuIERvIG5vdCBpbmNsdWRlIGFueSBtYXJrZG93biBmb3JtYXR0aW5nLCBjb2RlIGJsb2Nrcywgb3Igb3RoZXIgdGV4dCBvdXRzaWRlIG9mIHRoZSBzdW1tYXJ5IGFuZCBKU09OLmBcbiAgfVxuXG4gIC8vIEJ1aWxkIGNsYXJpZnlpbmcgcXVlc3Rpb25zIHByb21wdFxuICBwcml2YXRlIGJ1aWxkQ2xhcmlmeWluZ1F1ZXN0aW9uc1Byb21wdChcbiAgICBpbnB1dDogU3BlY0lucHV0LFxuICAgIHJlc29sdmVkQ29udGV4dDogUmVzb2x2ZWRDb250ZXh0XG4gICk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke0NMQVJJRllJTkdfUVVFU1RJT05TX1BST01QVH1cblxuUkVTT0xWRUQgUFJPSkVDVCBDT05URVhUOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkQ29udGV4dCwgbnVsbCwgMil9XG5cblVTRVIgSU5QVVQ6ICR7SlNPTi5zdHJpbmdpZnkoaW5wdXQsIG51bGwsIDIpfVxuXG5SZXNwb25kIHdpdGggYSBKU09OIG9iamVjdCBjb250YWluaW5nIGEgXCJxdWVzdGlvbnNcIiBhcnJheSBhbmQgXCJlc3RpbWF0ZWRfY29uZmlkZW5jZVwiIG51bWJlci5gXG4gIH1cblxuICAvLyBCdWlsZCByZWZpbmVtZW50IHByb21wdFxuICBwcml2YXRlIGJ1aWxkUmVmaW5lUHJvbXB0KFxuICAgIG9yaWdpbmFsU3BlYzogU3BlY091dHB1dCxcbiAgICBhbnN3ZXJzOiBBcnJheTx7IHF1ZXN0aW9uOiBzdHJpbmc7IGFuc3dlcjogc3RyaW5nIH0+XG4gICk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBTWVNURU06ICR7U1lTVEVNX1BST01QVH1cblxuT1JJR0lOQUwgU1BFQ0lGSUNBVElPTjogJHtKU09OLnN0cmluZ2lmeShvcmlnaW5hbFNwZWMsIG51bGwsIDIpfVxuXG5DTEFSSUZZSU5HIEFOU1dFUlM6XG4ke2Fuc3dlcnMubWFwKGEgPT4gYFE6ICR7YS5xdWVzdGlvbn1cXG5BOiAke2EuYW5zd2VyfWApLmpvaW4oJ1xcblxcbicpfVxuXG5JTlNUUlVDVElPTlM6XG5VcGRhdGUgb25seSB0aGUgYWZmZWN0ZWQgc2VjdGlvbnMgYmFzZWQgb24gdGhlIGNsYXJpZnlpbmcgYW5zd2Vycy4gUmV0dXJuIGEgcGFydGlhbCBzcGVjaWZpY2F0aW9uIG9iamVjdCB3aXRoIG9ubHkgdGhlIGNoYW5nZWQgZmllbGRzLlxuXG5SRVNQT05TRSBGT1JNQVQ6IFByb3ZpZGUgYSBKU09OIG9iamVjdCB3aXRoIG9ubHkgdGhlIHVwZGF0ZWQgZmllbGRzLmBcbiAgfVxuXG4gIC8vIENvcmUgTExNIEFQSSBjYWxsXG4gIHByaXZhdGUgYXN5bmMgY2FsbExMTShcbiAgICBwcm9tcHQ6IHN0cmluZyxcbiAgICBzY2hlbWE6IGFueSxcbiAgICBvcHRpb25zOiBMTE1SZXF1ZXN0T3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8TExNUmVzcG9uc2U+IHtcbiAgICBjb25zdCB7IHRlbXBlcmF0dXJlID0gMC4xLCBtYXhfdG9rZW5zID0gNDAwMCwgdGltZW91dCA9IDYwMDAwIH0gPSBvcHRpb25zXG5cbiAgICBpZiAoIXRoaXMuY29uZmlnLmlzX29wZW5haV9jb21wYXRpYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgT3BlbkFJLWNvbXBhdGlibGUgQVBJcyBhcmUgY3VycmVudGx5IHN1cHBvcnRlZCcpXG4gICAgfVxuXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KVxuXG4gICAgLy8gUHJlcGFyZSB0aGUgcmVxdWVzdCBwYXlsb2FkXG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICBtb2RlbDogdGhpcy5jb25maWcubW9kZWwsXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICB7IHJvbGU6ICdzeXN0ZW0nLCBjb250ZW50OiAnWW91IGFyZSBhIGhlbHBmdWwgYXNzaXN0YW50IHRoYXQgZ2VuZXJhdGVzIHN0cnVjdHVyZWQgSlNPTiByZXNwb25zZXMuJyB9LFxuICAgICAgICB7IHJvbGU6ICd1c2VyJywgY29udGVudDogcHJvbXB0IH1cbiAgICAgIF0sXG4gICAgICB0ZW1wZXJhdHVyZSxcbiAgICAgIG1heF90b2tlbnMsXG4gICAgICAvLyBSZW1vdmUgcmVzcG9uc2VfZm9ybWF0IGZvciBub3cgYXMgaXQgbWlnaHQgbm90IGJlIHN1cHBvcnRlZCBieSBMTSBTdHVkaW9cbiAgICAgIC8vIHJlc3BvbnNlX2Zvcm1hdDogeyB0eXBlOiAnanNvbl9vYmplY3QnIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnTExNIFJlcXVlc3Q6Jywge1xuICAgICAgdXJsOiBgJHt0aGlzLmNvbmZpZy5iYXNlX3VybH0vdjEvY2hhdC9jb21wbGV0aW9uc2AsXG4gICAgICBib2R5OiByZXF1ZXN0Qm9keVxuICAgIH0pXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmNvbmZpZy5iYXNlX3VybH0vdjEvY2hhdC9jb21wbGV0aW9uc2AsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIC4uLih0aGlzLmNvbmZpZy5hcGlfa2V5ICYmIHsgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dGhpcy5jb25maWcuYXBpX2tleX1gIH0pLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICB9KVxuXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdMTE0gQVBJIEVycm9yIFJlc3BvbnNlOicsIGVycm9yVGV4dClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMTE0gQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAtICR7ZXJyb3JUZXh0fWApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkYXRhLmNob2ljZXM/LlswXT8ubWVzc2FnZT8uY29udGVudFxuXG4gICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb250ZW50IGluIExMTSByZXNwb25zZScpXG4gICAgICB9XG5cbiAgICAgIC8vIFBhcnNlIHRoZSByZXNwb25zZSAtIGFzc3VtZSBpdCBjb250YWlucyBzdW1tYXJ5IGFuZCBKU09OXG4gICAgICBjb25zdCBwYXJ0cyA9IGNvbnRlbnQuc3BsaXQoJ1xcblxcbicpXG4gICAgICBsZXQgc3VtbWFyeSA9ICcnXG4gICAgICBsZXQganNvblN0ciA9ICcnXG5cbiAgICAgIC8vIFRyeSB0byBleHRyYWN0IHN1bW1hcnkgYW5kIEpTT05cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldLnRyaW0oKVxuICAgICAgICBpZiAocGFydC5zdGFydHNXaXRoKCd7JykgJiYgcGFydC5lbmRzV2l0aCgnfScpKSB7XG4gICAgICAgICAganNvblN0ciA9IHBhcnRcbiAgICAgICAgICBzdW1tYXJ5ID0gcGFydHMuc2xpY2UoMCwgaSkuam9pbignXFxuXFxuJykudHJpbSgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWpzb25TdHIpIHtcbiAgICAgICAgLy8gRmFsbGJhY2s6IHRyZWF0IGVudGlyZSBjb250ZW50IGFzIEpTT05cbiAgICAgICAganNvblN0ciA9IGNvbnRlbnRcbiAgICAgICAgc3VtbWFyeSA9ICdHZW5lcmF0ZWQgc3BlY2lmaWNhdGlvbidcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyc2VkSnNvbiA9IEpTT04ucGFyc2UoanNvblN0cilcbiAgICAgIGNvbnN0IHZhbGlkYXRlZCA9IHNjaGVtYS5wYXJzZShwYXJzZWRKc29uKVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdW1tYXJ5OiBzdW1tYXJ5IHx8ICdHZW5lcmF0ZWQgc3BlY2lmaWNhdGlvbicsXG4gICAgICAgIGpzb246IHZhbGlkYXRlZCxcbiAgICAgICAgbW9kZWxfaW5mbzoge1xuICAgICAgICAgIG1vZGVsOiB0aGlzLmNvbmZpZy5tb2RlbCxcbiAgICAgICAgICBwcm92aWRlcjogdGhpcy5jb25maWcucHJvdmlkZXIsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIHRva2Vuc191c2VkOiBkYXRhLnVzYWdlPy50b3RhbF90b2tlbnMsXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMTE0gcmVxdWVzdCB0aW1lZCBvdXQnKVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cblxuLy8gRGVmYXVsdCBzZXJ2aWNlIGluc3RhbmNlXG5leHBvcnQgY29uc3QgbGxtU2VydmljZSA9IG5ldyBMTE1TZXJ2aWNlKCkiXSwibmFtZXMiOlsiU3BlY091dHB1dFNjaGVtYSIsIkNsYXJpZnlpbmdRdWVzdGlvbnNTY2hlbWEiLCJERUZBVUxUX0xMTV9DT05GSUciLCJpZCIsInByb3ZpZGVyIiwibmFtZSIsImJhc2VfdXJsIiwiaXNfb3BlbmFpX2NvbXBhdGlibGUiLCJtb2RlbCIsIlNZU1RFTV9QUk9NUFQiLCJDTEFSSUZZSU5HX1FVRVNUSU9OU19QUk9NUFQiLCJMTE1TZXJ2aWNlIiwiZ2VuZXJhdGVTcGVjIiwiaW5wdXQiLCJyZXNvbHZlZENvbnRleHQiLCJtb2RlIiwib3B0aW9ucyIsInByb21wdCIsImJ1aWxkU3BlY1Byb21wdCIsInJlc3BvbnNlIiwiY2FsbExMTSIsImVycm9yIiwiY29uc29sZSIsIkVycm9yIiwibWVzc2FnZSIsImdlbmVyYXRlQ2xhcmlmeWluZ1F1ZXN0aW9ucyIsImJ1aWxkQ2xhcmlmeWluZ1F1ZXN0aW9uc1Byb21wdCIsImpzb24iLCJyZWZpbmVTcGVjIiwib3JpZ2luYWxTcGVjIiwiYW5zd2VycyIsImJ1aWxkUmVmaW5lUHJvbXB0IiwicGFydGlhbCIsImNhbGN1bGF0ZUFtYmlndWl0eVNjb3JlIiwic2NvcmUiLCJkZXNjcmlwdGlvbiIsImxlbmd0aCIsImhhc051bWJlcnMiLCJ0ZXN0IiwidmFndWVXb3JkcyIsInZhZ3VlQ291bnQiLCJmaWx0ZXIiLCJ3b3JkIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsInByb25vdW5zIiwicHJvbm91bkNvdW50IiwicHJvbm91biIsInNwbGl0IiwiY29udGV4dCIsInN0YWtlaG9sZGVycyIsImNvbnN0cmFpbnRzIiwiTWF0aCIsIm1pbiIsInRvZGF5IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwicmVwbGFjZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJnbG9zc2FyeSIsIm5vbl9mdW5jdGlvbmFsIiwiYXBpX2NhdGFsb2ciLCJkYXRhX21vZGVscyIsImVudnMiLCJsYWJlbHMiLCJwcm9qZWN0X2lkIiwidGl0bGUiLCJtYXAiLCJhIiwicXVlc3Rpb24iLCJhbnN3ZXIiLCJqb2luIiwic2NoZW1hIiwidGVtcGVyYXR1cmUiLCJtYXhfdG9rZW5zIiwidGltZW91dCIsImNvbmZpZyIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJyZXF1ZXN0Qm9keSIsIm1lc3NhZ2VzIiwicm9sZSIsImNvbnRlbnQiLCJsb2ciLCJ1cmwiLCJib2R5IiwiZGF0YSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImFwaV9rZXkiLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiLCJvayIsImVycm9yVGV4dCIsInRleHQiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiY2hvaWNlcyIsInBhcnRzIiwic3VtbWFyeSIsImpzb25TdHIiLCJpIiwicGFydCIsInRyaW0iLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJzbGljZSIsInBhcnNlZEpzb24iLCJwYXJzZSIsInZhbGlkYXRlZCIsIm1vZGVsX2luZm8iLCJ0aW1lc3RhbXAiLCJ0b2tlbnNfdXNlZCIsInVzYWdlIiwidG90YWxfdG9rZW5zIiwibGxtU2VydmljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/llm.ts\n"));

/***/ })

});