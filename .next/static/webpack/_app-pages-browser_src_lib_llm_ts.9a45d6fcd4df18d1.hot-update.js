"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_lib_llm_ts",{

/***/ "(app-pages-browser)/./src/lib/llm.ts":
/*!************************!*\
  !*** ./src/lib/llm.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CLARIFYING_QUESTIONS_PROMPT: () => (/* binding */ CLARIFYING_QUESTIONS_PROMPT),\n/* harmony export */   DEFAULT_LLM_CONFIG: () => (/* binding */ DEFAULT_LLM_CONFIG),\n/* harmony export */   LLMService: () => (/* binding */ LLMService),\n/* harmony export */   SYSTEM_PROMPT: () => (/* binding */ SYSTEM_PROMPT),\n/* harmony export */   llmService: () => (/* binding */ llmService)\n/* harmony export */ });\n/* harmony import */ var _types_schemas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types/schemas */ \"(app-pages-browser)/./src/types/schemas.ts\");\n\n// Default LM Studio configuration\nconst DEFAULT_LLM_CONFIG = {\n    id: 'local-model',\n    provider: 'local',\n    name: 'LM Studio Local Model',\n    base_url: 'http://localhost:1234',\n    is_openai_compatible: true,\n    model: 'local-model'\n};\n// System prompts\nconst SYSTEM_PROMPT = \"You are a pragmatic product/engineering copilot trained on modern agile practices. You write **concise, unambiguous** specs. You prefer bullet‑point clarity over prose. You surface **ambiguities** and **risks** explicitly. You generate **structured JSON** that matches the provided schema, and an accompanying human‑readable summary.\\n\\nGuidelines:\\n- Never fabricate org‑specific facts; ask questions instead\\n- Use domain vocabulary only if present in the input/context or project context\\n- Keep lists short and high‑signal; default max 7 items per list\\n- Use stable IDs with today's date prefix for easy diffing\\n- Keep acceptance criteria in Given/When/Then form for QA handoff\\n- Always include QA and Docs placeholders in task breakdown\\n- Group tasks with area and prereqs for natural ordering\";\nconst CLARIFYING_QUESTIONS_PROMPT = \"Given the input and resolved context, identify 3-5 questions that would most reduce ambiguity in the specification. Focus on:\\n- Missing business logic or edge cases\\n- Unclear functional requirements\\n- Ambiguous stakeholder expectations\\n- Technical implementation gaps\\n- Integration dependencies\\n\\nIMPORTANT: Respond with ONLY a valid JSON object that matches the ClarifyingQuestions schema. Do not include any other text, markdown, or explanations.\";\n// LLM Service class\nclass LLMService {\n    // Generate specification from input\n    async generateSpec(input, resolvedContext) {\n        let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'draft', options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        const prompt = this.buildSpecPrompt(input, resolvedContext, mode);\n        try {\n            const response = await this.callLLM(prompt, _types_schemas__WEBPACK_IMPORTED_MODULE_0__.SpecOutputSchema, options);\n            return response;\n        } catch (error) {\n            console.error('Error generating spec:', error);\n            throw new Error(\"Failed to generate specification: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Generate clarifying questions\n    async generateClarifyingQuestions(input, resolvedContext) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const prompt = this.buildClarifyingQuestionsPrompt(input, resolvedContext);\n        try {\n            const response = await this.callLLM(prompt, _types_schemas__WEBPACK_IMPORTED_MODULE_0__.ClarifyingQuestionsSchema, options);\n            return response.json;\n        } catch (error) {\n            console.error('Error generating clarifying questions:', error);\n            throw new Error(\"Failed to generate clarifying questions: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Refine specification with answers\n    async refineSpec(originalSpec, answers) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const prompt = this.buildRefinePrompt(originalSpec, answers);\n        try {\n            const response = await this.callLLM(prompt, _types_schemas__WEBPACK_IMPORTED_MODULE_0__.SpecOutputSchema.partial(), options);\n            return response.json;\n        } catch (error) {\n            console.error('Error refining spec:', error);\n            throw new Error(\"Failed to refine specification: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Calculate ambiguity score heuristic\n    calculateAmbiguityScore(input) {\n        var _input_context_stakeholders, _input_context_constraints;\n        let score = 0;\n        // Check input length (shorter descriptions tend to be more ambiguous)\n        if (input.description.length < 100) score += 0.3;\n        else if (input.description.length < 200) score += 0.1;\n        // Check for numbers/dates (more specific)\n        const hasNumbers = /\\d/.test(input.description);\n        if (!hasNumbers) score += 0.2;\n        // Check for vague words\n        const vagueWords = [\n            'some',\n            'maybe',\n            'possibly',\n            'could',\n            'might',\n            'perhaps',\n            'probably'\n        ];\n        const vagueCount = vagueWords.filter((word)=>input.description.toLowerCase().includes(word)).length;\n        score += vagueCount * 0.1;\n        // Check pronoun density (more pronouns = less specific)\n        const pronouns = [\n            'it',\n            'this',\n            'that',\n            'they',\n            'them'\n        ];\n        const pronounCount = pronouns.filter((pronoun)=>input.description.toLowerCase().split(' ').includes(pronoun)).length;\n        score += pronounCount * 0.05;\n        // Check for missing context\n        if (!((_input_context_stakeholders = input.context.stakeholders) === null || _input_context_stakeholders === void 0 ? void 0 : _input_context_stakeholders.length)) score += 0.1;\n        if (!((_input_context_constraints = input.context.constraints) === null || _input_context_constraints === void 0 ? void 0 : _input_context_constraints.length)) score += 0.1;\n        return Math.min(score, 1.0) // Cap at 1.0\n        ;\n    }\n    // Build spec generation prompt\n    buildSpecPrompt(input, resolvedContext, mode) {\n        const today = new Date().toISOString().split('T')[0].replace(/-/g, '');\n        return \"SYSTEM: \".concat(SYSTEM_PROMPT, \"\\n\\nRESOLVED PROJECT CONTEXT (YAML):\\ncontext:\\n  glossary: \").concat(JSON.stringify(resolvedContext.glossary, null, 2), \"\\n  stakeholders: \").concat(JSON.stringify(resolvedContext.stakeholders, null, 2), \"\\n  constraints: \").concat(JSON.stringify(resolvedContext.constraints, null, 2), \"\\n  non_functional: \").concat(JSON.stringify(resolvedContext.non_functional, null, 2), \"\\n  api_catalog: \").concat(JSON.stringify(resolvedContext.api_catalog, null, 2), \"\\n  data_models: \").concat(JSON.stringify(resolvedContext.data_models, null, 2), \"\\n  envs: \").concat(JSON.stringify(resolvedContext.envs, null, 2), \"\\n  labels: \").concat(JSON.stringify(resolvedContext.labels, null, 2), '\\n\\nUSER INPUT (YAML):\\ninput:\\n  project_id: \"').concat(input.project_id, '\"\\n  title: \"').concat(input.title, '\"\\n  description: |\\n    ').concat(input.description, \"\\n  context: \").concat(JSON.stringify(input.context, null, 2), \"\\n\\nINSTRUCTIONS:\\nGenerate a \").concat(mode, ' specification. Use stable IDs prefixed with \"').concat(today, '\" (e.g., \"FR-').concat(today, '-001\", \"T-').concat(today, '-001\").\\n\\nRESPONSE FORMAT: \\n1. Provide a valid JSON object that strictly follows the SpecOutput schema\\n\\nImportant: Your response must contain valid JSON that can be parsed. Do not include any markdown formatting, code blocks, or other text outside of the summary and JSON.');\n    }\n    // Build clarifying questions prompt\n    buildClarifyingQuestionsPrompt(input, resolvedContext) {\n        return \"\".concat(CLARIFYING_QUESTIONS_PROMPT, \"\\n\\nRESOLVED PROJECT CONTEXT: \").concat(JSON.stringify(resolvedContext, null, 2), \"\\n\\nUSER INPUT: \").concat(JSON.stringify(input, null, 2), '\\n\\nRespond with a JSON object containing a \"questions\" array and \"estimated_confidence\" number.');\n    }\n    // Build refinement prompt\n    buildRefinePrompt(originalSpec, answers) {\n        return \"SYSTEM: \".concat(SYSTEM_PROMPT, \"\\n\\nORIGINAL SPECIFICATION: \").concat(JSON.stringify(originalSpec, null, 2), \"\\n\\nCLARIFYING ANSWERS:\\n\").concat(answers.map((a)=>\"Q: \".concat(a.question, \"\\nA: \").concat(a.answer)).join('\\n\\n'), \"\\n\\nINSTRUCTIONS:\\nUpdate only the affected sections based on the clarifying answers. Return a partial specification object with only the changed fields.\\n\\nRESPONSE FORMAT:\\n- Provide a JSON object with only the updated fields.\\n- Output must only contain valid JSON.\");\n    }\n    // Core LLM API call\n    async callLLM(prompt, schema) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const { temperature = 0.1, max_tokens = 4000, timeout = 60000 } = options;\n        if (!this.config.is_openai_compatible) {\n            throw new Error('Only OpenAI-compatible APIs are currently supported');\n        }\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), timeout);\n        // Prepare the request payload\n        const requestBody = {\n            model: this.config.model,\n            messages: [\n                {\n                    role: 'system',\n                    content: 'You are a helpful assistant that generates structured JSON responses.'\n                },\n                {\n                    role: 'user',\n                    content: prompt\n                }\n            ],\n            temperature,\n            max_tokens\n        };\n        console.log('LLM Request:', {\n            url: \"\".concat(this.config.base_url, \"/v1/chat/completions\"),\n            body: requestBody\n        });\n        try {\n            var _data_choices__message, _data_choices_, _data_choices, _data_usage;\n            const response = await fetch(\"\".concat(this.config.base_url, \"/v1/chat/completions\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    ...this.config.api_key && {\n                        'Authorization': \"Bearer \".concat(this.config.api_key)\n                    }\n                },\n                body: JSON.stringify(requestBody),\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('LLM API Error Response:', errorText);\n                throw new Error(\"LLM API error: \".concat(response.status, \" \").concat(response.statusText, \" - \").concat(errorText));\n            }\n            const data = await response.json();\n            const content = (_data_choices = data.choices) === null || _data_choices === void 0 ? void 0 : (_data_choices_ = _data_choices[0]) === null || _data_choices_ === void 0 ? void 0 : (_data_choices__message = _data_choices_.message) === null || _data_choices__message === void 0 ? void 0 : _data_choices__message.content;\n            if (!content) {\n                throw new Error('No content in LLM response');\n            }\n            // Parse the response - assume it contains summary and JSON\n            const parts = content.split('\\n\\n');\n            let summary = '';\n            let jsonStr = '';\n            // Try to extract summary and JSON\n            for(let i = 0; i < parts.length; i++){\n                const part = parts[i].trim();\n                if (part.startsWith('{') && part.endsWith('}')) {\n                    jsonStr = part;\n                    summary = parts.slice(0, i).join('\\n\\n').trim();\n                    break;\n                }\n            }\n            if (!jsonStr) {\n                // Fallback: treat entire content as JSON\n                jsonStr = content;\n                summary = 'Generated specification';\n            }\n            const parsedJson = JSON.parse(jsonStr);\n            const validated = schema.parse(parsedJson);\n            return {\n                summary: summary || 'Generated specification',\n                json: validated,\n                model_info: {\n                    model: this.config.model,\n                    provider: this.config.provider,\n                    timestamp: new Date(),\n                    tokens_used: (_data_usage = data.usage) === null || _data_usage === void 0 ? void 0 : _data_usage.total_tokens\n                }\n            };\n        } catch (error) {\n            clearTimeout(timeoutId);\n            if (error instanceof Error && error.name === 'AbortError') {\n                throw new Error('LLM request timed out');\n            }\n            throw error;\n        }\n    }\n    constructor(config = DEFAULT_LLM_CONFIG){\n        this.config = config;\n    }\n}\n// Default service instance\nconst llmService = new LLMService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbGxtLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEwSTtBQWExSSxrQ0FBa0M7QUFDM0IsTUFBTUUscUJBQWdDO0lBQzNDQyxJQUFJO0lBQ0pDLFVBQVU7SUFDVkMsTUFBTTtJQUNOQyxVQUFVO0lBQ1ZDLHNCQUFzQjtJQUN0QkMsT0FBTztBQUNULEVBQUM7QUFvQkQsaUJBQWlCO0FBQ1YsTUFBTUMsZ0JBQWlCLHF5QkFTMkI7QUFFbEQsTUFBTUMsOEJBQStCLHljQU80RztBQUV4SixvQkFBb0I7QUFDYixNQUFNQztJQU9YLG9DQUFvQztJQUNwQyxNQUFNQyxhQUNKQyxLQUFnQixFQUNoQkMsZUFBZ0MsRUFHVjtZQUZ0QkMsT0FBQUEsaUVBQTBCLFNBQzFCQyxVQUFBQSxpRUFBNkIsQ0FBQztRQUU5QixNQUFNQyxTQUFTLElBQUksQ0FBQ0MsZUFBZSxDQUFDTCxPQUFPQyxpQkFBaUJDO1FBRTVELElBQUk7WUFDRixNQUFNSSxXQUFXLE1BQU0sSUFBSSxDQUFDQyxPQUFPLENBQUNILFFBQVFqQiw0REFBZ0JBLEVBQUVnQjtZQUM5RCxPQUFPRztRQUNULEVBQUUsT0FBT0UsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsMEJBQTBCQTtZQUN4QyxNQUFNLElBQUlFLE1BQU0scUNBQThGLE9BQXpERixpQkFBaUJFLFFBQVFGLE1BQU1HLE9BQU8sR0FBRztRQUNoRztJQUNGO0lBRUEsZ0NBQWdDO0lBQ2hDLE1BQU1DLDRCQUNKWixLQUFnQixFQUNoQkMsZUFBZ0MsRUFFRjtZQUQ5QkUsVUFBQUEsaUVBQTZCLENBQUM7UUFFOUIsTUFBTUMsU0FBUyxJQUFJLENBQUNTLDhCQUE4QixDQUFDYixPQUFPQztRQUUxRCxJQUFJO1lBQ0YsTUFBTUssV0FBVyxNQUFNLElBQUksQ0FBQ0MsT0FBTyxDQUFDSCxRQUFRaEIscUVBQXlCQSxFQUFFZTtZQUN2RSxPQUFPRyxTQUFTUSxJQUFJO1FBQ3RCLEVBQUUsT0FBT04sT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsMENBQTBDQTtZQUN4RCxNQUFNLElBQUlFLE1BQU0sNENBQXFHLE9BQXpERixpQkFBaUJFLFFBQVFGLE1BQU1HLE9BQU8sR0FBRztRQUN2RztJQUNGO0lBRUEsb0NBQW9DO0lBQ3BDLE1BQU1JLFdBQ0pDLFlBQXdCLEVBQ3hCQyxPQUFvRCxFQUV0QjtZQUQ5QmQsVUFBQUEsaUVBQTZCLENBQUM7UUFFOUIsTUFBTUMsU0FBUyxJQUFJLENBQUNjLGlCQUFpQixDQUFDRixjQUFjQztRQUVwRCxJQUFJO1lBQ0YsTUFBTVgsV0FBVyxNQUFNLElBQUksQ0FBQ0MsT0FBTyxDQUFDSCxRQUFRakIsNERBQWdCQSxDQUFDZ0MsT0FBTyxJQUFJaEI7WUFDeEUsT0FBT0csU0FBU1EsSUFBSTtRQUN0QixFQUFFLE9BQU9OLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHdCQUF3QkE7WUFDdEMsTUFBTSxJQUFJRSxNQUFNLG1DQUE0RixPQUF6REYsaUJBQWlCRSxRQUFRRixNQUFNRyxPQUFPLEdBQUc7UUFDOUY7SUFDRjtJQUVBLHNDQUFzQztJQUN0Q1Msd0JBQXdCcEIsS0FBZ0IsRUFBVTtZQTBCM0NBLDZCQUNBQTtRQTFCTCxJQUFJcUIsUUFBUTtRQUVaLHNFQUFzRTtRQUN0RSxJQUFJckIsTUFBTXNCLFdBQVcsQ0FBQ0MsTUFBTSxHQUFHLEtBQUtGLFNBQVM7YUFDeEMsSUFBSXJCLE1BQU1zQixXQUFXLENBQUNDLE1BQU0sR0FBRyxLQUFLRixTQUFTO1FBRWxELDBDQUEwQztRQUMxQyxNQUFNRyxhQUFhLEtBQUtDLElBQUksQ0FBQ3pCLE1BQU1zQixXQUFXO1FBQzlDLElBQUksQ0FBQ0UsWUFBWUgsU0FBUztRQUUxQix3QkFBd0I7UUFDeEIsTUFBTUssYUFBYTtZQUFDO1lBQVE7WUFBUztZQUFZO1lBQVM7WUFBUztZQUFXO1NBQVc7UUFDekYsTUFBTUMsYUFBYUQsV0FBV0UsTUFBTSxDQUFDQyxDQUFBQSxPQUNuQzdCLE1BQU1zQixXQUFXLENBQUNRLFdBQVcsR0FBR0MsUUFBUSxDQUFDRixPQUN6Q04sTUFBTTtRQUNSRixTQUFTTSxhQUFhO1FBRXRCLHdEQUF3RDtRQUN4RCxNQUFNSyxXQUFXO1lBQUM7WUFBTTtZQUFRO1lBQVE7WUFBUTtTQUFPO1FBQ3ZELE1BQU1DLGVBQWVELFNBQVNKLE1BQU0sQ0FBQ00sQ0FBQUEsVUFDbkNsQyxNQUFNc0IsV0FBVyxDQUFDUSxXQUFXLEdBQUdLLEtBQUssQ0FBQyxLQUFLSixRQUFRLENBQUNHLFVBQ3BEWCxNQUFNO1FBQ1JGLFNBQVNZLGVBQWU7UUFFeEIsNEJBQTRCO1FBQzVCLElBQUksR0FBQ2pDLDhCQUFBQSxNQUFNb0MsT0FBTyxDQUFDQyxZQUFZLGNBQTFCckMsa0RBQUFBLDRCQUE0QnVCLE1BQU0sR0FBRUYsU0FBUztRQUNsRCxJQUFJLEdBQUNyQiw2QkFBQUEsTUFBTW9DLE9BQU8sQ0FBQ0UsV0FBVyxjQUF6QnRDLGlEQUFBQSwyQkFBMkJ1QixNQUFNLEdBQUVGLFNBQVM7UUFFakQsT0FBT2tCLEtBQUtDLEdBQUcsQ0FBQ25CLE9BQU8sS0FBSyxhQUFhOztJQUMzQztJQUVBLCtCQUErQjtJQUN2QmhCLGdCQUNOTCxLQUFnQixFQUNoQkMsZUFBZ0MsRUFDaENDLElBQXVCLEVBQ2Y7UUFDUixNQUFNdUMsUUFBUSxJQUFJQyxPQUFPQyxXQUFXLEdBQUdSLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDUyxPQUFPLENBQUMsTUFBTTtRQUVuRSxPQUFPLFdBSUdDLE9BSlFqRCxlQUFjLGdFQUtsQmlELE9BREpBLEtBQUtDLFNBQVMsQ0FBQzdDLGdCQUFnQjhDLFFBQVEsRUFBRSxNQUFNLElBQUcsc0JBRS9DRixPQURDQSxLQUFLQyxTQUFTLENBQUM3QyxnQkFBZ0JvQyxZQUFZLEVBQUUsTUFBTSxJQUFHLHFCQUVwRFEsT0FESEEsS0FBS0MsU0FBUyxDQUFDN0MsZ0JBQWdCcUMsV0FBVyxFQUFFLE1BQU0sSUFBRyx3QkFFckRPLE9BREdBLEtBQUtDLFNBQVMsQ0FBQzdDLGdCQUFnQitDLGNBQWMsRUFBRSxNQUFNLElBQUcscUJBRTNESCxPQURBQSxLQUFLQyxTQUFTLENBQUM3QyxnQkFBZ0JnRCxXQUFXLEVBQUUsTUFBTSxJQUFHLHFCQUU1REosT0FET0EsS0FBS0MsU0FBUyxDQUFDN0MsZ0JBQWdCaUQsV0FBVyxFQUFFLE1BQU0sSUFBRyxjQUUxREwsT0FERkEsS0FBS0MsU0FBUyxDQUFDN0MsZ0JBQWdCa0QsSUFBSSxFQUFFLE1BQU0sSUFBRyxnQkFLdkNuRCxPQUpMNkMsS0FBS0MsU0FBUyxDQUFDN0MsZ0JBQWdCbUQsTUFBTSxFQUFFLE1BQU0sSUFBRyxtREFLaERwRCxPQURLQSxNQUFNcUQsVUFBVSxFQUFDLGlCQUc1QnJELE9BRk1BLE1BQU1zRCxLQUFLLEVBQUMsNkJBR1hULE9BRFA3QyxNQUFNc0IsV0FBVyxFQUFDLGlCQUlYcEIsT0FIQTJDLEtBQUtDLFNBQVMsQ0FBQzlDLE1BQU1vQyxPQUFPLEVBQUUsTUFBTSxJQUFHLGtDQUdjSyxPQUFyRHZDLE1BQUssa0RBQXFFdUMsT0FBckJBLE9BQU0saUJBQWlDQSxPQUFsQkEsT0FBTSxjQUFrQixPQUFOQSxPQUFNO0lBTTdHO0lBRUEsb0NBQW9DO0lBQzVCNUIsK0JBQ05iLEtBQWdCLEVBQ2hCQyxlQUFnQyxFQUN4QjtRQUNSLE9BQU8sR0FFaUI0QyxPQUZkaEQsNkJBQTRCLGtDQUk1QmdELE9BRmNBLEtBQUtDLFNBQVMsQ0FBQzdDLGlCQUFpQixNQUFNLElBQUcsb0JBRXhCLE9BQS9CNEMsS0FBS0MsU0FBUyxDQUFDOUMsT0FBTyxNQUFNLElBQUc7SUFHM0M7SUFFQSwwQkFBMEI7SUFDbEJrQixrQkFDTkYsWUFBd0IsRUFDeEJDLE9BQW9ELEVBQzVDO1FBQ1IsT0FBTyxXQUVlNEIsT0FGSmpELGVBQWMsZ0NBS2xDcUIsT0FId0I0QixLQUFLQyxTQUFTLENBQUM5QixjQUFjLE1BQU0sSUFBRyw2QkFHSSxPQUFsRUMsUUFBUXNDLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBSyxNQUF3QkEsT0FBbEJBLEVBQUVDLFFBQVEsRUFBQyxTQUFnQixPQUFURCxFQUFFRSxNQUFNLEdBQUlDLElBQUksQ0FBQyxTQUFRO0lBUWxFO0lBRUEsb0JBQW9CO0lBQ3BCLE1BQWNwRCxRQUNaSCxNQUFjLEVBQ2R3RCxNQUFXLEVBRVc7WUFEdEJ6RCxVQUFBQSxpRUFBNkIsQ0FBQztRQUU5QixNQUFNLEVBQUUwRCxjQUFjLEdBQUcsRUFBRUMsYUFBYSxJQUFJLEVBQUVDLFVBQVUsS0FBSyxFQUFFLEdBQUc1RDtRQUVsRSxJQUFJLENBQUMsSUFBSSxDQUFDNkQsTUFBTSxDQUFDdEUsb0JBQW9CLEVBQUU7WUFDckMsTUFBTSxJQUFJZ0IsTUFBTTtRQUNsQjtRQUVBLE1BQU11RCxhQUFhLElBQUlDO1FBQ3ZCLE1BQU1DLFlBQVlDLFdBQVcsSUFBTUgsV0FBV0ksS0FBSyxJQUFJTjtRQUV2RCw4QkFBOEI7UUFDOUIsTUFBTU8sY0FBYztZQUNsQjNFLE9BQU8sSUFBSSxDQUFDcUUsTUFBTSxDQUFDckUsS0FBSztZQUN4QjRFLFVBQVU7Z0JBQ1I7b0JBQUVDLE1BQU07b0JBQVVDLFNBQVM7Z0JBQXdFO2dCQUNuRztvQkFBRUQsTUFBTTtvQkFBUUMsU0FBU3JFO2dCQUFPO2FBQ2pDO1lBQ0R5RDtZQUNBQztRQUdGO1FBRUFyRCxRQUFRaUUsR0FBRyxDQUFDLGdCQUFnQjtZQUMxQkMsS0FBSyxHQUF3QixPQUFyQixJQUFJLENBQUNYLE1BQU0sQ0FBQ3ZFLFFBQVEsRUFBQztZQUM3Qm1GLE1BQU1OO1FBQ1I7UUFFQSxJQUFJO2dCQW9CY08sd0JBQUFBLGdCQUFBQSxlQXFDQ0E7WUF4RGpCLE1BQU12RSxXQUFXLE1BQU13RSxNQUFNLEdBQXdCLE9BQXJCLElBQUksQ0FBQ2QsTUFBTSxDQUFDdkUsUUFBUSxFQUFDLHlCQUF1QjtnQkFDMUVzRixRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsR0FBSSxJQUFJLENBQUNoQixNQUFNLENBQUNpQixPQUFPLElBQUk7d0JBQUUsaUJBQWlCLFVBQThCLE9BQXBCLElBQUksQ0FBQ2pCLE1BQU0sQ0FBQ2lCLE9BQU87b0JBQUcsQ0FBQztnQkFDakY7Z0JBQ0FMLE1BQU0vQixLQUFLQyxTQUFTLENBQUN3QjtnQkFDckJZLFFBQVFqQixXQUFXaUIsTUFBTTtZQUMzQjtZQUVBQyxhQUFhaEI7WUFFYixJQUFJLENBQUM3RCxTQUFTOEUsRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU0vRSxTQUFTZ0YsSUFBSTtnQkFDckM3RSxRQUFRRCxLQUFLLENBQUMsMkJBQTJCNkU7Z0JBQ3pDLE1BQU0sSUFBSTNFLE1BQU0sa0JBQXFDSixPQUFuQkEsU0FBU2lGLE1BQU0sRUFBQyxLQUE0QkYsT0FBekIvRSxTQUFTa0YsVUFBVSxFQUFDLE9BQWUsT0FBVkg7WUFDaEY7WUFFQSxNQUFNUixPQUFPLE1BQU12RSxTQUFTUSxJQUFJO1lBQ2hDLE1BQU0yRCxXQUFVSSxnQkFBQUEsS0FBS1ksT0FBTyxjQUFaWixxQ0FBQUEsaUJBQUFBLGFBQWMsQ0FBQyxFQUFFLGNBQWpCQSxzQ0FBQUEseUJBQUFBLGVBQW1CbEUsT0FBTyxjQUExQmtFLDZDQUFBQSx1QkFBNEJKLE9BQU87WUFFbkQsSUFBSSxDQUFDQSxTQUFTO2dCQUNaLE1BQU0sSUFBSS9ELE1BQU07WUFDbEI7WUFFQSwyREFBMkQ7WUFDM0QsTUFBTWdGLFFBQVFqQixRQUFRdEMsS0FBSyxDQUFDO1lBQzVCLElBQUl3RCxVQUFVO1lBQ2QsSUFBSUMsVUFBVTtZQUVkLGtDQUFrQztZQUNsQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsTUFBTW5FLE1BQU0sRUFBRXNFLElBQUs7Z0JBQ3JDLE1BQU1DLE9BQU9KLEtBQUssQ0FBQ0csRUFBRSxDQUFDRSxJQUFJO2dCQUMxQixJQUFJRCxLQUFLRSxVQUFVLENBQUMsUUFBUUYsS0FBS0csUUFBUSxDQUFDLE1BQU07b0JBQzlDTCxVQUFVRTtvQkFDVkgsVUFBVUQsTUFBTVEsS0FBSyxDQUFDLEdBQUdMLEdBQUdsQyxJQUFJLENBQUMsUUFBUW9DLElBQUk7b0JBQzdDO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJLENBQUNILFNBQVM7Z0JBQ1oseUNBQXlDO2dCQUN6Q0EsVUFBVW5CO2dCQUNWa0IsVUFBVTtZQUNaO1lBRUEsTUFBTVEsYUFBYXRELEtBQUt1RCxLQUFLLENBQUNSO1lBQzlCLE1BQU1TLFlBQVl6QyxPQUFPd0MsS0FBSyxDQUFDRDtZQUUvQixPQUFPO2dCQUNMUixTQUFTQSxXQUFXO2dCQUNwQjdFLE1BQU11RjtnQkFDTkMsWUFBWTtvQkFDVjNHLE9BQU8sSUFBSSxDQUFDcUUsTUFBTSxDQUFDckUsS0FBSztvQkFDeEJKLFVBQVUsSUFBSSxDQUFDeUUsTUFBTSxDQUFDekUsUUFBUTtvQkFDOUJnSCxXQUFXLElBQUk3RDtvQkFDZjhELFdBQVcsR0FBRTNCLGNBQUFBLEtBQUs0QixLQUFLLGNBQVY1QixrQ0FBQUEsWUFBWTZCLFlBQVk7Z0JBQ3ZDO1lBQ0Y7UUFDRixFQUFFLE9BQU9sRyxPQUFPO1lBQ2QyRSxhQUFhaEI7WUFDYixJQUFJM0QsaUJBQWlCRSxTQUFTRixNQUFNaEIsSUFBSSxLQUFLLGNBQWM7Z0JBQ3pELE1BQU0sSUFBSWtCLE1BQU07WUFDbEI7WUFDQSxNQUFNRjtRQUNSO0lBQ0Y7SUFyUUEsWUFBWXdELFNBQW9CM0Usa0JBQWtCLENBQUU7UUFDbEQsSUFBSSxDQUFDMkUsTUFBTSxHQUFHQTtJQUNoQjtBQW9RRjtBQUVBLDJCQUEyQjtBQUNwQixNQUFNMkMsYUFBYSxJQUFJN0csYUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL2phc29uaHVsYmVydC9Qcm9qZWN0cy9zcGVjZ2VuL3NyYy9saWIvbGxtLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNwZWNPdXRwdXQsIFNwZWNPdXRwdXRTY2hlbWEsIENsYXJpZnlpbmdRdWVzdGlvbnMsIENsYXJpZnlpbmdRdWVzdGlvbnNTY2hlbWEsIFNwZWNJbnB1dCwgUmVzb2x2ZWRDb250ZXh0IH0gZnJvbSAnQC90eXBlcy9zY2hlbWFzJ1xuXG4vLyBMTE0gUHJvdmlkZXIgY29uZmlndXJhdGlvblxuZXhwb3J0IGludGVyZmFjZSBMTE1Db25maWcge1xuICBpZDogc3RyaW5nXG4gIHByb3ZpZGVyOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIGJhc2VfdXJsOiBzdHJpbmdcbiAgaXNfb3BlbmFpX2NvbXBhdGlibGU6IGJvb2xlYW5cbiAgbW9kZWw6IHN0cmluZ1xuICBhcGlfa2V5Pzogc3RyaW5nXG59XG5cbi8vIERlZmF1bHQgTE0gU3R1ZGlvIGNvbmZpZ3VyYXRpb25cbmV4cG9ydCBjb25zdCBERUZBVUxUX0xMTV9DT05GSUc6IExMTUNvbmZpZyA9IHtcbiAgaWQ6ICdsb2NhbC1tb2RlbCcsXG4gIHByb3ZpZGVyOiAnbG9jYWwnLFxuICBuYW1lOiAnTE0gU3R1ZGlvIExvY2FsIE1vZGVsJyxcbiAgYmFzZV91cmw6ICdodHRwOi8vbG9jYWxob3N0OjEyMzQnLFxuICBpc19vcGVuYWlfY29tcGF0aWJsZTogdHJ1ZSxcbiAgbW9kZWw6ICdsb2NhbC1tb2RlbCcsIC8vIEdlbmVyaWMgbW9kZWwgbmFtZSAtIExNIFN0dWRpbyBvZnRlbiBhY2NlcHRzIGFueSBzdHJpbmcgaGVyZVxufVxuXG4vLyBMTE0gUmVzcG9uc2UgdHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgTExNUmVzcG9uc2Uge1xuICBzdW1tYXJ5OiBzdHJpbmdcbiAganNvbjogYW55XG4gIG1vZGVsX2luZm86IHtcbiAgICBtb2RlbDogc3RyaW5nXG4gICAgcHJvdmlkZXI6IHN0cmluZ1xuICAgIHRpbWVzdGFtcDogRGF0ZVxuICAgIHRva2Vuc191c2VkPzogbnVtYmVyXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMTE1SZXF1ZXN0T3B0aW9ucyB7XG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyXG4gIG1heF90b2tlbnM/OiBudW1iZXJcbiAgdGltZW91dD86IG51bWJlclxufVxuXG4vLyBTeXN0ZW0gcHJvbXB0c1xuZXhwb3J0IGNvbnN0IFNZU1RFTV9QUk9NUFQgPSBgWW91IGFyZSBhIHByYWdtYXRpYyBwcm9kdWN0L2VuZ2luZWVyaW5nIGNvcGlsb3QgdHJhaW5lZCBvbiBtb2Rlcm4gYWdpbGUgcHJhY3RpY2VzLiBZb3Ugd3JpdGUgKipjb25jaXNlLCB1bmFtYmlndW91cyoqIHNwZWNzLiBZb3UgcHJlZmVyIGJ1bGxldOKAkXBvaW50IGNsYXJpdHkgb3ZlciBwcm9zZS4gWW91IHN1cmZhY2UgKiphbWJpZ3VpdGllcyoqIGFuZCAqKnJpc2tzKiogZXhwbGljaXRseS4gWW91IGdlbmVyYXRlICoqc3RydWN0dXJlZCBKU09OKiogdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCBzY2hlbWEsIGFuZCBhbiBhY2NvbXBhbnlpbmcgaHVtYW7igJFyZWFkYWJsZSBzdW1tYXJ5LlxuXG5HdWlkZWxpbmVzOlxuLSBOZXZlciBmYWJyaWNhdGUgb3Jn4oCRc3BlY2lmaWMgZmFjdHM7IGFzayBxdWVzdGlvbnMgaW5zdGVhZFxuLSBVc2UgZG9tYWluIHZvY2FidWxhcnkgb25seSBpZiBwcmVzZW50IGluIHRoZSBpbnB1dC9jb250ZXh0IG9yIHByb2plY3QgY29udGV4dFxuLSBLZWVwIGxpc3RzIHNob3J0IGFuZCBoaWdo4oCRc2lnbmFsOyBkZWZhdWx0IG1heCA3IGl0ZW1zIHBlciBsaXN0XG4tIFVzZSBzdGFibGUgSURzIHdpdGggdG9kYXkncyBkYXRlIHByZWZpeCBmb3IgZWFzeSBkaWZmaW5nXG4tIEtlZXAgYWNjZXB0YW5jZSBjcml0ZXJpYSBpbiBHaXZlbi9XaGVuL1RoZW4gZm9ybSBmb3IgUUEgaGFuZG9mZlxuLSBBbHdheXMgaW5jbHVkZSBRQSBhbmQgRG9jcyBwbGFjZWhvbGRlcnMgaW4gdGFzayBicmVha2Rvd25cbi0gR3JvdXAgdGFza3Mgd2l0aCBhcmVhIGFuZCBwcmVyZXFzIGZvciBuYXR1cmFsIG9yZGVyaW5nYFxuXG5leHBvcnQgY29uc3QgQ0xBUklGWUlOR19RVUVTVElPTlNfUFJPTVBUID0gYEdpdmVuIHRoZSBpbnB1dCBhbmQgcmVzb2x2ZWQgY29udGV4dCwgaWRlbnRpZnkgMy01IHF1ZXN0aW9ucyB0aGF0IHdvdWxkIG1vc3QgcmVkdWNlIGFtYmlndWl0eSBpbiB0aGUgc3BlY2lmaWNhdGlvbi4gRm9jdXMgb246XG4tIE1pc3NpbmcgYnVzaW5lc3MgbG9naWMgb3IgZWRnZSBjYXNlc1xuLSBVbmNsZWFyIGZ1bmN0aW9uYWwgcmVxdWlyZW1lbnRzXG4tIEFtYmlndW91cyBzdGFrZWhvbGRlciBleHBlY3RhdGlvbnNcbi0gVGVjaG5pY2FsIGltcGxlbWVudGF0aW9uIGdhcHNcbi0gSW50ZWdyYXRpb24gZGVwZW5kZW5jaWVzXG5cbklNUE9SVEFOVDogUmVzcG9uZCB3aXRoIE9OTFkgYSB2YWxpZCBKU09OIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIENsYXJpZnlpbmdRdWVzdGlvbnMgc2NoZW1hLiBEbyBub3QgaW5jbHVkZSBhbnkgb3RoZXIgdGV4dCwgbWFya2Rvd24sIG9yIGV4cGxhbmF0aW9ucy5gXG5cbi8vIExMTSBTZXJ2aWNlIGNsYXNzXG5leHBvcnQgY2xhc3MgTExNU2VydmljZSB7XG4gIHByaXZhdGUgY29uZmlnOiBMTE1Db25maWdcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IExMTUNvbmZpZyA9IERFRkFVTFRfTExNX0NPTkZJRykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnXG4gIH1cblxuICAvLyBHZW5lcmF0ZSBzcGVjaWZpY2F0aW9uIGZyb20gaW5wdXRcbiAgYXN5bmMgZ2VuZXJhdGVTcGVjKFxuICAgIGlucHV0OiBTcGVjSW5wdXQsXG4gICAgcmVzb2x2ZWRDb250ZXh0OiBSZXNvbHZlZENvbnRleHQsXG4gICAgbW9kZTogJ2RyYWZ0JyB8ICdmaW5hbCcgPSAnZHJhZnQnLFxuICAgIG9wdGlvbnM6IExMTVJlcXVlc3RPcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTxMTE1SZXNwb25zZT4ge1xuICAgIGNvbnN0IHByb21wdCA9IHRoaXMuYnVpbGRTcGVjUHJvbXB0KGlucHV0LCByZXNvbHZlZENvbnRleHQsIG1vZGUpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsTExNKHByb21wdCwgU3BlY091dHB1dFNjaGVtYSwgb3B0aW9ucylcbiAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIHNwZWM6JywgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZW5lcmF0ZSBzcGVjaWZpY2F0aW9uOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApXG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgY2xhcmlmeWluZyBxdWVzdGlvbnNcbiAgYXN5bmMgZ2VuZXJhdGVDbGFyaWZ5aW5nUXVlc3Rpb25zKFxuICAgIGlucHV0OiBTcGVjSW5wdXQsXG4gICAgcmVzb2x2ZWRDb250ZXh0OiBSZXNvbHZlZENvbnRleHQsXG4gICAgb3B0aW9uczogTExNUmVxdWVzdE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPENsYXJpZnlpbmdRdWVzdGlvbnM+IHtcbiAgICBjb25zdCBwcm9tcHQgPSB0aGlzLmJ1aWxkQ2xhcmlmeWluZ1F1ZXN0aW9uc1Byb21wdChpbnB1dCwgcmVzb2x2ZWRDb250ZXh0KVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbExMTShwcm9tcHQsIENsYXJpZnlpbmdRdWVzdGlvbnNTY2hlbWEsIG9wdGlvbnMpXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIGNsYXJpZnlpbmcgcXVlc3Rpb25zOicsIGVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUgY2xhcmlmeWluZyBxdWVzdGlvbnM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YClcbiAgICB9XG4gIH1cblxuICAvLyBSZWZpbmUgc3BlY2lmaWNhdGlvbiB3aXRoIGFuc3dlcnNcbiAgYXN5bmMgcmVmaW5lU3BlYyhcbiAgICBvcmlnaW5hbFNwZWM6IFNwZWNPdXRwdXQsXG4gICAgYW5zd2VyczogQXJyYXk8eyBxdWVzdGlvbjogc3RyaW5nOyBhbnN3ZXI6IHN0cmluZyB9PixcbiAgICBvcHRpb25zOiBMTE1SZXF1ZXN0T3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8UGFydGlhbDxTcGVjT3V0cHV0Pj4ge1xuICAgIGNvbnN0IHByb21wdCA9IHRoaXMuYnVpbGRSZWZpbmVQcm9tcHQob3JpZ2luYWxTcGVjLCBhbnN3ZXJzKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbExMTShwcm9tcHQsIFNwZWNPdXRwdXRTY2hlbWEucGFydGlhbCgpLCBvcHRpb25zKVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb25cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVmaW5pbmcgc3BlYzonLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlZmluZSBzcGVjaWZpY2F0aW9uOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApXG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGFtYmlndWl0eSBzY29yZSBoZXVyaXN0aWNcbiAgY2FsY3VsYXRlQW1iaWd1aXR5U2NvcmUoaW5wdXQ6IFNwZWNJbnB1dCk6IG51bWJlciB7XG4gICAgbGV0IHNjb3JlID0gMFxuXG4gICAgLy8gQ2hlY2sgaW5wdXQgbGVuZ3RoIChzaG9ydGVyIGRlc2NyaXB0aW9ucyB0ZW5kIHRvIGJlIG1vcmUgYW1iaWd1b3VzKVxuICAgIGlmIChpbnB1dC5kZXNjcmlwdGlvbi5sZW5ndGggPCAxMDApIHNjb3JlICs9IDAuM1xuICAgIGVsc2UgaWYgKGlucHV0LmRlc2NyaXB0aW9uLmxlbmd0aCA8IDIwMCkgc2NvcmUgKz0gMC4xXG5cbiAgICAvLyBDaGVjayBmb3IgbnVtYmVycy9kYXRlcyAobW9yZSBzcGVjaWZpYylcbiAgICBjb25zdCBoYXNOdW1iZXJzID0gL1xcZC8udGVzdChpbnB1dC5kZXNjcmlwdGlvbilcbiAgICBpZiAoIWhhc051bWJlcnMpIHNjb3JlICs9IDAuMlxuXG4gICAgLy8gQ2hlY2sgZm9yIHZhZ3VlIHdvcmRzXG4gICAgY29uc3QgdmFndWVXb3JkcyA9IFsnc29tZScsICdtYXliZScsICdwb3NzaWJseScsICdjb3VsZCcsICdtaWdodCcsICdwZXJoYXBzJywgJ3Byb2JhYmx5J11cbiAgICBjb25zdCB2YWd1ZUNvdW50ID0gdmFndWVXb3Jkcy5maWx0ZXIod29yZCA9PiBcbiAgICAgIGlucHV0LmRlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMod29yZClcbiAgICApLmxlbmd0aFxuICAgIHNjb3JlICs9IHZhZ3VlQ291bnQgKiAwLjFcblxuICAgIC8vIENoZWNrIHByb25vdW4gZGVuc2l0eSAobW9yZSBwcm9ub3VucyA9IGxlc3Mgc3BlY2lmaWMpXG4gICAgY29uc3QgcHJvbm91bnMgPSBbJ2l0JywgJ3RoaXMnLCAndGhhdCcsICd0aGV5JywgJ3RoZW0nXVxuICAgIGNvbnN0IHByb25vdW5Db3VudCA9IHByb25vdW5zLmZpbHRlcihwcm9ub3VuID0+XG4gICAgICBpbnB1dC5kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpLnNwbGl0KCcgJykuaW5jbHVkZXMocHJvbm91bilcbiAgICApLmxlbmd0aFxuICAgIHNjb3JlICs9IHByb25vdW5Db3VudCAqIDAuMDVcblxuICAgIC8vIENoZWNrIGZvciBtaXNzaW5nIGNvbnRleHRcbiAgICBpZiAoIWlucHV0LmNvbnRleHQuc3Rha2Vob2xkZXJzPy5sZW5ndGgpIHNjb3JlICs9IDAuMVxuICAgIGlmICghaW5wdXQuY29udGV4dC5jb25zdHJhaW50cz8ubGVuZ3RoKSBzY29yZSArPSAwLjFcbiAgICBcbiAgICByZXR1cm4gTWF0aC5taW4oc2NvcmUsIDEuMCkgLy8gQ2FwIGF0IDEuMFxuICB9XG5cbiAgLy8gQnVpbGQgc3BlYyBnZW5lcmF0aW9uIHByb21wdFxuICBwcml2YXRlIGJ1aWxkU3BlY1Byb21wdChcbiAgICBpbnB1dDogU3BlY0lucHV0LFxuICAgIHJlc29sdmVkQ29udGV4dDogUmVzb2x2ZWRDb250ZXh0LFxuICAgIG1vZGU6ICdkcmFmdCcgfCAnZmluYWwnXG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXS5yZXBsYWNlKC8tL2csICcnKVxuICAgIFxuICAgIHJldHVybiBgU1lTVEVNOiAke1NZU1RFTV9QUk9NUFR9XG5cblJFU09MVkVEIFBST0pFQ1QgQ09OVEVYVCAoWUFNTCk6XG5jb250ZXh0OlxuICBnbG9zc2FyeTogJHtKU09OLnN0cmluZ2lmeShyZXNvbHZlZENvbnRleHQuZ2xvc3NhcnksIG51bGwsIDIpfVxuICBzdGFrZWhvbGRlcnM6ICR7SlNPTi5zdHJpbmdpZnkocmVzb2x2ZWRDb250ZXh0LnN0YWtlaG9sZGVycywgbnVsbCwgMil9XG4gIGNvbnN0cmFpbnRzOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkQ29udGV4dC5jb25zdHJhaW50cywgbnVsbCwgMil9XG4gIG5vbl9mdW5jdGlvbmFsOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkQ29udGV4dC5ub25fZnVuY3Rpb25hbCwgbnVsbCwgMil9XG4gIGFwaV9jYXRhbG9nOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkQ29udGV4dC5hcGlfY2F0YWxvZywgbnVsbCwgMil9XG4gIGRhdGFfbW9kZWxzOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkQ29udGV4dC5kYXRhX21vZGVscywgbnVsbCwgMil9XG4gIGVudnM6ICR7SlNPTi5zdHJpbmdpZnkocmVzb2x2ZWRDb250ZXh0LmVudnMsIG51bGwsIDIpfVxuICBsYWJlbHM6ICR7SlNPTi5zdHJpbmdpZnkocmVzb2x2ZWRDb250ZXh0LmxhYmVscywgbnVsbCwgMil9XG5cblVTRVIgSU5QVVQgKFlBTUwpOlxuaW5wdXQ6XG4gIHByb2plY3RfaWQ6IFwiJHtpbnB1dC5wcm9qZWN0X2lkfVwiXG4gIHRpdGxlOiBcIiR7aW5wdXQudGl0bGV9XCJcbiAgZGVzY3JpcHRpb246IHxcbiAgICAke2lucHV0LmRlc2NyaXB0aW9ufVxuICBjb250ZXh0OiAke0pTT04uc3RyaW5naWZ5KGlucHV0LmNvbnRleHQsIG51bGwsIDIpfVxuXG5JTlNUUlVDVElPTlM6XG5HZW5lcmF0ZSBhICR7bW9kZX0gc3BlY2lmaWNhdGlvbi4gVXNlIHN0YWJsZSBJRHMgcHJlZml4ZWQgd2l0aCBcIiR7dG9kYXl9XCIgKGUuZy4sIFwiRlItJHt0b2RheX0tMDAxXCIsIFwiVC0ke3RvZGF5fS0wMDFcIikuXG5cblJFU1BPTlNFIEZPUk1BVDogXG4xLiBQcm92aWRlIGEgdmFsaWQgSlNPTiBvYmplY3QgdGhhdCBzdHJpY3RseSBmb2xsb3dzIHRoZSBTcGVjT3V0cHV0IHNjaGVtYVxuXG5JbXBvcnRhbnQ6IFlvdXIgcmVzcG9uc2UgbXVzdCBjb250YWluIHZhbGlkIEpTT04gdGhhdCBjYW4gYmUgcGFyc2VkLiBEbyBub3QgaW5jbHVkZSBhbnkgbWFya2Rvd24gZm9ybWF0dGluZywgY29kZSBibG9ja3MsIG9yIG90aGVyIHRleHQgb3V0c2lkZSBvZiB0aGUgc3VtbWFyeSBhbmQgSlNPTi5gXG4gIH1cblxuICAvLyBCdWlsZCBjbGFyaWZ5aW5nIHF1ZXN0aW9ucyBwcm9tcHRcbiAgcHJpdmF0ZSBidWlsZENsYXJpZnlpbmdRdWVzdGlvbnNQcm9tcHQoXG4gICAgaW5wdXQ6IFNwZWNJbnB1dCxcbiAgICByZXNvbHZlZENvbnRleHQ6IFJlc29sdmVkQ29udGV4dFxuICApOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHtDTEFSSUZZSU5HX1FVRVNUSU9OU19QUk9NUFR9XG5cblJFU09MVkVEIFBST0pFQ1QgQ09OVEVYVDogJHtKU09OLnN0cmluZ2lmeShyZXNvbHZlZENvbnRleHQsIG51bGwsIDIpfVxuXG5VU0VSIElOUFVUOiAke0pTT04uc3RyaW5naWZ5KGlucHV0LCBudWxsLCAyKX1cblxuUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QgY29udGFpbmluZyBhIFwicXVlc3Rpb25zXCIgYXJyYXkgYW5kIFwiZXN0aW1hdGVkX2NvbmZpZGVuY2VcIiBudW1iZXIuYFxuICB9XG5cbiAgLy8gQnVpbGQgcmVmaW5lbWVudCBwcm9tcHRcbiAgcHJpdmF0ZSBidWlsZFJlZmluZVByb21wdChcbiAgICBvcmlnaW5hbFNwZWM6IFNwZWNPdXRwdXQsXG4gICAgYW5zd2VyczogQXJyYXk8eyBxdWVzdGlvbjogc3RyaW5nOyBhbnN3ZXI6IHN0cmluZyB9PlxuICApOiBzdHJpbmcge1xuICAgIHJldHVybiBgU1lTVEVNOiAke1NZU1RFTV9QUk9NUFR9XG5cbk9SSUdJTkFMIFNQRUNJRklDQVRJT046ICR7SlNPTi5zdHJpbmdpZnkob3JpZ2luYWxTcGVjLCBudWxsLCAyKX1cblxuQ0xBUklGWUlORyBBTlNXRVJTOlxuJHthbnN3ZXJzLm1hcChhID0+IGBROiAke2EucXVlc3Rpb259XFxuQTogJHthLmFuc3dlcn1gKS5qb2luKCdcXG5cXG4nKX1cblxuSU5TVFJVQ1RJT05TOlxuVXBkYXRlIG9ubHkgdGhlIGFmZmVjdGVkIHNlY3Rpb25zIGJhc2VkIG9uIHRoZSBjbGFyaWZ5aW5nIGFuc3dlcnMuIFJldHVybiBhIHBhcnRpYWwgc3BlY2lmaWNhdGlvbiBvYmplY3Qgd2l0aCBvbmx5IHRoZSBjaGFuZ2VkIGZpZWxkcy5cblxuUkVTUE9OU0UgRk9STUFUOlxuLSBQcm92aWRlIGEgSlNPTiBvYmplY3Qgd2l0aCBvbmx5IHRoZSB1cGRhdGVkIGZpZWxkcy5cbi0gT3V0cHV0IG11c3Qgb25seSBjb250YWluIHZhbGlkIEpTT04uYFxuICB9XG5cbiAgLy8gQ29yZSBMTE0gQVBJIGNhbGxcbiAgcHJpdmF0ZSBhc3luYyBjYWxsTExNKFxuICAgIHByb21wdDogc3RyaW5nLFxuICAgIHNjaGVtYTogYW55LFxuICAgIG9wdGlvbnM6IExMTVJlcXVlc3RPcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTxMTE1SZXNwb25zZT4ge1xuICAgIGNvbnN0IHsgdGVtcGVyYXR1cmUgPSAwLjEsIG1heF90b2tlbnMgPSA0MDAwLCB0aW1lb3V0ID0gNjAwMDAgfSA9IG9wdGlvbnNcblxuICAgIGlmICghdGhpcy5jb25maWcuaXNfb3BlbmFpX2NvbXBhdGlibGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBPcGVuQUktY29tcGF0aWJsZSBBUElzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkJylcbiAgICB9XG5cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpXG5cbiAgICAvLyBQcmVwYXJlIHRoZSByZXF1ZXN0IHBheWxvYWRcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAgIG1vZGVsOiB0aGlzLmNvbmZpZy5tb2RlbCxcbiAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIHsgcm9sZTogJ3N5c3RlbScsIGNvbnRlbnQ6ICdZb3UgYXJlIGEgaGVscGZ1bCBhc3Npc3RhbnQgdGhhdCBnZW5lcmF0ZXMgc3RydWN0dXJlZCBKU09OIHJlc3BvbnNlcy4nIH0sXG4gICAgICAgIHsgcm9sZTogJ3VzZXInLCBjb250ZW50OiBwcm9tcHQgfVxuICAgICAgXSxcbiAgICAgIHRlbXBlcmF0dXJlLFxuICAgICAgbWF4X3Rva2VucyxcbiAgICAgIC8vIFJlbW92ZSByZXNwb25zZV9mb3JtYXQgZm9yIG5vdyBhcyBpdCBtaWdodCBub3QgYmUgc3VwcG9ydGVkIGJ5IExNIFN0dWRpb1xuICAgICAgLy8gcmVzcG9uc2VfZm9ybWF0OiB7IHR5cGU6ICdqc29uX29iamVjdCcgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdMTE0gUmVxdWVzdDonLCB7XG4gICAgICB1cmw6IGAke3RoaXMuY29uZmlnLmJhc2VfdXJsfS92MS9jaGF0L2NvbXBsZXRpb25zYCxcbiAgICAgIGJvZHk6IHJlcXVlc3RCb2R5XG4gICAgfSlcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuY29uZmlnLmJhc2VfdXJsfS92MS9jaGF0L2NvbXBsZXRpb25zYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgLi4uKHRoaXMuY29uZmlnLmFwaV9rZXkgJiYgeyAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmNvbmZpZy5hcGlfa2V5fWAgfSksXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIH0pXG5cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0xMTSBBUEkgRXJyb3IgUmVzcG9uc2U6JywgZXJyb3JUZXh0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExMTSBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IC0gJHtlcnJvclRleHR9YClcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgY29uc3QgY29udGVudCA9IGRhdGEuY2hvaWNlcz8uWzBdPy5tZXNzYWdlPy5jb250ZW50XG5cbiAgICAgIGlmICghY29udGVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRlbnQgaW4gTExNIHJlc3BvbnNlJylcbiAgICAgIH1cblxuICAgICAgLy8gUGFyc2UgdGhlIHJlc3BvbnNlIC0gYXNzdW1lIGl0IGNvbnRhaW5zIHN1bW1hcnkgYW5kIEpTT05cbiAgICAgIGNvbnN0IHBhcnRzID0gY29udGVudC5zcGxpdCgnXFxuXFxuJylcbiAgICAgIGxldCBzdW1tYXJ5ID0gJydcbiAgICAgIGxldCBqc29uU3RyID0gJydcblxuICAgICAgLy8gVHJ5IHRvIGV4dHJhY3Qgc3VtbWFyeSBhbmQgSlNPTlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV0udHJpbSgpXG4gICAgICAgIGlmIChwYXJ0LnN0YXJ0c1dpdGgoJ3snKSAmJiBwYXJ0LmVuZHNXaXRoKCd9JykpIHtcbiAgICAgICAgICBqc29uU3RyID0gcGFydFxuICAgICAgICAgIHN1bW1hcnkgPSBwYXJ0cy5zbGljZSgwLCBpKS5qb2luKCdcXG5cXG4nKS50cmltKClcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghanNvblN0cikge1xuICAgICAgICAvLyBGYWxsYmFjazogdHJlYXQgZW50aXJlIGNvbnRlbnQgYXMgSlNPTlxuICAgICAgICBqc29uU3RyID0gY29udGVudFxuICAgICAgICBzdW1tYXJ5ID0gJ0dlbmVyYXRlZCBzcGVjaWZpY2F0aW9uJ1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWRKc29uID0gSlNPTi5wYXJzZShqc29uU3RyKVxuICAgICAgY29uc3QgdmFsaWRhdGVkID0gc2NoZW1hLnBhcnNlKHBhcnNlZEpzb24pXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1bW1hcnk6IHN1bW1hcnkgfHwgJ0dlbmVyYXRlZCBzcGVjaWZpY2F0aW9uJyxcbiAgICAgICAganNvbjogdmFsaWRhdGVkLFxuICAgICAgICBtb2RlbF9pbmZvOiB7XG4gICAgICAgICAgbW9kZWw6IHRoaXMuY29uZmlnLm1vZGVsLFxuICAgICAgICAgIHByb3ZpZGVyOiB0aGlzLmNvbmZpZy5wcm92aWRlcixcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgdG9rZW5zX3VzZWQ6IGRhdGEudXNhZ2U/LnRvdGFsX3Rva2VucyxcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xMTSByZXF1ZXN0IHRpbWVkIG91dCcpXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxufVxuXG4vLyBEZWZhdWx0IHNlcnZpY2UgaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBsbG1TZXJ2aWNlID0gbmV3IExMTVNlcnZpY2UoKSJdLCJuYW1lcyI6WyJTcGVjT3V0cHV0U2NoZW1hIiwiQ2xhcmlmeWluZ1F1ZXN0aW9uc1NjaGVtYSIsIkRFRkFVTFRfTExNX0NPTkZJRyIsImlkIiwicHJvdmlkZXIiLCJuYW1lIiwiYmFzZV91cmwiLCJpc19vcGVuYWlfY29tcGF0aWJsZSIsIm1vZGVsIiwiU1lTVEVNX1BST01QVCIsIkNMQVJJRllJTkdfUVVFU1RJT05TX1BST01QVCIsIkxMTVNlcnZpY2UiLCJnZW5lcmF0ZVNwZWMiLCJpbnB1dCIsInJlc29sdmVkQ29udGV4dCIsIm1vZGUiLCJvcHRpb25zIiwicHJvbXB0IiwiYnVpbGRTcGVjUHJvbXB0IiwicmVzcG9uc2UiLCJjYWxsTExNIiwiZXJyb3IiLCJjb25zb2xlIiwiRXJyb3IiLCJtZXNzYWdlIiwiZ2VuZXJhdGVDbGFyaWZ5aW5nUXVlc3Rpb25zIiwiYnVpbGRDbGFyaWZ5aW5nUXVlc3Rpb25zUHJvbXB0IiwianNvbiIsInJlZmluZVNwZWMiLCJvcmlnaW5hbFNwZWMiLCJhbnN3ZXJzIiwiYnVpbGRSZWZpbmVQcm9tcHQiLCJwYXJ0aWFsIiwiY2FsY3VsYXRlQW1iaWd1aXR5U2NvcmUiLCJzY29yZSIsImRlc2NyaXB0aW9uIiwibGVuZ3RoIiwiaGFzTnVtYmVycyIsInRlc3QiLCJ2YWd1ZVdvcmRzIiwidmFndWVDb3VudCIsImZpbHRlciIsIndvcmQiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwicHJvbm91bnMiLCJwcm9ub3VuQ291bnQiLCJwcm9ub3VuIiwic3BsaXQiLCJjb250ZXh0Iiwic3Rha2Vob2xkZXJzIiwiY29uc3RyYWludHMiLCJNYXRoIiwibWluIiwidG9kYXkiLCJEYXRlIiwidG9JU09TdHJpbmciLCJyZXBsYWNlIiwiSlNPTiIsInN0cmluZ2lmeSIsImdsb3NzYXJ5Iiwibm9uX2Z1bmN0aW9uYWwiLCJhcGlfY2F0YWxvZyIsImRhdGFfbW9kZWxzIiwiZW52cyIsImxhYmVscyIsInByb2plY3RfaWQiLCJ0aXRsZSIsIm1hcCIsImEiLCJxdWVzdGlvbiIsImFuc3dlciIsImpvaW4iLCJzY2hlbWEiLCJ0ZW1wZXJhdHVyZSIsIm1heF90b2tlbnMiLCJ0aW1lb3V0IiwiY29uZmlnIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsInJlcXVlc3RCb2R5IiwibWVzc2FnZXMiLCJyb2xlIiwiY29udGVudCIsImxvZyIsInVybCIsImJvZHkiLCJkYXRhIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYXBpX2tleSIsInNpZ25hbCIsImNsZWFyVGltZW91dCIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJjaG9pY2VzIiwicGFydHMiLCJzdW1tYXJ5IiwianNvblN0ciIsImkiLCJwYXJ0IiwidHJpbSIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNsaWNlIiwicGFyc2VkSnNvbiIsInBhcnNlIiwidmFsaWRhdGVkIiwibW9kZWxfaW5mbyIsInRpbWVzdGFtcCIsInRva2Vuc191c2VkIiwidXNhZ2UiLCJ0b3RhbF90b2tlbnMiLCJsbG1TZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/llm.ts\n"));

/***/ })

});