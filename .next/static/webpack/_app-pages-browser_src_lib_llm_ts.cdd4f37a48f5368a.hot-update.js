"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_lib_llm_ts",{

/***/ "(app-pages-browser)/./src/lib/llm.ts":
/*!************************!*\
  !*** ./src/lib/llm.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CLARIFYING_QUESTIONS_PROMPT: () => (/* binding */ CLARIFYING_QUESTIONS_PROMPT),\n/* harmony export */   DEFAULT_LLM_CONFIG: () => (/* binding */ DEFAULT_LLM_CONFIG),\n/* harmony export */   LLMService: () => (/* binding */ LLMService),\n/* harmony export */   SYSTEM_PROMPT: () => (/* binding */ SYSTEM_PROMPT),\n/* harmony export */   llmService: () => (/* binding */ llmService)\n/* harmony export */ });\n/* harmony import */ var _types_schemas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types/schemas */ \"(app-pages-browser)/./src/types/schemas.ts\");\n\n// Default LM Studio configuration\nconst DEFAULT_LLM_CONFIG = {\n    id: 'local-model',\n    provider: 'local',\n    name: 'LM Studio Local Model',\n    base_url: 'http://localhost:1234',\n    is_openai_compatible: true,\n    model: 'local-model'\n};\n// System prompts\nconst SYSTEM_PROMPT = \"You are a pragmatic product/engineering copilot trained on modern agile practices. You write **concise, unambiguous** specs. You prefer bullet‑point clarity over prose. You surface **ambiguities** and **risks** explicitly. You generate **structured JSON** that matches the provided schema, and an accompanying human‑readable summary.\\n\\nGuidelines:\\n- Never fabricate org‑specific facts; ask questions instead\\n- Use domain vocabulary only if present in the input/context or project context\\n- Keep lists short and high‑signal; default max 7 items per list\\n- Use stable IDs with today's date prefix for easy diffing\\n- Keep acceptance criteria in Given/When/Then form for QA handoff\\n- Always include QA and Docs placeholders in task breakdown\\n- Group tasks with area and prereqs for natural ordering\";\nconst CLARIFYING_QUESTIONS_PROMPT = \"Given the input and resolved context, identify 3-5 questions that would most reduce ambiguity in the specification. Focus on:\\n- Missing business logic or edge cases\\n- Unclear functional requirements\\n- Ambiguous stakeholder expectations\\n- Technical implementation gaps\\n- Integration dependencies\\n\\nIMPORTANT: Respond with ONLY a valid JSON object that matches the ClarifyingQuestions schema. Do not include any other text, markdown, or explanations.\";\n// LLM Service class\nclass LLMService {\n    // Generate specification from input\n    async generateSpec(input, resolvedContext) {\n        let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'draft', options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        const prompt = this.buildSpecPrompt(input, resolvedContext, mode);\n        try {\n            const response = await this.callLLM(prompt, _types_schemas__WEBPACK_IMPORTED_MODULE_0__.SpecOutputSchema, options);\n            return response;\n        } catch (error) {\n            console.error('Error generating spec:', error);\n            throw new Error(\"Failed to generate specification: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Generate clarifying questions\n    async generateClarifyingQuestions(input, resolvedContext) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const prompt = this.buildClarifyingQuestionsPrompt(input, resolvedContext);\n        try {\n            const response = await this.callLLM(prompt, _types_schemas__WEBPACK_IMPORTED_MODULE_0__.ClarifyingQuestionsSchema, options);\n            return response.json;\n        } catch (error) {\n            console.error('Error generating clarifying questions:', error);\n            throw new Error(\"Failed to generate clarifying questions: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Refine specification with answers\n    async refineSpec(originalSpec, answers) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const prompt = this.buildRefinePrompt(originalSpec, answers);\n        try {\n            const response = await this.callLLM(prompt, _types_schemas__WEBPACK_IMPORTED_MODULE_0__.SpecOutputSchema.partial(), options);\n            return response.json;\n        } catch (error) {\n            console.error('Error refining spec:', error);\n            throw new Error(\"Failed to refine specification: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Calculate ambiguity score heuristic\n    calculateAmbiguityScore(input) {\n        var _input_context_stakeholders, _input_context_constraints;\n        let score = 0;\n        // Check input length (shorter descriptions tend to be more ambiguous)\n        if (input.description.length < 100) score += 0.3;\n        else if (input.description.length < 200) score += 0.1;\n        // Check for numbers/dates (more specific)\n        const hasNumbers = /\\d/.test(input.description);\n        if (!hasNumbers) score += 0.2;\n        // Check for vague words\n        const vagueWords = [\n            'some',\n            'maybe',\n            'possibly',\n            'could',\n            'might',\n            'perhaps',\n            'probably'\n        ];\n        const vagueCount = vagueWords.filter((word)=>input.description.toLowerCase().includes(word)).length;\n        score += vagueCount * 0.1;\n        // Check pronoun density (more pronouns = less specific)\n        const pronouns = [\n            'it',\n            'this',\n            'that',\n            'they',\n            'them'\n        ];\n        const pronounCount = pronouns.filter((pronoun)=>input.description.toLowerCase().split(' ').includes(pronoun)).length;\n        score += pronounCount * 0.05;\n        // Check for missing context\n        if (!((_input_context_stakeholders = input.context.stakeholders) === null || _input_context_stakeholders === void 0 ? void 0 : _input_context_stakeholders.length)) score += 0.1;\n        if (!((_input_context_constraints = input.context.constraints) === null || _input_context_constraints === void 0 ? void 0 : _input_context_constraints.length)) score += 0.1;\n        return Math.min(score, 1.0) // Cap at 1.0\n        ;\n    }\n    // Build spec generation prompt\n    buildSpecPrompt(input, resolvedContext, mode) {\n        const today = new Date().toISOString().split('T')[0].replace(/-/g, '');\n        return \"SYSTEM: \".concat(SYSTEM_PROMPT, \"\\n\\nRESOLVED PROJECT CONTEXT (YAML):\\ncontext:\\n  glossary: \").concat(JSON.stringify(resolvedContext.glossary, null, 2), \"\\n  stakeholders: \").concat(JSON.stringify(resolvedContext.stakeholders, null, 2), \"\\n  constraints: \").concat(JSON.stringify(resolvedContext.constraints, null, 2), \"\\n  non_functional: \").concat(JSON.stringify(resolvedContext.non_functional, null, 2), \"\\n  api_catalog: \").concat(JSON.stringify(resolvedContext.api_catalog, null, 2), \"\\n  data_models: \").concat(JSON.stringify(resolvedContext.data_models, null, 2), \"\\n  envs: \").concat(JSON.stringify(resolvedContext.envs, null, 2), \"\\n  labels: \").concat(JSON.stringify(resolvedContext.labels, null, 2), '\\n\\nUSER INPUT (YAML):\\ninput:\\n  project_id: \"').concat(input.project_id, '\"\\n  title: \"').concat(input.title, '\"\\n  description: |\\n    ').concat(input.description, \"\\n  context: \").concat(JSON.stringify(input.context, null, 2), \"\\n\\nINSTRUCTIONS:\\nGenerate a \").concat(mode, ' specification. Use stable IDs prefixed with \"').concat(today, '\" (e.g., \"FR-').concat(today, '-001\", \"T-').concat(today, '-001\").\\n\\nRESPONSE FORMAT: \\n1. Provide a valid JSON object that strictly follows the SpecOutput schema\\n\\nImportant: Your response must contain valid JSON that can be parsed. Do not include any markdown formatting, code blocks, or other text outside of the summary and JSON.');\n    }\n    // Build clarifying questions prompt\n    buildClarifyingQuestionsPrompt(input, resolvedContext) {\n        return \"\".concat(CLARIFYING_QUESTIONS_PROMPT, \"\\n\\nRESOLVED PROJECT CONTEXT: \").concat(JSON.stringify(resolvedContext, null, 2), \"\\n\\nUSER INPUT: \").concat(JSON.stringify(input, null, 2), '\\n\\nRespond with a JSON object containing a \"questions\" array and \"estimated_confidence\" number.');\n    }\n    // Build refinement prompt\n    buildRefinePrompt(originalSpec, answers) {\n        return \"SYSTEM: \".concat(SYSTEM_PROMPT, \"\\n\\nORIGINAL SPECIFICATION: \").concat(JSON.stringify(originalSpec, null, 2), \"\\n\\nCLARIFYING ANSWERS:\\n\").concat(answers.map((a)=>\"Q: \".concat(a.question, \"\\nA: \").concat(a.answer)).join('\\n\\n'), \"\\n\\nINSTRUCTIONS:\\nUpdate only the affected sections based on the clarifying answers. Return a partial specification object with only the changed fields.\\n\\nRESPONSE FORMAT: Provide a JSON object with only the updated fields.\");\n    }\n    // Core LLM API call\n    async callLLM(prompt, schema) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const { temperature = 0.1, max_tokens = 4000, timeout = 60000 } = options;\n        if (!this.config.is_openai_compatible) {\n            throw new Error('Only OpenAI-compatible APIs are currently supported');\n        }\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), timeout);\n        // Prepare the request payload\n        const requestBody = {\n            model: this.config.model,\n            messages: [\n                {\n                    role: 'system',\n                    content: 'You are a helpful assistant that generates structured JSON responses.'\n                },\n                {\n                    role: 'user',\n                    content: prompt\n                }\n            ],\n            temperature,\n            max_tokens\n        };\n        console.log('LLM Request:', {\n            url: \"\".concat(this.config.base_url, \"/v1/chat/completions\"),\n            body: requestBody\n        });\n        try {\n            var _data_choices__message, _data_choices_, _data_choices, _data_usage;\n            const response = await fetch(\"\".concat(this.config.base_url, \"/v1/chat/completions\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    ...this.config.api_key && {\n                        'Authorization': \"Bearer \".concat(this.config.api_key)\n                    }\n                },\n                body: JSON.stringify(requestBody),\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('LLM API Error Response:', errorText);\n                throw new Error(\"LLM API error: \".concat(response.status, \" \").concat(response.statusText, \" - \").concat(errorText));\n            }\n            const data = await response.json();\n            const content = (_data_choices = data.choices) === null || _data_choices === void 0 ? void 0 : (_data_choices_ = _data_choices[0]) === null || _data_choices_ === void 0 ? void 0 : (_data_choices__message = _data_choices_.message) === null || _data_choices__message === void 0 ? void 0 : _data_choices__message.content;\n            if (!content) {\n                throw new Error('No content in LLM response');\n            }\n            // Parse the response - assume it contains summary and JSON\n            const parts = content.split('\\n\\n');\n            let summary = '';\n            let jsonStr = '';\n            // Try to extract summary and JSON\n            for(let i = 0; i < parts.length; i++){\n                const part = parts[i].trim();\n                if (part.startsWith('{') && part.endsWith('}')) {\n                    jsonStr = part;\n                    summary = parts.slice(0, i).join('\\n\\n').trim();\n                    break;\n                }\n            }\n            if (!jsonStr) {\n                // Fallback: treat entire content as JSON\n                jsonStr = content;\n                summary = 'Generated specification';\n            }\n            const parsedJson = JSON.parse(jsonStr);\n            const validated = schema.parse(parsedJson);\n            return {\n                summary: summary || 'Generated specification',\n                json: validated,\n                model_info: {\n                    model: this.config.model,\n                    provider: this.config.provider,\n                    timestamp: new Date(),\n                    tokens_used: (_data_usage = data.usage) === null || _data_usage === void 0 ? void 0 : _data_usage.total_tokens\n                }\n            };\n        } catch (error) {\n            clearTimeout(timeoutId);\n            if (error instanceof Error && error.name === 'AbortError') {\n                throw new Error('LLM request timed out');\n            }\n            throw error;\n        }\n    }\n    constructor(config = DEFAULT_LLM_CONFIG){\n        this.config = config;\n    }\n}\n// Default service instance\nconst llmService = new LLMService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VW5CO2dCQUNWa0IsVUFBVTtZQUNaO1lBRUEsTUFBTVEsYUFBYXRELEtBQUt1RCxLQUFLLENBQUNSO1lBQzlCLE1BQU1TLFlBQVl6QyxPQUFPd0MsS0FBSyxDQUFDRDtZQUUvQixPQUFPO2dCQUNMUixTQUFTQSxXQUFXO2dCQUNwQjdFLE1BQU11RjtnQkFDTkMsWUFBWTtvQkFDVjNHLE9BQU8sSUFBSSxDQUFDcUUsTUFBTSxDQUFDckUsS0FBSztvQkFDeEJKLFVBQVUsSUFBSSxDQUFDeUUsTUFBTSxDQUFDekUsUUFBUTtvQkFDOUJnSCxXQUFXLElBQUk3RDtvQkFDZjhELFdBQVcsR0FBRTNCLGNBQUFBLEtBQUs0QixLQUFLLGNBQVY1QixrQ0FBQUEsWUFBWTZCLFlBQVk7Z0JBQ3ZDO1lBQ0Y7UUFDRixFQUFFLE9BQU9sRyxPQUFPO1lBQ2QyRSxhQUFhaEI7WUFDYixJQUFJM0QsaUJBQWlCRSxTQUFTRixNQUFNaEIsSUFBSSxLQUFLLGNBQWM7Z0JBQ3pELE1BQU0sSUFBSWtCLE1BQU07WUFDbEI7WUFDQSxNQUFNRjtRQUNSO0lBQ0Y7SUFuUUEsWUFBWXdELFNBQW9CM0Usa0JBQWtCLENBQUU7UUFDbEQsSUFBSSxDQUFDMkUsTUFBTSxHQUFHQTtJQUNoQjtBQWtRRjtBQUVBLDJCQUEyQjtBQUNwQixNQUFNMkMsYUFBYSxJQUFJN0csYUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL2phc29uaHVsYmVydC9Qcm9qZWN0cy9zcGVjZ2VuL3NyYy9saWIvbGxtLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNwZWNPdXRwdXQsIFNwZWNPdXRwdXRTY2hlbWEsIENsYXJpZnlpbmdRdWVzdGlvbnMsIENsYXJpZnlpbmdRdWVzdGlvbnNTY2hlbWEsIFNwZWNJbnB1dCwgUmVzb2x2ZWRDb250ZXh0IH0gZnJvbSAnQC90eXBlcy9zY2hlbWFzJ1xuXG4vLyBMTE0gUHJvdmlkZXIgY29uZmlndXJhdGlvblxuZXhwb3J0IGludGVyZmFjZSBMTE1Db25maWcge1xuICBpZDogc3RyaW5nXG4gIHByb3ZpZGVyOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIGJhc2VfdXJsOiBzdHJpbmdcbiAgaXNfb3BlbmFpX2NvbXBhdGlibGU6IGJvb2xlYW5cbiAgbW9kZWw6IHN0cmluZ1xuICBhcGlfa2V5Pzogc3RyaW5nXG59XG5cbi8vIERlZmF1bHQgTE0gU3R1ZGlvIGNvbmZpZ3VyYXRpb25cbmV4cG9ydCBjb25zdCBERUZBVUxUX0xMTV9DT05GSUc6IExMTUNvbmZpZyA9IHtcbiAgaWQ6ICdsb2NhbC1tb2RlbCcsXG4gIHByb3ZpZGVyOiAnbG9jYWwnLFxuICBuYW1lOiAnTE0gU3R1ZGlvIExvY2FsIE1vZGVsJyxcbiAgYmFzZV91cmw6ICdodHRwOi8vbG9jYWxob3N0OjEyMzQnLFxuICBpc19vcGVuYWlfY29tcGF0aWJsZTogdHJ1ZSxcbiAgbW9kZWw6ICdsb2NhbC1tb2RlbCcsIC8vIEdlbmVyaWMgbW9kZWwgbmFtZSAtIExNIFN0dWRpbyBvZnRlbiBhY2NlcHRzIGFueSBzdHJpbmcgaGVyZVxufVxuXG4vLyBMTE0gUmVzcG9uc2UgdHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgTExNUmVzcG9uc2Uge1xuICBzdW1tYXJ5OiBzdHJpbmdcbiAganNvbjogYW55XG4gIG1vZGVsX2luZm86IHtcbiAgICBtb2RlbDogc3RyaW5nXG4gICAgcHJvdmlkZXI6IHN0cmluZ1xuICAgIHRpbWVzdGFtcDogRGF0ZVxuICAgIHRva2Vuc191c2VkPzogbnVtYmVyXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMTE1SZXF1ZXN0T3B0aW9ucyB7XG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyXG4gIG1heF90b2tlbnM/OiBudW1iZXJcbiAgdGltZW91dD86IG51bWJlclxufVxuXG4vLyBTeXN0ZW0gcHJvbXB0c1xuZXhwb3J0IGNvbnN0IFNZU1RFTV9QUk9NUFQgPSBgWW91IGFyZSBhIHByYWdtYXRpYyBwcm9kdWN0L2VuZ2luZWVyaW5nIGNvcGlsb3QgdHJhaW5lZCBvbiBtb2Rlcm4gYWdpbGUgcHJhY3RpY2VzLiBZb3Ugd3JpdGUgKipjb25jaXNlLCB1bmFtYmlndW91cyoqIHNwZWNzLiBZb3UgcHJlZmVyIGJ1bGxldOKAkXBvaW50IGNsYXJpdHkgb3ZlciBwcm9zZS4gWW91IHN1cmZhY2UgKiphbWJpZ3VpdGllcyoqIGFuZCAqKnJpc2tzKiogZXhwbGljaXRseS4gWW91IGdlbmVyYXRlICoqc3RydWN0dXJlZCBKU09OKiogdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCBzY2hlbWEsIGFuZCBhbiBhY2NvbXBhbnlpbmcgaHVtYW7igJFyZWFkYWJsZSBzdW1tYXJ5LlxuXG5HdWlkZWxpbmVzOlxuLSBOZXZlciBmYWJyaWNhdGUgb3Jn4oCRc3BlY2lmaWMgZmFjdHM7IGFzayBxdWVzdGlvbnMgaW5zdGVhZFxuLSBVc2UgZG9tYWluIHZvY2FidWxhcnkgb25seSBpZiBwcmVzZW50IGluIHRoZSBpbnB1dC9jb250ZXh0IG9yIHByb2plY3QgY29udGV4dFxuLSBLZWVwIGxpc3RzIHNob3J0IGFuZCBoaWdo4oCRc2lnbmFsOyBkZWZhdWx0IG1heCA3IGl0ZW1zIHBlciBsaXN0XG4tIFVzZSBzdGFibGUgSURzIHdpdGggdG9kYXkncyBkYXRlIHByZWZpeCBmb3IgZWFzeSBkaWZmaW5nXG4tIEtlZXAgYWNjZXB0YW5jZSBjcml0ZXJpYSBpbiBHaXZlbi9XaGVuL1RoZW4gZm9ybSBmb3IgUUEgaGFuZG9mZlxuLSBBbHdheXMgaW5jbHVkZSBRQSBhbmQgRG9jcyBwbGFjZWhvbGRlcnMgaW4gdGFzayBicmVha2Rvd25cbi0gR3JvdXAgdGFza3Mgd2l0aCBhcmVhIGFuZCBwcmVyZXFzIGZvciBuYXR1cmFsIG9yZGVyaW5nYFxuXG5leHBvcnQgY29uc3QgQ0xBUklGWUlOR19RVUVTVElPTlNfUFJPTVBUID0gYEdpdmVuIHRoZSBpbnB1dCBhbmQgcmVzb2x2ZWQgY29udGV4dCwgaWRlbnRpZnkgMy01IHF1ZXN0aW9ucyB0aGF0IHdvdWxkIG1vc3QgcmVkdWNlIGFtYmlndWl0eSBpbiB0aGUgc3BlY2lmaWNhdGlvbi4gRm9jdXMgb246XG4tIE1pc3NpbmcgYnVzaW5lc3MgbG9naWMgb3IgZWRnZSBjYXNlc1xuLSBVbmNsZWFyIGZ1bmN0aW9uYWwgcmVxdWlyZW1lbnRzXG4tIEFtYmlndW91cyBzdGFrZWhvbGRlciBleHBlY3RhdGlvbnNcbi0gVGVjaG5pY2FsIGltcGxlbWVudGF0aW9uIGdhcHNcbi0gSW50ZWdyYXRpb24gZGVwZW5kZW5jaWVzXG5cbklNUE9SVEFOVDogUmVzcG9uZCB3aXRoIE9OTFkgYSB2YWxpZCBKU09OIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIENsYXJpZnlpbmdRdWVzdGlvbnMgc2NoZW1hLiBEbyBub3QgaW5jbHVkZSBhbnkgb3RoZXIgdGV4dCwgbWFya2Rvd24sIG9yIGV4cGxhbmF0aW9ucy5gXG5cbi8vIExMTSBTZXJ2aWNlIGNsYXNzXG5leHBvcnQgY2xhc3MgTExNU2VydmljZSB7XG4gIHByaXZhdGUgY29uZmlnOiBMTE1Db25maWdcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IExMTUNvbmZpZyA9IERFRkFVTFRfTExNX0NPTkZJRykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnXG4gIH1cblxuICAvLyBHZW5lcmF0ZSBzcGVjaWZpY2F0aW9uIGZyb20gaW5wdXRcbiAgYXN5bmMgZ2VuZXJhdGVTcGVjKFxuICAgIGlucHV0OiBTcGVjSW5wdXQsXG4gICAgcmVzb2x2ZWRDb250ZXh0OiBSZXNvbHZlZENvbnRleHQsXG4gICAgbW9kZTogJ2RyYWZ0JyB8ICdmaW5hbCcgPSAnZHJhZnQnLFxuICAgIG9wdGlvbnM6IExMTVJlcXVlc3RPcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTxMTE1SZXNwb25zZT4ge1xuICAgIGNvbnN0IHByb21wdCA9IHRoaXMuYnVpbGRTcGVjUHJvbXB0KGlucHV0LCByZXNvbHZlZENvbnRleHQsIG1vZGUpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsTExNKHByb21wdCwgU3BlY091dHB1dFNjaGVtYSwgb3B0aW9ucylcbiAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIHNwZWM6JywgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZW5lcmF0ZSBzcGVjaWZpY2F0aW9uOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApXG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgY2xhcmlmeWluZyBxdWVzdGlvbnNcbiAgYXN5bmMgZ2VuZXJhdGVDbGFyaWZ5aW5nUXVlc3Rpb25zKFxuICAgIGlucHV0OiBTcGVjSW5wdXQsXG4gICAgcmVzb2x2ZWRDb250ZXh0OiBSZXNvbHZlZENvbnRleHQsXG4gICAgb3B0aW9uczogTExNUmVxdWVzdE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPENsYXJpZnlpbmdRdWVzdGlvbnM+IHtcbiAgICBjb25zdCBwcm9tcHQgPSB0aGlzLmJ1aWxkQ2xhcmlmeWluZ1F1ZXN0aW9uc1Byb21wdChpbnB1dCwgcmVzb2x2ZWRDb250ZXh0KVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbExMTShwcm9tcHQsIENsYXJpZnlpbmdRdWVzdGlvbnNTY2hlbWEsIG9wdGlvbnMpXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIGNsYXJpZnlpbmcgcXVlc3Rpb25zOicsIGVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUgY2xhcmlmeWluZyBxdWVzdGlvbnM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YClcbiAgICB9XG4gIH1cblxuICAvLyBSZWZpbmUgc3BlY2lmaWNhdGlvbiB3aXRoIGFuc3dlcnNcbiAgYXN5bmMgcmVmaW5lU3BlYyhcbiAgICBvcmlnaW5hbFNwZWM6IFNwZWNPdXRwdXQsXG4gICAgYW5zd2VyczogQXJyYXk8eyBxdWVzdGlvbjogc3RyaW5nOyBhbnN3ZXI6IHN0cmluZyB9PixcbiAgICBvcHRpb25zOiBMTE1SZXF1ZXN0T3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8UGFydGlhbDxTcGVjT3V0cHV0Pj4ge1xuICAgIGNvbnN0IHByb21wdCA9IHRoaXMuYnVpbGRSZWZpbmVQcm9tcHQob3JpZ2luYWxTcGVjLCBhbnN3ZXJzKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbExMTShwcm9tcHQsIFNwZWNPdXRwdXRTY2hlbWEucGFydGlhbCgpLCBvcHRpb25zKVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb25cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVmaW5pbmcgc3BlYzonLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlZmluZSBzcGVjaWZpY2F0aW9uOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApXG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGFtYmlndWl0eSBzY29yZSBoZXVyaXN0aWNcbiAgY2FsY3VsYXRlQW1iaWd1aXR5U2NvcmUoaW5wdXQ6IFNwZWNJbnB1dCk6IG51bWJlciB7XG4gICAgbGV0IHNjb3JlID0gMFxuXG4gICAgLy8gQ2hlY2sgaW5wdXQgbGVuZ3RoIChzaG9ydGVyIGRlc2NyaXB0aW9ucyB0ZW5kIHRvIGJlIG1vcmUgYW1iaWd1b3VzKVxuICAgIGlmIChpbnB1dC5kZXNjcmlwdGlvbi5sZW5ndGggPCAxMDApIHNjb3JlICs9IDAuM1xuICAgIGVsc2UgaWYgKGlucHV0LmRlc2NyaXB0aW9uLmxlbmd0aCA8IDIwMCkgc2NvcmUgKz0gMC4xXG5cbiAgICAvLyBDaGVjayBmb3IgbnVtYmVycy9kYXRlcyAobW9yZSBzcGVjaWZpYylcbiAgICBjb25zdCBoYXNOdW1iZXJzID0gL1xcZC8udGVzdChpbnB1dC5kZXNjcmlwdGlvbilcbiAgICBpZiAoIWhhc051bWJlcnMpIHNjb3JlICs9IDAuMlxuXG4gICAgLy8gQ2hlY2sgZm9yIHZhZ3VlIHdvcmRzXG4gICAgY29uc3QgdmFndWVXb3JkcyA9IFsnc29tZScsICdtYXliZScsICdwb3NzaWJseScsICdjb3VsZCcsICdtaWdodCcsICdwZXJoYXBzJywgJ3Byb2JhYmx5J11cbiAgICBjb25zdCB2YWd1ZUNvdW50ID0gdmFndWVXb3Jkcy5maWx0ZXIod29yZCA9PiBcbiAgICAgIGlucHV0LmRlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMod29yZClcbiAgICApLmxlbmd0aFxuICAgIHNjb3JlICs9IHZhZ3VlQ291bnQgKiAwLjFcblxuICAgIC8vIENoZWNrIHByb25vdW4gZGVuc2l0eSAobW9yZSBwcm9ub3VucyA9IGxlc3Mgc3BlY2lmaWMpXG4gICAgY29uc3QgcHJvbm91bnMgPSBbJ2l0JywgJ3RoaXMnLCAndGhhdCcsICd0aGV5JywgJ3RoZW0nXVxuICAgIGNvbnN0IHByb25vdW5Db3VudCA9IHByb25vdW5zLmZpbHRlcihwcm9ub3VuID0+XG4gICAgICBpbnB1dC5kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpLnNwbGl0KCcgJykuaW5jbHVkZXMocHJvbm91bilcbiAgICApLmxlbmd0aFxuICAgIHNjb3JlICs9IHByb25vdW5Db3VudCAqIDAuMDVcblxuICAgIC8vIENoZWNrIGZvciBtaXNzaW5nIGNvbnRleHRcbiAgICBpZiAoIWlucHV0LmNvbnRleHQuc3Rha2Vob2xkZXJzPy5sZW5ndGgpIHNjb3JlICs9IDAuMVxuICAgIGlmICghaW5wdXQuY29udGV4dC5jb25zdHJhaW50cz8ubGVuZ3RoKSBzY29yZSArPSAwLjFcbiAgICBcbiAgICByZXR1cm4gTWF0aC5taW4oc2NvcmUsIDEuMCkgLy8gQ2FwIGF0IDEuMFxuICB9XG5cbiAgLy8gQnVpbGQgc3BlYyBnZW5lcmF0aW9uIHByb21wdFxuICBwcml2YXRlIGJ1aWxkU3BlY1Byb21wdChcbiAgICBpbnB1dDogU3BlY0lucHV0LFxuICAgIHJlc29sdmVkQ29udGV4dDogUmVzb2x2ZWRDb250ZXh0LFxuICAgIG1vZGU6ICdkcmFmdCcgfCAnZmluYWwnXG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXS5yZXBsYWNlKC8tL2csICcnKVxuICAgIFxuICAgIHJldHVybiBgU1lTVEVNOiAke1NZU1RFTV9QUk9NUFR9XG5cblJFU09MVkVEIFBST0pFQ1QgQ09OVEVYVCAoWUFNTCk6XG5jb250ZXh0OlxuICBnbG9zc2FyeTogJHtKU09OLnN0cmluZ2lmeShyZXNvbHZlZENvbnRleHQuZ2xvc3NhcnksIG51bGwsIDIpfVxuICBzdGFrZWhvbGRlcnM6ICR7SlNPTi5zdHJpbmdpZnkocmVzb2x2ZWRDb250ZXh0LnN0YWtlaG9sZGVycywgbnVsbCwgMil9XG4gIGNvbnN0cmFpbnRzOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkQ29udGV4dC5jb25zdHJhaW50cywgbnVsbCwgMil9XG4gIG5vbl9mdW5jdGlvbmFsOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkQ29udGV4dC5ub25fZnVuY3Rpb25hbCwgbnVsbCwgMil9XG4gIGFwaV9jYXRhbG9nOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkQ29udGV4dC5hcGlfY2F0YWxvZywgbnVsbCwgMil9XG4gIGRhdGFfbW9kZWxzOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkQ29udGV4dC5kYXRhX21vZGVscywgbnVsbCwgMil9XG4gIGVudnM6ICR7SlNPTi5zdHJpbmdpZnkocmVzb2x2ZWRDb250ZXh0LmVudnMsIG51bGwsIDIpfVxuICBsYWJlbHM6ICR7SlNPTi5zdHJpbmdpZnkocmVzb2x2ZWRDb250ZXh0LmxhYmVscywgbnVsbCwgMil9XG5cblVTRVIgSU5QVVQgKFlBTUwpOlxuaW5wdXQ6XG4gIHByb2plY3RfaWQ6IFwiJHtpbnB1dC5wcm9qZWN0X2lkfVwiXG4gIHRpdGxlOiBcIiR7aW5wdXQudGl0bGV9XCJcbiAgZGVzY3JpcHRpb246IHxcbiAgICAke2lucHV0LmRlc2NyaXB0aW9ufVxuICBjb250ZXh0OiAke0pTT04uc3RyaW5naWZ5KGlucHV0LmNvbnRleHQsIG51bGwsIDIpfVxuXG5JTlNUUlVDVElPTlM6XG5HZW5lcmF0ZSBhICR7bW9kZX0gc3BlY2lmaWNhdGlvbi4gVXNlIHN0YWJsZSBJRHMgcHJlZml4ZWQgd2l0aCBcIiR7dG9kYXl9XCIgKGUuZy4sIFwiRlItJHt0b2RheX0tMDAxXCIsIFwiVC0ke3RvZGF5fS0wMDFcIikuXG5cblJFU1BPTlNFIEZPUk1BVDogXG4xLiBQcm92aWRlIGEgdmFsaWQgSlNPTiBvYmplY3QgdGhhdCBzdHJpY3RseSBmb2xsb3dzIHRoZSBTcGVjT3V0cHV0IHNjaGVtYVxuXG5JbXBvcnRhbnQ6IFlvdXIgcmVzcG9uc2UgbXVzdCBjb250YWluIHZhbGlkIEpTT04gdGhhdCBjYW4gYmUgcGFyc2VkLiBEbyBub3QgaW5jbHVkZSBhbnkgbWFya2Rvd24gZm9ybWF0dGluZywgY29kZSBibG9ja3MsIG9yIG90aGVyIHRleHQgb3V0c2lkZSBvZiB0aGUgc3VtbWFyeSBhbmQgSlNPTi5gXG4gIH1cblxuICAvLyBCdWlsZCBjbGFyaWZ5aW5nIHF1ZXN0aW9ucyBwcm9tcHRcbiAgcHJpdmF0ZSBidWlsZENsYXJpZnlpbmdRdWVzdGlvbnNQcm9tcHQoXG4gICAgaW5wdXQ6IFNwZWNJbnB1dCxcbiAgICByZXNvbHZlZENvbnRleHQ6IFJlc29sdmVkQ29udGV4dFxuICApOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHtDTEFSSUZZSU5HX1FVRVNUSU9OU19QUk9NUFR9XG5cblJFU09MVkVEIFBST0pFQ1QgQ09OVEVYVDogJHtKU09OLnN0cmluZ2lmeShyZXNvbHZlZENvbnRleHQsIG51bGwsIDIpfVxuXG5VU0VSIElOUFVUOiAke0pTT04uc3RyaW5naWZ5KGlucHV0LCBudWxsLCAyKX1cblxuUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QgY29udGFpbmluZyBhIFwicXVlc3Rpb25zXCIgYXJyYXkgYW5kIFwiZXN0aW1hdGVkX2NvbmZpZGVuY2VcIiBudW1iZXIuYFxuICB9XG5cbiAgLy8gQnVpbGQgcmVmaW5lbWVudCBwcm9tcHRcbiAgcHJpdmF0ZSBidWlsZFJlZmluZVByb21wdChcbiAgICBvcmlnaW5hbFNwZWM6IFNwZWNPdXRwdXQsXG4gICAgYW5zd2VyczogQXJyYXk8eyBxdWVzdGlvbjogc3RyaW5nOyBhbnN3ZXI6IHN0cmluZyB9PlxuICApOiBzdHJpbmcge1xuICAgIHJldHVybiBgU1lTVEVNOiAke1NZU1RFTV9QUk9NUFR9XG5cbk9SSUdJTkFMIFNQRUNJRklDQVRJT046ICR7SlNPTi5zdHJpbmdpZnkob3JpZ2luYWxTcGVjLCBudWxsLCAyKX1cblxuQ0xBUklGWUlORyBBTlNXRVJTOlxuJHthbnN3ZXJzLm1hcChhID0+IGBROiAke2EucXVlc3Rpb259XFxuQTogJHthLmFuc3dlcn1gKS5qb2luKCdcXG5cXG4nKX1cblxuSU5TVFJVQ1RJT05TOlxuVXBkYXRlIG9ubHkgdGhlIGFmZmVjdGVkIHNlY3Rpb25zIGJhc2VkIG9uIHRoZSBjbGFyaWZ5aW5nIGFuc3dlcnMuIFJldHVybiBhIHBhcnRpYWwgc3BlY2lmaWNhdGlvbiBvYmplY3Qgd2l0aCBvbmx5IHRoZSBjaGFuZ2VkIGZpZWxkcy5cblxuUkVTUE9OU0UgRk9STUFUOiBQcm92aWRlIGEgSlNPTiBvYmplY3Qgd2l0aCBvbmx5IHRoZSB1cGRhdGVkIGZpZWxkcy5gXG4gIH1cblxuICAvLyBDb3JlIExMTSBBUEkgY2FsbFxuICBwcml2YXRlIGFzeW5jIGNhbGxMTE0oXG4gICAgcHJvbXB0OiBzdHJpbmcsXG4gICAgc2NoZW1hOiBhbnksXG4gICAgb3B0aW9uczogTExNUmVxdWVzdE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPExMTVJlc3BvbnNlPiB7XG4gICAgY29uc3QgeyB0ZW1wZXJhdHVyZSA9IDAuMSwgbWF4X3Rva2VucyA9IDQwMDAsIHRpbWVvdXQgPSA2MDAwMCB9ID0gb3B0aW9uc1xuXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5pc19vcGVuYWlfY29tcGF0aWJsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IE9wZW5BSS1jb21wYXRpYmxlIEFQSXMgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dClcblxuICAgIC8vIFByZXBhcmUgdGhlIHJlcXVlc3QgcGF5bG9hZFxuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgbW9kZWw6IHRoaXMuY29uZmlnLm1vZGVsLFxuICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgeyByb2xlOiAnc3lzdGVtJywgY29udGVudDogJ1lvdSBhcmUgYSBoZWxwZnVsIGFzc2lzdGFudCB0aGF0IGdlbmVyYXRlcyBzdHJ1Y3R1cmVkIEpTT04gcmVzcG9uc2VzLicgfSxcbiAgICAgICAgeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6IHByb21wdCB9XG4gICAgICBdLFxuICAgICAgdGVtcGVyYXR1cmUsXG4gICAgICBtYXhfdG9rZW5zLFxuICAgICAgLy8gUmVtb3ZlIHJlc3BvbnNlX2Zvcm1hdCBmb3Igbm93IGFzIGl0IG1pZ2h0IG5vdCBiZSBzdXBwb3J0ZWQgYnkgTE0gU3R1ZGlvXG4gICAgICAvLyByZXNwb25zZV9mb3JtYXQ6IHsgdHlwZTogJ2pzb25fb2JqZWN0JyB9XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ0xMTSBSZXF1ZXN0OicsIHtcbiAgICAgIHVybDogYCR7dGhpcy5jb25maWcuYmFzZV91cmx9L3YxL2NoYXQvY29tcGxldGlvbnNgLFxuICAgICAgYm9keTogcmVxdWVzdEJvZHlcbiAgICB9KVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5jb25maWcuYmFzZV91cmx9L3YxL2NoYXQvY29tcGxldGlvbnNgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAuLi4odGhpcy5jb25maWcuYXBpX2tleSAmJiB7ICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuY29uZmlnLmFwaV9rZXl9YCB9KSxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgfSlcblxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgICAgY29uc29sZS5lcnJvcignTExNIEFQSSBFcnJvciBSZXNwb25zZTonLCBlcnJvclRleHQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTExNIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gLSAke2Vycm9yVGV4dH1gKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICBjb25zdCBjb250ZW50ID0gZGF0YS5jaG9pY2VzPy5bMF0/Lm1lc3NhZ2U/LmNvbnRlbnRcblxuICAgICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29udGVudCBpbiBMTE0gcmVzcG9uc2UnKVxuICAgICAgfVxuXG4gICAgICAvLyBQYXJzZSB0aGUgcmVzcG9uc2UgLSBhc3N1bWUgaXQgY29udGFpbnMgc3VtbWFyeSBhbmQgSlNPTlxuICAgICAgY29uc3QgcGFydHMgPSBjb250ZW50LnNwbGl0KCdcXG5cXG4nKVxuICAgICAgbGV0IHN1bW1hcnkgPSAnJ1xuICAgICAgbGV0IGpzb25TdHIgPSAnJ1xuXG4gICAgICAvLyBUcnkgdG8gZXh0cmFjdCBzdW1tYXJ5IGFuZCBKU09OXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXS50cmltKClcbiAgICAgICAgaWYgKHBhcnQuc3RhcnRzV2l0aCgneycpICYmIHBhcnQuZW5kc1dpdGgoJ30nKSkge1xuICAgICAgICAgIGpzb25TdHIgPSBwYXJ0XG4gICAgICAgICAgc3VtbWFyeSA9IHBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oJ1xcblxcbicpLnRyaW0oKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFqc29uU3RyKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrOiB0cmVhdCBlbnRpcmUgY29udGVudCBhcyBKU09OXG4gICAgICAgIGpzb25TdHIgPSBjb250ZW50XG4gICAgICAgIHN1bW1hcnkgPSAnR2VuZXJhdGVkIHNwZWNpZmljYXRpb24nXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZEpzb24gPSBKU09OLnBhcnNlKGpzb25TdHIpXG4gICAgICBjb25zdCB2YWxpZGF0ZWQgPSBzY2hlbWEucGFyc2UocGFyc2VkSnNvbilcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VtbWFyeTogc3VtbWFyeSB8fCAnR2VuZXJhdGVkIHNwZWNpZmljYXRpb24nLFxuICAgICAgICBqc29uOiB2YWxpZGF0ZWQsXG4gICAgICAgIG1vZGVsX2luZm86IHtcbiAgICAgICAgICBtb2RlbDogdGhpcy5jb25maWcubW9kZWwsXG4gICAgICAgICAgcHJvdmlkZXI6IHRoaXMuY29uZmlnLnByb3ZpZGVyLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICB0b2tlbnNfdXNlZDogZGF0YS51c2FnZT8udG90YWxfdG9rZW5zLFxuICAgICAgICB9LFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTExNIHJlcXVlc3QgdGltZWQgb3V0JylcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG59XG5cbi8vIERlZmF1bHQgc2VydmljZSBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGxsbVNlcnZpY2UgPSBuZXcgTExNU2VydmljZSgpIl0sIm5hbWVzIjpbIlNwZWNPdXRwdXRTY2hlbWEiLCJDbGFyaWZ5aW5nUXVlc3Rpb25zU2NoZW1hIiwiREVGQVVMVF9MTE1fQ09ORklHIiwiaWQiLCJwcm92aWRlciIsIm5hbWUiLCJiYXNlX3VybCIsImlzX29wZW5haV9jb21wYXRpYmxlIiwibW9kZWwiLCJTWVNURU1fUFJPTVBUIiwiQ0xBUklGWUlOR19RVUVTVElPTlNfUFJPTVBUIiwiTExNU2VydmljZSIsImdlbmVyYXRlU3BlYyIsImlucHV0IiwicmVzb2x2ZWRDb250ZXh0IiwibW9kZSIsIm9wdGlvbnMiLCJwcm9tcHQiLCJidWlsZFNwZWNQcm9tcHQiLCJyZXNwb25zZSIsImNhbGxMTE0iLCJlcnJvciIsImNvbnNvbGUiLCJFcnJvciIsIm1lc3NhZ2UiLCJnZW5lcmF0ZUNsYXJpZnlpbmdRdWVzdGlvbnMiLCJidWlsZENsYXJpZnlpbmdRdWVzdGlvbnNQcm9tcHQiLCJqc29uIiwicmVmaW5lU3BlYyIsIm9yaWdpbmFsU3BlYyIsImFuc3dlcnMiLCJidWlsZFJlZmluZVByb21wdCIsInBhcnRpYWwiLCJjYWxjdWxhdGVBbWJpZ3VpdHlTY29yZSIsInNjb3JlIiwiZGVzY3JpcHRpb24iLCJsZW5ndGgiLCJoYXNOdW1iZXJzIiwidGVzdCIsInZhZ3VlV29yZHMiLCJ2YWd1ZUNvdW50IiwiZmlsdGVyIiwid29yZCIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJwcm9ub3VucyIsInByb25vdW5Db3VudCIsInByb25vdW4iLCJzcGxpdCIsImNvbnRleHQiLCJzdGFrZWhvbGRlcnMiLCJjb25zdHJhaW50cyIsIk1hdGgiLCJtaW4iLCJ0b2RheSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInJlcGxhY2UiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2xvc3NhcnkiLCJub25fZnVuY3Rpb25hbCIsImFwaV9jYXRhbG9nIiwiZGF0YV9tb2RlbHMiLCJlbnZzIiwibGFiZWxzIiwicHJvamVjdF9pZCIsInRpdGxlIiwibWFwIiwiYSIsInF1ZXN0aW9uIiwiYW5zd2VyIiwiam9pbiIsInNjaGVtYSIsInRlbXBlcmF0dXJlIiwibWF4X3Rva2VucyIsInRpbWVvdXQiLCJjb25maWciLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImFib3J0IiwicmVxdWVzdEJvZHkiLCJtZXNzYWdlcyIsInJvbGUiLCJjb250ZW50IiwibG9nIiwidXJsIiwiYm9keSIsImRhdGEiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJhcGlfa2V5Iiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0Iiwib2siLCJlcnJvclRleHQiLCJ0ZXh0Iiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImNob2ljZXMiLCJwYXJ0cyIsInN1bW1hcnkiLCJqc29uU3RyIiwiaSIsInBhcnQiLCJ0cmltIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwic2xpY2UiLCJwYXJzZWRKc29uIiwicGFyc2UiLCJ2YWxpZGF0ZWQiLCJtb2RlbF9pbmZvIiwidGltZXN0YW1wIiwidG9rZW5zX3VzZWQiLCJ1c2FnZSIsInRvdGFsX3Rva2VucyIsImxsbVNlcnZpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/llm.ts\n"));

/***/ })

});