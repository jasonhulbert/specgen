"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_projectContext_ts"],{

/***/ "(app-pages-browser)/./node_modules/idb/build/index.js":
/*!*****************************************!*\
  !*** ./node_modules/idb/build/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteDB: () => (/* binding */ deleteDB),\n/* harmony export */   openDB: () => (/* binding */ openDB),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\nconst instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pZGIvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUNBQXlDLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVSxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFeUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNvbmh1bGJlcnQvUHJvamVjdHMvc3BlY2dlbi9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGluc3RhbmNlT2ZBbnkgPSAob2JqZWN0LCBjb25zdHJ1Y3RvcnMpID0+IGNvbnN0cnVjdG9ycy5zb21lKChjKSA9PiBvYmplY3QgaW5zdGFuY2VvZiBjKTtcblxubGV0IGlkYlByb3h5YWJsZVR5cGVzO1xubGV0IGN1cnNvckFkdmFuY2VNZXRob2RzO1xuLy8gVGhpcyBpcyBhIGZ1bmN0aW9uIHRvIHByZXZlbnQgaXQgdGhyb3dpbmcgdXAgaW4gbm9kZSBlbnZpcm9ubWVudHMuXG5mdW5jdGlvbiBnZXRJZGJQcm94eWFibGVUeXBlcygpIHtcbiAgICByZXR1cm4gKGlkYlByb3h5YWJsZVR5cGVzIHx8XG4gICAgICAgIChpZGJQcm94eWFibGVUeXBlcyA9IFtcbiAgICAgICAgICAgIElEQkRhdGFiYXNlLFxuICAgICAgICAgICAgSURCT2JqZWN0U3RvcmUsXG4gICAgICAgICAgICBJREJJbmRleCxcbiAgICAgICAgICAgIElEQkN1cnNvcixcbiAgICAgICAgICAgIElEQlRyYW5zYWN0aW9uLFxuICAgICAgICBdKSk7XG59XG4vLyBUaGlzIGlzIGEgZnVuY3Rpb24gdG8gcHJldmVudCBpdCB0aHJvd2luZyB1cCBpbiBub2RlIGVudmlyb25tZW50cy5cbmZ1bmN0aW9uIGdldEN1cnNvckFkdmFuY2VNZXRob2RzKCkge1xuICAgIHJldHVybiAoY3Vyc29yQWR2YW5jZU1ldGhvZHMgfHxcbiAgICAgICAgKGN1cnNvckFkdmFuY2VNZXRob2RzID0gW1xuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5hZHZhbmNlLFxuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5jb250aW51ZSxcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuY29udGludWVQcmltYXJ5S2V5LFxuICAgICAgICBdKSk7XG59XG5jb25zdCB0cmFuc2FjdGlvbkRvbmVNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgdHJhbnNmb3JtQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHByb21pc2lmeVJlcXVlc3QocmVxdWVzdCkge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVubGlzdGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgc3VjY2Vzcyk7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSh3cmFwKHJlcXVlc3QucmVzdWx0KSk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignc3VjY2VzcycsIHN1Y2Nlc3MpO1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH0pO1xuICAgIC8vIFRoaXMgbWFwcGluZyBleGlzdHMgaW4gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlIGJ1dCBkb2Vzbid0IGV4aXN0IGluIHRyYW5zZm9ybUNhY2hlLiBUaGlzXG4gICAgLy8gaXMgYmVjYXVzZSB3ZSBjcmVhdGUgbWFueSBwcm9taXNlcyBmcm9tIGEgc2luZ2xlIElEQlJlcXVlc3QuXG4gICAgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLnNldChwcm9taXNlLCByZXF1ZXN0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbih0eCkge1xuICAgIC8vIEVhcmx5IGJhaWwgaWYgd2UndmUgYWxyZWFkeSBjcmVhdGVkIGEgZG9uZSBwcm9taXNlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgIGlmICh0cmFuc2FjdGlvbkRvbmVNYXAuaGFzKHR4KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRvbmUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVubGlzdGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29tcGxldGUnLCBjb21wbGV0ZSk7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KHR4LmVycm9yIHx8IG5ldyBET01FeGNlcHRpb24oJ0Fib3J0RXJyb3InLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgY29tcGxldGUpO1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBlcnJvcik7XG4gICAgfSk7XG4gICAgLy8gQ2FjaGUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbC5cbiAgICB0cmFuc2FjdGlvbkRvbmVNYXAuc2V0KHR4LCBkb25lKTtcbn1cbmxldCBpZGJQcm94eVRyYXBzID0ge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgdHJhbnNhY3Rpb24uZG9uZS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnZG9uZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uRG9uZU1hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIE1ha2UgdHguc3RvcmUgcmV0dXJuIHRoZSBvbmx5IHN0b3JlIGluIHRoZSB0cmFuc2FjdGlvbiwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBtYW55LlxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdzdG9yZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWl2ZXIub2JqZWN0U3RvcmVOYW1lc1sxXVxuICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IHJlY2VpdmVyLm9iamVjdFN0b3JlKHJlY2VpdmVyLm9iamVjdFN0b3JlTmFtZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVsc2UgdHJhbnNmb3JtIHdoYXRldmVyIHdlIGdldCBiYWNrLlxuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXRbcHJvcF0pO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24gJiZcbiAgICAgICAgICAgIChwcm9wID09PSAnZG9uZScgfHwgcHJvcCA9PT0gJ3N0b3JlJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wIGluIHRhcmdldDtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHJlcGxhY2VUcmFwcyhjYWxsYmFjaykge1xuICAgIGlkYlByb3h5VHJhcHMgPSBjYWxsYmFjayhpZGJQcm94eVRyYXBzKTtcbn1cbmZ1bmN0aW9uIHdyYXBGdW5jdGlvbihmdW5jKSB7XG4gICAgLy8gRHVlIHRvIGV4cGVjdGVkIG9iamVjdCBlcXVhbGl0eSAod2hpY2ggaXMgZW5mb3JjZWQgYnkgdGhlIGNhY2hpbmcgaW4gYHdyYXBgKSwgd2VcbiAgICAvLyBvbmx5IGNyZWF0ZSBvbmUgbmV3IGZ1bmMgcGVyIGZ1bmMuXG4gICAgLy8gQ3Vyc29yIG1ldGhvZHMgYXJlIHNwZWNpYWwsIGFzIHRoZSBiZWhhdmlvdXIgaXMgYSBsaXR0bGUgbW9yZSBkaWZmZXJlbnQgdG8gc3RhbmRhcmQgSURCLiBJblxuICAgIC8vIElEQiwgeW91IGFkdmFuY2UgdGhlIGN1cnNvciBhbmQgd2FpdCBmb3IgYSBuZXcgJ3N1Y2Nlc3MnIG9uIHRoZSBJREJSZXF1ZXN0IHRoYXQgZ2F2ZSB5b3UgdGhlXG4gICAgLy8gY3Vyc29yLiBJdCdzIGtpbmRhIGxpa2UgYSBwcm9taXNlIHRoYXQgY2FuIHJlc29sdmUgd2l0aCBtYW55IHZhbHVlcy4gVGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2VcbiAgICAvLyB3aXRoIHJlYWwgcHJvbWlzZXMsIHNvIGVhY2ggYWR2YW5jZSBtZXRob2RzIHJldHVybnMgYSBuZXcgcHJvbWlzZSBmb3IgdGhlIGN1cnNvciBvYmplY3QsIG9yXG4gICAgLy8gdW5kZWZpbmVkIGlmIHRoZSBlbmQgb2YgdGhlIGN1cnNvciBoYXMgYmVlbiByZWFjaGVkLlxuICAgIGlmIChnZXRDdXJzb3JBZHZhbmNlTWV0aG9kcygpLmluY2x1ZGVzKGZ1bmMpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgLy8gQ2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJveHkgYXMgJ3RoaXMnIGNhdXNlcyBJTExFR0FMIElOVk9DQVRJT04sIHNvIHdlIHVzZVxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgICAgICAgIGZ1bmMuYXBwbHkodW53cmFwKHRoaXMpLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB3cmFwKHRoaXMucmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAvLyBDYWxsaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm94eSBhcyAndGhpcycgY2F1c2VzIElMTEVHQUwgSU5WT0NBVElPTiwgc28gd2UgdXNlXG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAgIHJldHVybiB3cmFwKGZ1bmMuYXBwbHkodW53cmFwKHRoaXMpLCBhcmdzKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUNhY2hhYmxlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gd3JhcEZ1bmN0aW9uKHZhbHVlKTtcbiAgICAvLyBUaGlzIGRvZXNuJ3QgcmV0dXJuLCBpdCBqdXN0IGNyZWF0ZXMgYSAnZG9uZScgcHJvbWlzZSBmb3IgdGhlIHRyYW5zYWN0aW9uLFxuICAgIC8vIHdoaWNoIGlzIGxhdGVyIHJldHVybmVkIGZvciB0cmFuc2FjdGlvbi5kb25lIChzZWUgaWRiT2JqZWN0SGFuZGxlcikuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24pXG4gICAgICAgIGNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbih2YWx1ZSk7XG4gICAgaWYgKGluc3RhbmNlT2ZBbnkodmFsdWUsIGdldElkYlByb3h5YWJsZVR5cGVzKCkpKVxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHZhbHVlLCBpZGJQcm94eVRyYXBzKTtcbiAgICAvLyBSZXR1cm4gdGhlIHNhbWUgdmFsdWUgYmFjayBpZiB3ZSdyZSBub3QgZ29pbmcgdG8gdHJhbnNmb3JtIGl0LlxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHdyYXAodmFsdWUpIHtcbiAgICAvLyBXZSBzb21ldGltZXMgZ2VuZXJhdGUgbXVsdGlwbGUgcHJvbWlzZXMgZnJvbSBhIHNpbmdsZSBJREJSZXF1ZXN0IChlZyB3aGVuIGN1cnNvcmluZyksIGJlY2F1c2VcbiAgICAvLyBJREIgaXMgd2VpcmQgYW5kIGEgc2luZ2xlIElEQlJlcXVlc3QgY2FuIHlpZWxkIG1hbnkgcmVzcG9uc2VzLCBzbyB0aGVzZSBjYW4ndCBiZSBjYWNoZWQuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSURCUmVxdWVzdClcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeVJlcXVlc3QodmFsdWUpO1xuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgdHJhbnNmb3JtZWQgdGhpcyB2YWx1ZSBiZWZvcmUsIHJldXNlIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZS5cbiAgICAvLyBUaGlzIGlzIGZhc3RlciwgYnV0IGl0IGFsc28gcHJvdmlkZXMgb2JqZWN0IGVxdWFsaXR5LlxuICAgIGlmICh0cmFuc2Zvcm1DYWNoZS5oYXModmFsdWUpKVxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtQ2FjaGUuZ2V0KHZhbHVlKTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHRyYW5zZm9ybUNhY2hhYmxlVmFsdWUodmFsdWUpO1xuICAgIC8vIE5vdCBhbGwgdHlwZXMgYXJlIHRyYW5zZm9ybWVkLlxuICAgIC8vIFRoZXNlIG1heSBiZSBwcmltaXRpdmUgdHlwZXMsIHNvIHRoZXkgY2FuJ3QgYmUgV2Vha01hcCBrZXlzLlxuICAgIGlmIChuZXdWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdHJhbnNmb3JtQ2FjaGUuc2V0KHZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5zZXQobmV3VmFsdWUsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xufVxuY29uc3QgdW53cmFwID0gKHZhbHVlKSA9PiByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuZ2V0KHZhbHVlKTtcblxuLyoqXG4gKiBPcGVuIGEgZGF0YWJhc2UuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgZGF0YWJhc2UuXG4gKiBAcGFyYW0gdmVyc2lvbiBTY2hlbWEgdmVyc2lvbi5cbiAqIEBwYXJhbSBjYWxsYmFja3MgQWRkaXRpb25hbCBjYWxsYmFja3MuXG4gKi9cbmZ1bmN0aW9uIG9wZW5EQihuYW1lLCB2ZXJzaW9uLCB7IGJsb2NrZWQsIHVwZ3JhZGUsIGJsb2NraW5nLCB0ZXJtaW5hdGVkIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihuYW1lLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBvcGVuUHJvbWlzZSA9IHdyYXAocmVxdWVzdCk7XG4gICAgaWYgKHVwZ3JhZGUpIHtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCd1cGdyYWRlbmVlZGVkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB1cGdyYWRlKHdyYXAocmVxdWVzdC5yZXN1bHQpLCBldmVudC5vbGRWZXJzaW9uLCBldmVudC5uZXdWZXJzaW9uLCB3cmFwKHJlcXVlc3QudHJhbnNhY3Rpb24pLCBldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYmxvY2tlZCkge1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Jsb2NrZWQnLCAoZXZlbnQpID0+IGJsb2NrZWQoXG4gICAgICAgIC8vIENhc3RpbmcgZHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC1ET00tbGliLWdlbmVyYXRvci9wdWxsLzE0MDVcbiAgICAgICAgZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQubmV3VmVyc2lvbiwgZXZlbnQpKTtcbiAgICB9XG4gICAgb3BlblByb21pc2VcbiAgICAgICAgLnRoZW4oKGRiKSA9PiB7XG4gICAgICAgIGlmICh0ZXJtaW5hdGVkKVxuICAgICAgICAgICAgZGIuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoKSA9PiB0ZXJtaW5hdGVkKCkpO1xuICAgICAgICBpZiAoYmxvY2tpbmcpIHtcbiAgICAgICAgICAgIGRiLmFkZEV2ZW50TGlzdGVuZXIoJ3ZlcnNpb25jaGFuZ2UnLCAoZXZlbnQpID0+IGJsb2NraW5nKGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50Lm5ld1ZlcnNpb24sIGV2ZW50KSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICByZXR1cm4gb3BlblByb21pc2U7XG59XG4vKipcbiAqIERlbGV0ZSBhIGRhdGFiYXNlLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGRhdGFiYXNlLlxuICovXG5mdW5jdGlvbiBkZWxldGVEQihuYW1lLCB7IGJsb2NrZWQgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShuYW1lKTtcbiAgICBpZiAoYmxvY2tlZCkge1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Jsb2NrZWQnLCAoZXZlbnQpID0+IGJsb2NrZWQoXG4gICAgICAgIC8vIENhc3RpbmcgZHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC1ET00tbGliLWdlbmVyYXRvci9wdWxsLzE0MDVcbiAgICAgICAgZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXAocmVxdWVzdCkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xufVxuXG5jb25zdCByZWFkTWV0aG9kcyA9IFsnZ2V0JywgJ2dldEtleScsICdnZXRBbGwnLCAnZ2V0QWxsS2V5cycsICdjb3VudCddO1xuY29uc3Qgd3JpdGVNZXRob2RzID0gWydwdXQnLCAnYWRkJywgJ2RlbGV0ZScsICdjbGVhciddO1xuY29uc3QgY2FjaGVkTWV0aG9kcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHtcbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBJREJEYXRhYmFzZSAmJlxuICAgICAgICAhKHByb3AgaW4gdGFyZ2V0KSAmJlxuICAgICAgICB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhY2hlZE1ldGhvZHMuZ2V0KHByb3ApKVxuICAgICAgICByZXR1cm4gY2FjaGVkTWV0aG9kcy5nZXQocHJvcCk7XG4gICAgY29uc3QgdGFyZ2V0RnVuY05hbWUgPSBwcm9wLnJlcGxhY2UoL0Zyb21JbmRleCQvLCAnJyk7XG4gICAgY29uc3QgdXNlSW5kZXggPSBwcm9wICE9PSB0YXJnZXRGdW5jTmFtZTtcbiAgICBjb25zdCBpc1dyaXRlID0gd3JpdGVNZXRob2RzLmluY2x1ZGVzKHRhcmdldEZ1bmNOYW1lKTtcbiAgICBpZiAoXG4gICAgLy8gQmFpbCBpZiB0aGUgdGFyZ2V0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHRhcmdldC4gRWcsIGdldEFsbCBpc24ndCBpbiBFZGdlLlxuICAgICEodGFyZ2V0RnVuY05hbWUgaW4gKHVzZUluZGV4ID8gSURCSW5kZXggOiBJREJPYmplY3RTdG9yZSkucHJvdG90eXBlKSB8fFxuICAgICAgICAhKGlzV3JpdGUgfHwgcmVhZE1ldGhvZHMuaW5jbHVkZXModGFyZ2V0RnVuY05hbWUpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jIGZ1bmN0aW9uIChzdG9yZU5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gaXNXcml0ZSA/ICdyZWFkd3JpdGUnIDogdW5kZWZpbmVkIGd6aXBwcyBiZXR0ZXIsIGJ1dCBmYWlscyBpbiBFZGdlIDooXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy50cmFuc2FjdGlvbihzdG9yZU5hbWUsIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6ICdyZWFkb25seScpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gdHguc3RvcmU7XG4gICAgICAgIGlmICh1c2VJbmRleClcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5pbmRleChhcmdzLnNoaWZ0KCkpO1xuICAgICAgICAvLyBNdXN0IHJlamVjdCBpZiBvcCByZWplY3RzLlxuICAgICAgICAvLyBJZiBpdCdzIGEgd3JpdGUgb3BlcmF0aW9uLCBtdXN0IHJlamVjdCBpZiB0eC5kb25lIHJlamVjdHMuXG4gICAgICAgIC8vIE11c3QgcmVqZWN0IHdpdGggb3AgcmVqZWN0aW9uIGZpcnN0LlxuICAgICAgICAvLyBNdXN0IHJlc29sdmUgd2l0aCBvcCB2YWx1ZS5cbiAgICAgICAgLy8gTXVzdCBoYW5kbGUgYm90aCBwcm9taXNlcyAobm8gdW5oYW5kbGVkIHJlamVjdGlvbnMpXG4gICAgICAgIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGFyZ2V0W3RhcmdldEZ1bmNOYW1lXSguLi5hcmdzKSxcbiAgICAgICAgICAgIGlzV3JpdGUgJiYgdHguZG9uZSxcbiAgICAgICAgXSkpWzBdO1xuICAgIH07XG4gICAgY2FjaGVkTWV0aG9kcy5zZXQocHJvcCwgbWV0aG9kKTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxucmVwbGFjZVRyYXBzKChvbGRUcmFwcykgPT4gKHtcbiAgICAuLi5vbGRUcmFwcyxcbiAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiBnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlciksXG4gICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiAhIWdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHx8IG9sZFRyYXBzLmhhcyh0YXJnZXQsIHByb3ApLFxufSkpO1xuXG5jb25zdCBhZHZhbmNlTWV0aG9kUHJvcHMgPSBbJ2NvbnRpbnVlJywgJ2NvbnRpbnVlUHJpbWFyeUtleScsICdhZHZhbmNlJ107XG5jb25zdCBtZXRob2RNYXAgPSB7fTtcbmNvbnN0IGFkdmFuY2VSZXN1bHRzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGl0dHJQcm94aWVkQ3Vyc29yVG9PcmlnaW5hbFByb3h5ID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGN1cnNvckl0ZXJhdG9yVHJhcHMgPSB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgICBpZiAoIWFkdmFuY2VNZXRob2RQcm9wcy5pbmNsdWRlcyhwcm9wKSlcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICAgIGxldCBjYWNoZWRGdW5jID0gbWV0aG9kTWFwW3Byb3BdO1xuICAgICAgICBpZiAoIWNhY2hlZEZ1bmMpIHtcbiAgICAgICAgICAgIGNhY2hlZEZ1bmMgPSBtZXRob2RNYXBbcHJvcF0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGFkdmFuY2VSZXN1bHRzLnNldCh0aGlzLCBpdHRyUHJveGllZEN1cnNvclRvT3JpZ2luYWxQcm94eS5nZXQodGhpcylbcHJvcF0oLi4uYXJncykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkRnVuYztcbiAgICB9LFxufTtcbmFzeW5jIGZ1bmN0aW9uKiBpdGVyYXRlKC4uLmFyZ3MpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdGhpcy1hc3NpZ25tZW50XG4gICAgbGV0IGN1cnNvciA9IHRoaXM7XG4gICAgaWYgKCEoY3Vyc29yIGluc3RhbmNlb2YgSURCQ3Vyc29yKSkge1xuICAgICAgICBjdXJzb3IgPSBhd2FpdCBjdXJzb3Iub3BlbkN1cnNvciguLi5hcmdzKTtcbiAgICB9XG4gICAgaWYgKCFjdXJzb3IpXG4gICAgICAgIHJldHVybjtcbiAgICBjdXJzb3IgPSBjdXJzb3I7XG4gICAgY29uc3QgcHJveGllZEN1cnNvciA9IG5ldyBQcm94eShjdXJzb3IsIGN1cnNvckl0ZXJhdG9yVHJhcHMpO1xuICAgIGl0dHJQcm94aWVkQ3Vyc29yVG9PcmlnaW5hbFByb3h5LnNldChwcm94aWVkQ3Vyc29yLCBjdXJzb3IpO1xuICAgIC8vIE1hcCB0aGlzIGRvdWJsZS1wcm94eSBiYWNrIHRvIHRoZSBvcmlnaW5hbCwgc28gb3RoZXIgY3Vyc29yIG1ldGhvZHMgd29yay5cbiAgICByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuc2V0KHByb3hpZWRDdXJzb3IsIHVud3JhcChjdXJzb3IpKTtcbiAgICB3aGlsZSAoY3Vyc29yKSB7XG4gICAgICAgIHlpZWxkIHByb3hpZWRDdXJzb3I7XG4gICAgICAgIC8vIElmIG9uZSBvZiB0aGUgYWR2YW5jaW5nIG1ldGhvZHMgd2FzIG5vdCBjYWxsZWQsIGNhbGwgY29udGludWUoKS5cbiAgICAgICAgY3Vyc29yID0gYXdhaXQgKGFkdmFuY2VSZXN1bHRzLmdldChwcm94aWVkQ3Vyc29yKSB8fCBjdXJzb3IuY29udGludWUoKSk7XG4gICAgICAgIGFkdmFuY2VSZXN1bHRzLmRlbGV0ZShwcm94aWVkQ3Vyc29yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0l0ZXJhdG9yUHJvcCh0YXJnZXQsIHByb3ApIHtcbiAgICByZXR1cm4gKChwcm9wID09PSBTeW1ib2wuYXN5bmNJdGVyYXRvciAmJlxuICAgICAgICBpbnN0YW5jZU9mQW55KHRhcmdldCwgW0lEQkluZGV4LCBJREJPYmplY3RTdG9yZSwgSURCQ3Vyc29yXSkpIHx8XG4gICAgICAgIChwcm9wID09PSAnaXRlcmF0ZScgJiYgaW5zdGFuY2VPZkFueSh0YXJnZXQsIFtJREJJbmRleCwgSURCT2JqZWN0U3RvcmVdKSkpO1xufVxucmVwbGFjZVRyYXBzKChvbGRUcmFwcykgPT4gKHtcbiAgICAuLi5vbGRUcmFwcyxcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICBpZiAoaXNJdGVyYXRvclByb3AodGFyZ2V0LCBwcm9wKSlcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRlO1xuICAgICAgICByZXR1cm4gb2xkVHJhcHMuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgICByZXR1cm4gaXNJdGVyYXRvclByb3AodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICB9LFxufSkpO1xuXG5leHBvcnQgeyBkZWxldGVEQiwgb3BlbkRCLCB1bndyYXAsIHdyYXAgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/idb/build/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/native.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLGlFQUFlO0FBQ2Y7QUFDQSxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMvamFzb25odWxiZXJ0L1Byb2plY3RzL3NwZWNnZW4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9uYXRpdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmFuZG9tVVVJRCA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21VVUlEICYmIGNyeXB0by5yYW5kb21VVUlELmJpbmQoY3J5cHRvKTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmFuZG9tVVVJRFxufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/native.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyx5Q0FBeUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNvbmh1bGJlcnQvUHJvamVjdHMvc3BlY2dlbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JlZ2V4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvamFzb25odWxiZXJ0L1Byb2plY3RzL3NwZWNnZW4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9ybmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG5sZXQgZ2V0UmFuZG9tVmFsdWVzO1xuY29uc3Qgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi5cbiAgICBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pO1xuXG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/rng.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyIvVXNlcnMvamFzb25odWxiZXJ0L1Byb2plY3RzL3NwZWNnZW4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9zdHJpbmdpZnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbmNvbnN0IGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zbGljZSgxKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICByZXR1cm4gYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV07XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgY29uc3QgdXVpZCA9IHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNOO0FBQ3NCOztBQUVqRDtBQUNBLE1BQU0sa0RBQU07QUFDWixXQUFXLGtEQUFNO0FBQ2pCOztBQUVBO0FBQ0EsaURBQWlELCtDQUFHLEtBQUs7O0FBRXpEO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLDhEQUFlO0FBQ3hCOztBQUVBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNvbmh1bGJlcnQvUHJvamVjdHMvc3BlY2dlbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBuYXRpdmUgZnJvbSAnLi9uYXRpdmUuanMnO1xuaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGlmIChuYXRpdmUucmFuZG9tVVVJRCAmJiAhYnVmICYmICFvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5hdGl2ZS5yYW5kb21VVUlEKCk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiB1bnNhZmVTdHJpbmdpZnkocm5kcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHY0OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7O0FBRS9CO0FBQ0EscUNBQXFDLGlEQUFLO0FBQzFDOztBQUVBLGlFQUFlLFFBQVEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNvbmh1bGJlcnQvUHJvamVjdHMvc3BlY2dlbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/validate.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/database.ts":
/*!*****************************!*\
  !*** ./src/lib/database.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DatabaseService: () => (/* binding */ DatabaseService),\n/* harmony export */   getDBService: () => (/* binding */ getDBService),\n/* harmony export */   initDB: () => (/* binding */ initDB)\n/* harmony export */ });\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! idb */ \"(app-pages-browser)/./node_modules/idb/build/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n\n\nconst DB_NAME = 'specgen';\nconst DB_VERSION = 1;\n// Database instance\nlet dbInstance = null;\n// Initialize database\nasync function initDB() {\n    if (dbInstance) return dbInstance;\n    dbInstance = await (0,idb__WEBPACK_IMPORTED_MODULE_0__.openDB)(DB_NAME, DB_VERSION, {\n        upgrade (db) {\n            // Projects store\n            const projectStore = db.createObjectStore('projects', {\n                keyPath: 'id'\n            });\n            projectStore.createIndex('by-created', 'created_at');\n            // Project contexts store\n            const contextStore = db.createObjectStore('project_contexts', {\n                keyPath: 'id'\n            });\n            contextStore.createIndex('by-project-active', [\n                'project_id',\n                'is_active'\n            ]);\n            contextStore.createIndex('by-project-created', [\n                'project_id',\n                'created_at'\n            ]);\n            // Project context diffs store\n            const diffStore = db.createObjectStore('project_context_diffs', {\n                keyPath: 'id'\n            });\n            diffStore.createIndex('by-context', 'project_context_id');\n            // Spec inputs store\n            const inputStore = db.createObjectStore('spec_inputs', {\n                keyPath: 'id'\n            });\n            inputStore.createIndex('by-project-created', [\n                'project_id',\n                'created_at'\n            ]);\n            // Spec outputs store\n            const outputStore = db.createObjectStore('spec_outputs', {\n                keyPath: 'id'\n            });\n            outputStore.createIndex('by-input', 'input_id');\n            outputStore.createIndex('by-created', 'created_at');\n            // Spec revisions store\n            const revisionStore = db.createObjectStore('spec_revisions', {\n                keyPath: 'id'\n            });\n            revisionStore.createIndex('by-output', 'output_id');\n            // Spec evaluations store\n            const evalStore = db.createObjectStore('spec_evaluations', {\n                keyPath: 'id'\n            });\n            evalStore.createIndex('by-output', 'output_id');\n        }\n    });\n    return dbInstance;\n}\n// Database operations\nclass DatabaseService {\n    // Projects\n    async createProject(data) {\n        const project = {\n            ...data,\n            id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n            created_at: new Date()\n        };\n        await this.db.add('projects', project);\n        return project;\n    }\n    async getProject(id) {\n        return this.db.get('projects', id);\n    }\n    async getProjects() {\n        return this.db.getAllFromIndex('projects', 'by-created');\n    }\n    async updateProject(id, updates) {\n        const project = await this.getProject(id);\n        if (!project) throw new Error('Project not found');\n        const updated = {\n            ...project,\n            ...updates\n        };\n        await this.db.put('projects', updated);\n    }\n    // Project Contexts\n    async createProjectContext(data) {\n        const context = {\n            ...data,\n            id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n            created_at: new Date()\n        };\n        // If this is active, deactivate others\n        if (context.is_active) {\n            await this.deactivateProjectContexts(context.project_id);\n        }\n        await this.db.add('project_contexts', context);\n        return context;\n    }\n    async getActiveProjectContext(projectId) {\n        const contexts = await this.db.getAllFromIndex('project_contexts', 'by-project-active', [\n            projectId,\n            1\n        ]);\n        return contexts[0];\n    }\n    async getProjectContexts(projectId) {\n        return this.db.getAllFromIndex('project_contexts', 'by-project-created', [\n            projectId\n        ]);\n    }\n    async activateProjectContext(contextId) {\n        const context = await this.db.get('project_contexts', contextId);\n        if (!context) throw new Error('Context not found');\n        // Deactivate others\n        await this.deactivateProjectContexts(context.project_id);\n        // Activate this one\n        context.is_active = 1;\n        await this.db.put('project_contexts', context);\n    }\n    async deactivateProjectContexts(projectId) {\n        const activeContexts = await this.db.getAllFromIndex('project_contexts', 'by-project-active', [\n            projectId,\n            1\n        ]);\n        for (const context of activeContexts){\n            context.is_active = 0;\n            await this.db.put('project_contexts', context);\n        }\n    }\n    // Spec Inputs\n    async createSpecInput(data) {\n        const input = {\n            ...data,\n            id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n            created_at: new Date()\n        };\n        await this.db.add('spec_inputs', input);\n        return input;\n    }\n    async getSpecInput(id) {\n        return this.db.get('spec_inputs', id);\n    }\n    async getSpecInputsByProject(projectId) {\n        return this.db.getAllFromIndex('spec_inputs', 'by-project-created', [\n            projectId\n        ]);\n    }\n    // Spec Outputs\n    async createSpecOutput(data) {\n        const output = {\n            ...data,\n            id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n            created_at: new Date()\n        };\n        await this.db.add('spec_outputs', output);\n        return output;\n    }\n    async getSpecOutput(id) {\n        return this.db.get('spec_outputs', id);\n    }\n    async getSpecOutputByInput(inputId) {\n        const outputs = await this.db.getAllFromIndex('spec_outputs', 'by-input', inputId);\n        return outputs[0] // Return latest\n        ;\n    }\n    async getRecentSpecOutputs() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;\n        const outputs = await this.db.getAllFromIndex('spec_outputs', 'by-created');\n        return outputs.slice(-limit).reverse();\n    }\n    // Spec Evaluations\n    async createSpecEvaluation(data) {\n        const evaluation = {\n            ...data,\n            id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n            created_at: new Date()\n        };\n        await this.db.add('spec_evaluations', evaluation);\n        return evaluation;\n    }\n    async getSpecEvaluation(outputId) {\n        const evaluations = await this.db.getAllFromIndex('spec_evaluations', 'by-output', outputId);\n        return evaluations[0];\n    }\n    constructor(db){\n        this.db = db;\n    }\n}\n// Global database service instance\nlet dbService = null;\nasync function getDBService() {\n    if (!dbService) {\n        const db = await initDB();\n        dbService = new DatabaseService(db);\n    }\n    return dbService;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OEQ7WUFBekNDLFFBQUFBLGlFQUFRO1FBQ2pDLE1BQU1GLFVBQVUsTUFBTSxJQUFJLENBQUNqRCxFQUFFLENBQUNzQixlQUFlLENBQUMsZ0JBQWdCO1FBQzlELE9BQU8yQixRQUFRRyxLQUFLLENBQUMsQ0FBQ0QsT0FBT0UsT0FBTztJQUN0QztJQUVBLG1CQUFtQjtJQUNuQixNQUFNQyxxQkFBcUJ6QyxJQUErQyxFQUEyQjtRQUNuRyxNQUFNMEMsYUFBNkI7WUFDakMsR0FBRzFDLElBQUk7WUFDUEUsSUFBSXJCLGdEQUFNQTtZQUNWc0IsWUFBWSxJQUFJQztRQUNsQjtRQUNBLE1BQU0sSUFBSSxDQUFDakIsRUFBRSxDQUFDa0IsR0FBRyxDQUFDLG9CQUFvQnFDO1FBQ3RDLE9BQU9BO0lBQ1Q7SUFFQSxNQUFNQyxrQkFBa0JDLFFBQWdCLEVBQXVDO1FBQzdFLE1BQU1DLGNBQWMsTUFBTSxJQUFJLENBQUMxRCxFQUFFLENBQUNzQixlQUFlLENBQUMsb0JBQW9CLGFBQWFtQztRQUNuRixPQUFPQyxXQUFXLENBQUMsRUFBRTtJQUN2QjtJQXhJQSxZQUFZMUQsRUFBMkIsQ0FBRTtRQUN2QyxJQUFJLENBQUNBLEVBQUUsR0FBR0E7SUFDWjtBQXVJRjtBQUVBLG1DQUFtQztBQUNuQyxJQUFJMkQsWUFBb0M7QUFFakMsZUFBZUM7SUFDcEIsSUFBSSxDQUFDRCxXQUFXO1FBQ2QsTUFBTTNELEtBQUssTUFBTUY7UUFDakI2RCxZQUFZLElBQUloRCxnQkFBZ0JYO0lBQ2xDO0lBQ0EsT0FBTzJEO0FBQ1QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNvbmh1bGJlcnQvUHJvamVjdHMvc3BlY2dlbi9zcmMvbGliL2RhdGFiYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG9wZW5EQiwgSURCUERhdGFiYXNlIH0gZnJvbSAnaWRiJ1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCdcbmltcG9ydCB7XG4gIFByb2plY3QsXG4gIFByb2plY3RDb250ZXh0LFxuICBQcm9qZWN0Q29udGV4dERpZmYsXG4gIFNwZWNJbnB1dFJlY29yZCxcbiAgU3BlY091dHB1dFJlY29yZCxcbiAgU3BlY1JldmlzaW9uLFxuICBTcGVjRXZhbHVhdGlvbixcbn0gZnJvbSAnQC90eXBlcy9kYXRhYmFzZSdcblxuY29uc3QgREJfTkFNRSA9ICdzcGVjZ2VuJ1xuY29uc3QgREJfVkVSU0lPTiA9IDFcblxuLy8gRGF0YWJhc2UgaW50ZXJmYWNlXG5pbnRlcmZhY2UgU3BlY0dlbkRCIHtcbiAgcHJvamVjdHM6IHtcbiAgICBrZXk6IHN0cmluZ1xuICAgIHZhbHVlOiBQcm9qZWN0XG4gICAgaW5kZXhlczogeyAnYnktY3JlYXRlZCc6IERhdGUgfVxuICB9XG4gIHByb2plY3RfY29udGV4dHM6IHtcbiAgICBrZXk6IHN0cmluZ1xuICAgIHZhbHVlOiBQcm9qZWN0Q29udGV4dFxuICAgIGluZGV4ZXM6IHsgJ2J5LXByb2plY3QtYWN0aXZlJzogW3N0cmluZywgbnVtYmVyXTsgJ2J5LXByb2plY3QtY3JlYXRlZCc6IFtzdHJpbmcsIERhdGVdIH1cbiAgfVxuICBwcm9qZWN0X2NvbnRleHRfZGlmZnM6IHtcbiAgICBrZXk6IHN0cmluZ1xuICAgIHZhbHVlOiBQcm9qZWN0Q29udGV4dERpZmZcbiAgICBpbmRleGVzOiB7ICdieS1jb250ZXh0Jzogc3RyaW5nIH1cbiAgfVxuICBzcGVjX2lucHV0czoge1xuICAgIGtleTogc3RyaW5nXG4gICAgdmFsdWU6IFNwZWNJbnB1dFJlY29yZFxuICAgIGluZGV4ZXM6IHsgJ2J5LXByb2plY3QtY3JlYXRlZCc6IFtzdHJpbmcsIERhdGVdIH1cbiAgfVxuICBzcGVjX291dHB1dHM6IHtcbiAgICBrZXk6IHN0cmluZ1xuICAgIHZhbHVlOiBTcGVjT3V0cHV0UmVjb3JkXG4gICAgaW5kZXhlczogeyAnYnktaW5wdXQnOiBzdHJpbmc7ICdieS1jcmVhdGVkJzogRGF0ZSB9XG4gIH1cbiAgc3BlY19yZXZpc2lvbnM6IHtcbiAgICBrZXk6IHN0cmluZ1xuICAgIHZhbHVlOiBTcGVjUmV2aXNpb25cbiAgICBpbmRleGVzOiB7ICdieS1vdXRwdXQnOiBzdHJpbmcgfVxuICB9XG4gIHNwZWNfZXZhbHVhdGlvbnM6IHtcbiAgICBrZXk6IHN0cmluZ1xuICAgIHZhbHVlOiBTcGVjRXZhbHVhdGlvblxuICAgIGluZGV4ZXM6IHsgJ2J5LW91dHB1dCc6IHN0cmluZyB9XG4gIH1cbn1cblxuLy8gRGF0YWJhc2UgaW5zdGFuY2VcbmxldCBkYkluc3RhbmNlOiBJREJQRGF0YWJhc2U8U3BlY0dlbkRCPiB8IG51bGwgPSBudWxsXG5cbi8vIEluaXRpYWxpemUgZGF0YWJhc2VcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0REIoKTogUHJvbWlzZTxJREJQRGF0YWJhc2U8U3BlY0dlbkRCPj4ge1xuICBpZiAoZGJJbnN0YW5jZSkgcmV0dXJuIGRiSW5zdGFuY2VcblxuICBkYkluc3RhbmNlID0gYXdhaXQgb3BlbkRCPFNwZWNHZW5EQj4oREJfTkFNRSwgREJfVkVSU0lPTiwge1xuICAgIHVwZ3JhZGUoZGIpIHtcbiAgICAgIC8vIFByb2plY3RzIHN0b3JlXG4gICAgICBjb25zdCBwcm9qZWN0U3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZSgncHJvamVjdHMnLCB7IGtleVBhdGg6ICdpZCcgfSlcbiAgICAgIHByb2plY3RTdG9yZS5jcmVhdGVJbmRleCgnYnktY3JlYXRlZCcsICdjcmVhdGVkX2F0JylcblxuICAgICAgLy8gUHJvamVjdCBjb250ZXh0cyBzdG9yZVxuICAgICAgY29uc3QgY29udGV4dFN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ3Byb2plY3RfY29udGV4dHMnLCB7IGtleVBhdGg6ICdpZCcgfSlcbiAgICAgIGNvbnRleHRTdG9yZS5jcmVhdGVJbmRleCgnYnktcHJvamVjdC1hY3RpdmUnLCBbJ3Byb2plY3RfaWQnLCAnaXNfYWN0aXZlJ10pXG4gICAgICBjb250ZXh0U3RvcmUuY3JlYXRlSW5kZXgoJ2J5LXByb2plY3QtY3JlYXRlZCcsIFsncHJvamVjdF9pZCcsICdjcmVhdGVkX2F0J10pXG5cbiAgICAgIC8vIFByb2plY3QgY29udGV4dCBkaWZmcyBzdG9yZVxuICAgICAgY29uc3QgZGlmZlN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ3Byb2plY3RfY29udGV4dF9kaWZmcycsIHsga2V5UGF0aDogJ2lkJyB9KVxuICAgICAgZGlmZlN0b3JlLmNyZWF0ZUluZGV4KCdieS1jb250ZXh0JywgJ3Byb2plY3RfY29udGV4dF9pZCcpXG5cbiAgICAgIC8vIFNwZWMgaW5wdXRzIHN0b3JlXG4gICAgICBjb25zdCBpbnB1dFN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ3NwZWNfaW5wdXRzJywgeyBrZXlQYXRoOiAnaWQnIH0pXG4gICAgICBpbnB1dFN0b3JlLmNyZWF0ZUluZGV4KCdieS1wcm9qZWN0LWNyZWF0ZWQnLCBbJ3Byb2plY3RfaWQnLCAnY3JlYXRlZF9hdCddKVxuXG4gICAgICAvLyBTcGVjIG91dHB1dHMgc3RvcmVcbiAgICAgIGNvbnN0IG91dHB1dFN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ3NwZWNfb3V0cHV0cycsIHsga2V5UGF0aDogJ2lkJyB9KVxuICAgICAgb3V0cHV0U3RvcmUuY3JlYXRlSW5kZXgoJ2J5LWlucHV0JywgJ2lucHV0X2lkJylcbiAgICAgIG91dHB1dFN0b3JlLmNyZWF0ZUluZGV4KCdieS1jcmVhdGVkJywgJ2NyZWF0ZWRfYXQnKVxuXG4gICAgICAvLyBTcGVjIHJldmlzaW9ucyBzdG9yZVxuICAgICAgY29uc3QgcmV2aXNpb25TdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdzcGVjX3JldmlzaW9ucycsIHsga2V5UGF0aDogJ2lkJyB9KVxuICAgICAgcmV2aXNpb25TdG9yZS5jcmVhdGVJbmRleCgnYnktb3V0cHV0JywgJ291dHB1dF9pZCcpXG5cbiAgICAgIC8vIFNwZWMgZXZhbHVhdGlvbnMgc3RvcmVcbiAgICAgIGNvbnN0IGV2YWxTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdzcGVjX2V2YWx1YXRpb25zJywgeyBrZXlQYXRoOiAnaWQnIH0pXG4gICAgICBldmFsU3RvcmUuY3JlYXRlSW5kZXgoJ2J5LW91dHB1dCcsICdvdXRwdXRfaWQnKVxuICAgIH0sXG4gIH0pXG5cbiAgcmV0dXJuIGRiSW5zdGFuY2Vcbn1cblxuLy8gRGF0YWJhc2Ugb3BlcmF0aW9uc1xuZXhwb3J0IGNsYXNzIERhdGFiYXNlU2VydmljZSB7XG4gIHByaXZhdGUgZGI6IElEQlBEYXRhYmFzZTxTcGVjR2VuREI+XG5cbiAgY29uc3RydWN0b3IoZGI6IElEQlBEYXRhYmFzZTxTcGVjR2VuREI+KSB7XG4gICAgdGhpcy5kYiA9IGRiXG4gIH1cblxuICAvLyBQcm9qZWN0c1xuICBhc3luYyBjcmVhdGVQcm9qZWN0KGRhdGE6IE9taXQ8UHJvamVjdCwgJ2lkJyB8ICdjcmVhdGVkX2F0Jz4pOiBQcm9taXNlPFByb2plY3Q+IHtcbiAgICBjb25zdCBwcm9qZWN0OiBQcm9qZWN0ID0ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGlkOiB1dWlkdjQoKSxcbiAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCksXG4gICAgfVxuICAgIGF3YWl0IHRoaXMuZGIuYWRkKCdwcm9qZWN0cycsIHByb2plY3QpXG4gICAgcmV0dXJuIHByb2plY3RcbiAgfVxuXG4gIGFzeW5jIGdldFByb2plY3QoaWQ6IHN0cmluZyk6IFByb21pc2U8UHJvamVjdCB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiB0aGlzLmRiLmdldCgncHJvamVjdHMnLCBpZClcbiAgfVxuXG4gIGFzeW5jIGdldFByb2plY3RzKCk6IFByb21pc2U8UHJvamVjdFtdPiB7XG4gICAgcmV0dXJuIHRoaXMuZGIuZ2V0QWxsRnJvbUluZGV4KCdwcm9qZWN0cycsICdieS1jcmVhdGVkJylcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVByb2plY3QoaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxQcm9qZWN0Pik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHByb2plY3QgPSBhd2FpdCB0aGlzLmdldFByb2plY3QoaWQpXG4gICAgaWYgKCFwcm9qZWN0KSB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3Qgbm90IGZvdW5kJylcbiAgICBcbiAgICBjb25zdCB1cGRhdGVkID0geyAuLi5wcm9qZWN0LCAuLi51cGRhdGVzIH1cbiAgICBhd2FpdCB0aGlzLmRiLnB1dCgncHJvamVjdHMnLCB1cGRhdGVkKVxuICB9XG5cbiAgLy8gUHJvamVjdCBDb250ZXh0c1xuICBhc3luYyBjcmVhdGVQcm9qZWN0Q29udGV4dChkYXRhOiBPbWl0PFByb2plY3RDb250ZXh0LCAnaWQnIHwgJ2NyZWF0ZWRfYXQnPik6IFByb21pc2U8UHJvamVjdENvbnRleHQ+IHtcbiAgICBjb25zdCBjb250ZXh0OiBQcm9qZWN0Q29udGV4dCA9IHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBpZDogdXVpZHY0KCksXG4gICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLFxuICAgIH1cbiAgICBcbiAgICAvLyBJZiB0aGlzIGlzIGFjdGl2ZSwgZGVhY3RpdmF0ZSBvdGhlcnNcbiAgICBpZiAoY29udGV4dC5pc19hY3RpdmUpIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVhY3RpdmF0ZVByb2plY3RDb250ZXh0cyhjb250ZXh0LnByb2plY3RfaWQpXG4gICAgfVxuICAgIFxuICAgIGF3YWl0IHRoaXMuZGIuYWRkKCdwcm9qZWN0X2NvbnRleHRzJywgY29udGV4dClcbiAgICByZXR1cm4gY29udGV4dFxuICB9XG5cbiAgYXN5bmMgZ2V0QWN0aXZlUHJvamVjdENvbnRleHQocHJvamVjdElkOiBzdHJpbmcpOiBQcm9taXNlPFByb2plY3RDb250ZXh0IHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgY29udGV4dHMgPSBhd2FpdCB0aGlzLmRiLmdldEFsbEZyb21JbmRleCgncHJvamVjdF9jb250ZXh0cycsICdieS1wcm9qZWN0LWFjdGl2ZScsIFtwcm9qZWN0SWQsIDFdKVxuICAgIHJldHVybiBjb250ZXh0c1swXVxuICB9XG5cbiAgYXN5bmMgZ2V0UHJvamVjdENvbnRleHRzKHByb2plY3RJZDogc3RyaW5nKTogUHJvbWlzZTxQcm9qZWN0Q29udGV4dFtdPiB7XG4gICAgcmV0dXJuIHRoaXMuZGIuZ2V0QWxsRnJvbUluZGV4KCdwcm9qZWN0X2NvbnRleHRzJywgJ2J5LXByb2plY3QtY3JlYXRlZCcsIFtwcm9qZWN0SWRdKVxuICB9XG5cbiAgYXN5bmMgYWN0aXZhdGVQcm9qZWN0Q29udGV4dChjb250ZXh0SWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCB0aGlzLmRiLmdldCgncHJvamVjdF9jb250ZXh0cycsIGNvbnRleHRJZClcbiAgICBpZiAoIWNvbnRleHQpIHRocm93IG5ldyBFcnJvcignQ29udGV4dCBub3QgZm91bmQnKVxuICAgIFxuICAgIC8vIERlYWN0aXZhdGUgb3RoZXJzXG4gICAgYXdhaXQgdGhpcy5kZWFjdGl2YXRlUHJvamVjdENvbnRleHRzKGNvbnRleHQucHJvamVjdF9pZClcbiAgICBcbiAgICAvLyBBY3RpdmF0ZSB0aGlzIG9uZVxuICAgIGNvbnRleHQuaXNfYWN0aXZlID0gMVxuICAgIGF3YWl0IHRoaXMuZGIucHV0KCdwcm9qZWN0X2NvbnRleHRzJywgY29udGV4dClcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZGVhY3RpdmF0ZVByb2plY3RDb250ZXh0cyhwcm9qZWN0SWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGFjdGl2ZUNvbnRleHRzID0gYXdhaXQgdGhpcy5kYi5nZXRBbGxGcm9tSW5kZXgoJ3Byb2plY3RfY29udGV4dHMnLCAnYnktcHJvamVjdC1hY3RpdmUnLCBbcHJvamVjdElkLCAxXSlcbiAgICBcbiAgICBmb3IgKGNvbnN0IGNvbnRleHQgb2YgYWN0aXZlQ29udGV4dHMpIHtcbiAgICAgIGNvbnRleHQuaXNfYWN0aXZlID0gMFxuICAgICAgYXdhaXQgdGhpcy5kYi5wdXQoJ3Byb2plY3RfY29udGV4dHMnLCBjb250ZXh0KVxuICAgIH1cbiAgfVxuXG4gIC8vIFNwZWMgSW5wdXRzXG4gIGFzeW5jIGNyZWF0ZVNwZWNJbnB1dChkYXRhOiBPbWl0PFNwZWNJbnB1dFJlY29yZCwgJ2lkJyB8ICdjcmVhdGVkX2F0Jz4pOiBQcm9taXNlPFNwZWNJbnB1dFJlY29yZD4ge1xuICAgIGNvbnN0IGlucHV0OiBTcGVjSW5wdXRSZWNvcmQgPSB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgaWQ6IHV1aWR2NCgpLFxuICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKSxcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5kYi5hZGQoJ3NwZWNfaW5wdXRzJywgaW5wdXQpXG4gICAgcmV0dXJuIGlucHV0XG4gIH1cblxuICBhc3luYyBnZXRTcGVjSW5wdXQoaWQ6IHN0cmluZyk6IFByb21pc2U8U3BlY0lucHV0UmVjb3JkIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIHRoaXMuZGIuZ2V0KCdzcGVjX2lucHV0cycsIGlkKVxuICB9XG5cbiAgYXN5bmMgZ2V0U3BlY0lucHV0c0J5UHJvamVjdChwcm9qZWN0SWQ6IHN0cmluZyk6IFByb21pc2U8U3BlY0lucHV0UmVjb3JkW10+IHtcbiAgICByZXR1cm4gdGhpcy5kYi5nZXRBbGxGcm9tSW5kZXgoJ3NwZWNfaW5wdXRzJywgJ2J5LXByb2plY3QtY3JlYXRlZCcsIFtwcm9qZWN0SWRdKVxuICB9XG5cbiAgLy8gU3BlYyBPdXRwdXRzXG4gIGFzeW5jIGNyZWF0ZVNwZWNPdXRwdXQoZGF0YTogT21pdDxTcGVjT3V0cHV0UmVjb3JkLCAnaWQnIHwgJ2NyZWF0ZWRfYXQnPik6IFByb21pc2U8U3BlY091dHB1dFJlY29yZD4ge1xuICAgIGNvbnN0IG91dHB1dDogU3BlY091dHB1dFJlY29yZCA9IHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBpZDogdXVpZHY0KCksXG4gICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLFxuICAgIH1cbiAgICBhd2FpdCB0aGlzLmRiLmFkZCgnc3BlY19vdXRwdXRzJywgb3V0cHV0KVxuICAgIHJldHVybiBvdXRwdXRcbiAgfVxuXG4gIGFzeW5jIGdldFNwZWNPdXRwdXQoaWQ6IHN0cmluZyk6IFByb21pc2U8U3BlY091dHB1dFJlY29yZCB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiB0aGlzLmRiLmdldCgnc3BlY19vdXRwdXRzJywgaWQpXG4gIH1cblxuICBhc3luYyBnZXRTcGVjT3V0cHV0QnlJbnB1dChpbnB1dElkOiBzdHJpbmcpOiBQcm9taXNlPFNwZWNPdXRwdXRSZWNvcmQgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBvdXRwdXRzID0gYXdhaXQgdGhpcy5kYi5nZXRBbGxGcm9tSW5kZXgoJ3NwZWNfb3V0cHV0cycsICdieS1pbnB1dCcsIGlucHV0SWQpXG4gICAgcmV0dXJuIG91dHB1dHNbMF0gLy8gUmV0dXJuIGxhdGVzdFxuICB9XG5cbiAgYXN5bmMgZ2V0UmVjZW50U3BlY091dHB1dHMobGltaXQgPSAxMCk6IFByb21pc2U8U3BlY091dHB1dFJlY29yZFtdPiB7XG4gICAgY29uc3Qgb3V0cHV0cyA9IGF3YWl0IHRoaXMuZGIuZ2V0QWxsRnJvbUluZGV4KCdzcGVjX291dHB1dHMnLCAnYnktY3JlYXRlZCcpXG4gICAgcmV0dXJuIG91dHB1dHMuc2xpY2UoLWxpbWl0KS5yZXZlcnNlKClcbiAgfVxuXG4gIC8vIFNwZWMgRXZhbHVhdGlvbnNcbiAgYXN5bmMgY3JlYXRlU3BlY0V2YWx1YXRpb24oZGF0YTogT21pdDxTcGVjRXZhbHVhdGlvbiwgJ2lkJyB8ICdjcmVhdGVkX2F0Jz4pOiBQcm9taXNlPFNwZWNFdmFsdWF0aW9uPiB7XG4gICAgY29uc3QgZXZhbHVhdGlvbjogU3BlY0V2YWx1YXRpb24gPSB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgaWQ6IHV1aWR2NCgpLFxuICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKSxcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5kYi5hZGQoJ3NwZWNfZXZhbHVhdGlvbnMnLCBldmFsdWF0aW9uKVxuICAgIHJldHVybiBldmFsdWF0aW9uXG4gIH1cblxuICBhc3luYyBnZXRTcGVjRXZhbHVhdGlvbihvdXRwdXRJZDogc3RyaW5nKTogUHJvbWlzZTxTcGVjRXZhbHVhdGlvbiB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IGV2YWx1YXRpb25zID0gYXdhaXQgdGhpcy5kYi5nZXRBbGxGcm9tSW5kZXgoJ3NwZWNfZXZhbHVhdGlvbnMnLCAnYnktb3V0cHV0Jywgb3V0cHV0SWQpXG4gICAgcmV0dXJuIGV2YWx1YXRpb25zWzBdXG4gIH1cbn1cblxuLy8gR2xvYmFsIGRhdGFiYXNlIHNlcnZpY2UgaW5zdGFuY2VcbmxldCBkYlNlcnZpY2U6IERhdGFiYXNlU2VydmljZSB8IG51bGwgPSBudWxsXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREQlNlcnZpY2UoKTogUHJvbWlzZTxEYXRhYmFzZVNlcnZpY2U+IHtcbiAgaWYgKCFkYlNlcnZpY2UpIHtcbiAgICBjb25zdCBkYiA9IGF3YWl0IGluaXREQigpXG4gICAgZGJTZXJ2aWNlID0gbmV3IERhdGFiYXNlU2VydmljZShkYilcbiAgfVxuICByZXR1cm4gZGJTZXJ2aWNlXG59Il0sIm5hbWVzIjpbIm9wZW5EQiIsInY0IiwidXVpZHY0IiwiREJfTkFNRSIsIkRCX1ZFUlNJT04iLCJkYkluc3RhbmNlIiwiaW5pdERCIiwidXBncmFkZSIsImRiIiwicHJvamVjdFN0b3JlIiwiY3JlYXRlT2JqZWN0U3RvcmUiLCJrZXlQYXRoIiwiY3JlYXRlSW5kZXgiLCJjb250ZXh0U3RvcmUiLCJkaWZmU3RvcmUiLCJpbnB1dFN0b3JlIiwib3V0cHV0U3RvcmUiLCJyZXZpc2lvblN0b3JlIiwiZXZhbFN0b3JlIiwiRGF0YWJhc2VTZXJ2aWNlIiwiY3JlYXRlUHJvamVjdCIsImRhdGEiLCJwcm9qZWN0IiwiaWQiLCJjcmVhdGVkX2F0IiwiRGF0ZSIsImFkZCIsImdldFByb2plY3QiLCJnZXQiLCJnZXRQcm9qZWN0cyIsImdldEFsbEZyb21JbmRleCIsInVwZGF0ZVByb2plY3QiLCJ1cGRhdGVzIiwiRXJyb3IiLCJ1cGRhdGVkIiwicHV0IiwiY3JlYXRlUHJvamVjdENvbnRleHQiLCJjb250ZXh0IiwiaXNfYWN0aXZlIiwiZGVhY3RpdmF0ZVByb2plY3RDb250ZXh0cyIsInByb2plY3RfaWQiLCJnZXRBY3RpdmVQcm9qZWN0Q29udGV4dCIsInByb2plY3RJZCIsImNvbnRleHRzIiwiZ2V0UHJvamVjdENvbnRleHRzIiwiYWN0aXZhdGVQcm9qZWN0Q29udGV4dCIsImNvbnRleHRJZCIsImFjdGl2ZUNvbnRleHRzIiwiY3JlYXRlU3BlY0lucHV0IiwiaW5wdXQiLCJnZXRTcGVjSW5wdXQiLCJnZXRTcGVjSW5wdXRzQnlQcm9qZWN0IiwiY3JlYXRlU3BlY091dHB1dCIsIm91dHB1dCIsImdldFNwZWNPdXRwdXQiLCJnZXRTcGVjT3V0cHV0QnlJbnB1dCIsImlucHV0SWQiLCJvdXRwdXRzIiwiZ2V0UmVjZW50U3BlY091dHB1dHMiLCJsaW1pdCIsInNsaWNlIiwicmV2ZXJzZSIsImNyZWF0ZVNwZWNFdmFsdWF0aW9uIiwiZXZhbHVhdGlvbiIsImdldFNwZWNFdmFsdWF0aW9uIiwib3V0cHV0SWQiLCJldmFsdWF0aW9ucyIsImRiU2VydmljZSIsImdldERCU2VydmljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/database.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/projectContext.ts":
/*!***********************************!*\
  !*** ./src/lib/projectContext.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_PROJECT_CONTEXT: () => (/* binding */ DEFAULT_PROJECT_CONTEXT),\n/* harmony export */   ProjectContextService: () => (/* binding */ ProjectContextService),\n/* harmony export */   projectContextService: () => (/* binding */ projectContextService)\n/* harmony export */ });\n/* harmony import */ var _lib_database__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/database */ \"(app-pages-browser)/./src/lib/database.ts\");\n\n// Deep merge utility for context merging\nfunction deepMerge(target, source) {\n    const result = {\n        ...target\n    };\n    for(const key in source){\n        if (source[key] !== undefined) {\n            if (Array.isArray(source[key])) {\n                result[key] = source[key];\n            } else if (typeof source[key] === 'object' && source[key] !== null && !Array.isArray(source[key])) {\n                result[key] = deepMerge(result[key] || {}, source[key]);\n            } else {\n                result[key] = source[key];\n            }\n        }\n    }\n    return result;\n}\n// Context difference calculation\nfunction calculateDiff(previous, current) {\n    const diff = {};\n    // Simple field-by-field comparison\n    for(const key in current){\n        if (JSON.stringify(previous[key]) !== JSON.stringify(current[key])) {\n            diff[key] = {\n                previous: previous[key],\n                current: current[key]\n            };\n        }\n    }\n    return diff;\n}\n// Default context template\nconst DEFAULT_PROJECT_CONTEXT = {\n    glossary: {},\n    stakeholders: [],\n    constraints: [],\n    non_functional: [],\n    api_catalog: [],\n    data_models: [],\n    envs: [\n        'local',\n        'dev',\n        'test',\n        'prod'\n    ],\n    labels: {}\n};\n// Context merging service\nclass ProjectContextService {\n    // Resolve final context by merging project defaults with feature overrides\n    async resolveContext(projectId, featureContext) {\n        var _featureContext_stakeholders, _featureContext_constraints, _featureContext_non_functional;\n        const dbService = await (0,_lib_database__WEBPACK_IMPORTED_MODULE_0__.getDBService)();\n        // Get active project context (defaults)\n        const activeContext = await dbService.getActiveProjectContext(projectId);\n        const projectDefaults = (activeContext === null || activeContext === void 0 ? void 0 : activeContext.context_json) || DEFAULT_PROJECT_CONTEXT;\n        // If no feature context or inherit_from_project is false, return project defaults\n        if (!featureContext || !featureContext.inherit_from_project) {\n            return projectDefaults;\n        }\n        // Merge project defaults with feature overrides\n        let resolvedContext = {\n            ...projectDefaults\n        };\n        // Apply feature-level context fields\n        if ((_featureContext_stakeholders = featureContext.stakeholders) === null || _featureContext_stakeholders === void 0 ? void 0 : _featureContext_stakeholders.length) {\n            const existingStakeholders = resolvedContext.stakeholders.map((s)=>s.name);\n            const newStakeholderNames = featureContext.stakeholders.filter((name)=>!existingStakeholders.includes(name));\n            // Add new stakeholders with basic info\n            const newStakeholders = newStakeholderNames.map((name)=>({\n                    name,\n                    role: 'Stakeholder',\n                    interests: []\n                }));\n            resolvedContext.stakeholders = [\n                ...resolvedContext.stakeholders,\n                ...newStakeholders\n            ];\n        }\n        if ((_featureContext_constraints = featureContext.constraints) === null || _featureContext_constraints === void 0 ? void 0 : _featureContext_constraints.length) {\n            const uniqueConstraints = new Set([\n                ...resolvedContext.constraints,\n                ...featureContext.constraints\n            ]);\n            resolvedContext.constraints = Array.from(uniqueConstraints);\n        }\n        if ((_featureContext_non_functional = featureContext.non_functional) === null || _featureContext_non_functional === void 0 ? void 0 : _featureContext_non_functional.length) {\n            const uniqueNonFunctional = new Set([\n                ...resolvedContext.non_functional,\n                ...featureContext.non_functional\n            ]);\n            resolvedContext.non_functional = Array.from(uniqueNonFunctional);\n        }\n        // Apply explicit overrides (feature overrides always win)\n        if (featureContext.overrides) {\n            resolvedContext = deepMerge(resolvedContext, featureContext.overrides);\n        }\n        return resolvedContext;\n    }\n    // Create a new project context version\n    async createProjectContext(projectId, context) {\n        let isActive = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        const dbService = await (0,_lib_database__WEBPACK_IMPORTED_MODULE_0__.getDBService)();\n        // Get current version number\n        const existingContexts = await dbService.getProjectContexts(projectId);\n        const nextVersion = existingContexts.length > 0 ? Math.max(...existingContexts.map((c)=>c.version)) + 1 : 1;\n        // Create new context\n        const newContext = await dbService.createProjectContext({\n            project_id: projectId,\n            context_json: context,\n            version: nextVersion,\n            is_active: isActive ? 1 : 0\n        });\n        // Create diff if there's a previous version\n        if (existingContexts.length > 0) {\n            const previousContext = existingContexts[existingContexts.length - 1];\n            const diff = calculateDiff(previousContext.context_json, context);\n            if (Object.keys(diff).length > 0) {\n            // Store the diff (if needed for history tracking)\n            // await dbService.createProjectContextDiff(...) \n            }\n        }\n        return newContext;\n    }\n    // Update and version a project context\n    async updateProjectContext(projectId, updates) {\n        let createNewVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        const dbService = await (0,_lib_database__WEBPACK_IMPORTED_MODULE_0__.getDBService)();\n        // Get current active context\n        const activeContext = await dbService.getActiveProjectContext(projectId);\n        if (!activeContext) {\n            throw new Error('No active context found for project');\n        }\n        // Merge updates\n        const updatedContext = deepMerge(activeContext.context_json, updates);\n        if (createNewVersion) {\n            // Create new version\n            return this.createProjectContext(projectId, updatedContext, true);\n        } else {\n            // Update in place (rare case)\n            activeContext.context_json = updatedContext;\n            await dbService.updateProject(activeContext.id, activeContext);\n            return activeContext;\n        }\n    }\n    // Get context history with diffs\n    async getContextHistory(projectId) {\n        const dbService = await (0,_lib_database__WEBPACK_IMPORTED_MODULE_0__.getDBService)();\n        const contexts = await dbService.getProjectContexts(projectId);\n        // Sort by version\n        contexts.sort((a, b)=>a.version - b.version);\n        // Calculate diffs between versions\n        const history = contexts.map((context, index)=>{\n            let diff = {};\n            if (index > 0) {\n                diff = calculateDiff(contexts[index - 1].context_json, context.context_json);\n            }\n            return {\n                ...context,\n                diff,\n                is_current: context.is_active === 1\n            };\n        });\n        return history;\n    }\n    // Activate a specific context version\n    async activateContextVersion(contextId) {\n        const dbService = await (0,_lib_database__WEBPACK_IMPORTED_MODULE_0__.getDBService)();\n        await dbService.activateProjectContext(contextId);\n    }\n    // Preview resolved context without saving\n    async previewResolvedContext(projectId, featureContext) {\n        const dbService = await (0,_lib_database__WEBPACK_IMPORTED_MODULE_0__.getDBService)();\n        const activeContext = await dbService.getActiveProjectContext(projectId);\n        const projectDefaults = (activeContext === null || activeContext === void 0 ? void 0 : activeContext.context_json) || DEFAULT_PROJECT_CONTEXT;\n        const resolved = await this.resolveContext(projectId, featureContext);\n        // Calculate what came from where for transparency\n        const inherited = {\n            ...projectDefaults\n        };\n        const overrides = featureContext.overrides || {};\n        return {\n            resolved,\n            inherited_from_project: inherited,\n            feature_overrides: overrides\n        };\n    }\n    // Validate context completeness\n    validateContext(context) {\n        const warnings = [];\n        const suggestions = [];\n        // Check for common missing elements\n        if (Object.keys(context.glossary).length === 0) {\n            suggestions.push('Consider adding domain terms to the glossary');\n        }\n        if (context.stakeholders.length === 0) {\n            warnings.push('No stakeholders defined - this may lead to unclear requirements');\n        }\n        if (context.constraints.length === 0) {\n            suggestions.push('Consider adding technical or business constraints');\n        }\n        if (context.non_functional.length === 0) {\n            suggestions.push('Consider adding non-functional requirements (performance, security, etc.)');\n        }\n        if (context.api_catalog.length === 0) {\n            suggestions.push('Consider documenting existing APIs and services');\n        }\n        // Check stakeholder completeness\n        const incompleteStakeholders = context.stakeholders.filter((s)=>!s.role || s.interests.length === 0);\n        if (incompleteStakeholders.length > 0) {\n            warnings.push(\"\".concat(incompleteStakeholders.length, \" stakeholder(s) missing role or interests\"));\n        }\n        const isValid = warnings.length === 0;\n        return {\n            isValid,\n            warnings,\n            suggestions\n        };\n    }\n    // Import context from external source (Jira, Confluence, etc.)\n    async importContext(projectId, source, data) {\n        // Placeholder for external integrations\n        switch(source){\n            case 'json':\n                // Validate and import JSON context\n                const imported = data;\n                return this.createProjectContext(projectId, imported, false).then((c)=>c.context_json);\n            case 'jira':\n                // Extract context from Jira project metadata\n                // This would integrate with Jira API to extract components, users, etc.\n                throw new Error('Jira import not yet implemented');\n            case 'confluence':\n                // Extract context from Confluence space\n                throw new Error('Confluence import not yet implemented');\n            default:\n                throw new Error(\"Unknown import source: \".concat(source));\n        }\n    }\n}\n// Default service instance\nconst projectContextService = new ProjectContextService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcHJvamVjdENvbnRleHQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUM2QztBQUU3Qyx5Q0FBeUM7QUFDekMsU0FBU0MsVUFBeUNDLE1BQVMsRUFBRUMsTUFBa0I7SUFDN0UsTUFBTUMsU0FBUztRQUFFLEdBQUdGLE1BQU07SUFBQztJQUUzQixJQUFLLE1BQU1HLE9BQU9GLE9BQVE7UUFDeEIsSUFBSUEsTUFBTSxDQUFDRSxJQUFJLEtBQUtDLFdBQVc7WUFDN0IsSUFBSUMsTUFBTUMsT0FBTyxDQUFDTCxNQUFNLENBQUNFLElBQUksR0FBRztnQkFDOUJELE1BQU0sQ0FBQ0MsSUFBSSxHQUFHRixNQUFNLENBQUNFLElBQUk7WUFDM0IsT0FBTyxJQUFJLE9BQU9GLE1BQU0sQ0FBQ0UsSUFBSSxLQUFLLFlBQVlGLE1BQU0sQ0FBQ0UsSUFBSSxLQUFLLFFBQVEsQ0FBQ0UsTUFBTUMsT0FBTyxDQUFDTCxNQUFNLENBQUNFLElBQUksR0FBRztnQkFDakdELE1BQU0sQ0FBQ0MsSUFBSSxHQUFHSixVQUFVRyxNQUFNLENBQUNDLElBQUksSUFBSSxDQUFDLEdBQUdGLE1BQU0sQ0FBQ0UsSUFBSTtZQUN4RCxPQUFPO2dCQUNMRCxNQUFNLENBQUNDLElBQUksR0FBR0YsTUFBTSxDQUFDRSxJQUFJO1lBQzNCO1FBQ0Y7SUFDRjtJQUVBLE9BQU9EO0FBQ1Q7QUFFQSxpQ0FBaUM7QUFDakMsU0FBU0ssY0FBY0MsUUFBeUIsRUFBRUMsT0FBd0I7SUFDeEUsTUFBTUMsT0FBNEIsQ0FBQztJQUVuQyxtQ0FBbUM7SUFDbkMsSUFBSyxNQUFNUCxPQUFPTSxRQUFTO1FBQ3pCLElBQUlFLEtBQUtDLFNBQVMsQ0FBQ0osUUFBUSxDQUFDTCxJQUE2QixNQUFNUSxLQUFLQyxTQUFTLENBQUNILE9BQU8sQ0FBQ04sSUFBNkIsR0FBRztZQUNwSE8sSUFBSSxDQUFDUCxJQUFJLEdBQUc7Z0JBQ1ZLLFVBQVVBLFFBQVEsQ0FBQ0wsSUFBNkI7Z0JB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LFNBQWlCLEVBQ2pCdkIsTUFBc0MsRUFDdEM4RixJQUFTLEVBQ2lCO1FBQzFCLHdDQUF3QztRQUN4QyxPQUFROUY7WUFDTixLQUFLO2dCQUNILG1DQUFtQztnQkFDbkMsTUFBTStGLFdBQVdEO2dCQUNqQixPQUFPLElBQUksQ0FBQzlDLG9CQUFvQixDQUFDekIsV0FBV3dFLFVBQVUsT0FBT0MsSUFBSSxDQUFDeEMsQ0FBQUEsSUFBS0EsRUFBRTNCLFlBQVk7WUFFdkYsS0FBSztnQkFDSCw2Q0FBNkM7Z0JBQzdDLHdFQUF3RTtnQkFDeEUsTUFBTSxJQUFJc0MsTUFBTTtZQUVsQixLQUFLO2dCQUNILHdDQUF3QztnQkFDeEMsTUFBTSxJQUFJQSxNQUFNO1lBRWxCO2dCQUNFLE1BQU0sSUFBSUEsTUFBTSwwQkFBaUMsT0FBUG5FO1FBQzlDO0lBQ0Y7QUFDRjtBQUVBLDJCQUEyQjtBQUNwQixNQUFNaUcsd0JBQXdCLElBQUk1RSx3QkFBdUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNvbmh1bGJlcnQvUHJvamVjdHMvc3BlY2dlbi9zcmMvbGliL3Byb2plY3RDb250ZXh0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlc29sdmVkQ29udGV4dCwgU3BlY0lucHV0LCBJbnB1dENvbnRleHQgfSBmcm9tICdAL3R5cGVzL3NjaGVtYXMnXG5pbXBvcnQgeyBnZXREQlNlcnZpY2UgfSBmcm9tICdAL2xpYi9kYXRhYmFzZSdcblxuLy8gRGVlcCBtZXJnZSB1dGlsaXR5IGZvciBjb250ZXh0IG1lcmdpbmdcbmZ1bmN0aW9uIGRlZXBNZXJnZTxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4odGFyZ2V0OiBULCBzb3VyY2U6IFBhcnRpYWw8VD4pOiBUIHtcbiAgY29uc3QgcmVzdWx0ID0geyAuLi50YXJnZXQgfVxuICBcbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVtrZXldKSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZVtrZXldIGFzIFRbRXh0cmFjdDxrZXlvZiBULCBzdHJpbmc+XVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlW2tleV0gPT09ICdvYmplY3QnICYmIHNvdXJjZVtrZXldICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHNvdXJjZVtrZXldKSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGRlZXBNZXJnZShyZXN1bHRba2V5XSB8fCB7fSwgc291cmNlW2tleV0pIGFzIFRbRXh0cmFjdDxrZXlvZiBULCBzdHJpbmc+XVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2Vba2V5XSBhcyBUW0V4dHJhY3Q8a2V5b2YgVCwgc3RyaW5nPl1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gQ29udGV4dCBkaWZmZXJlbmNlIGNhbGN1bGF0aW9uXG5mdW5jdGlvbiBjYWxjdWxhdGVEaWZmKHByZXZpb3VzOiBSZXNvbHZlZENvbnRleHQsIGN1cnJlbnQ6IFJlc29sdmVkQ29udGV4dCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCBkaWZmOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge31cbiAgXG4gIC8vIFNpbXBsZSBmaWVsZC1ieS1maWVsZCBjb21wYXJpc29uXG4gIGZvciAoY29uc3Qga2V5IGluIGN1cnJlbnQpIHtcbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkocHJldmlvdXNba2V5IGFzIGtleW9mIFJlc29sdmVkQ29udGV4dF0pICE9PSBKU09OLnN0cmluZ2lmeShjdXJyZW50W2tleSBhcyBrZXlvZiBSZXNvbHZlZENvbnRleHRdKSkge1xuICAgICAgZGlmZltrZXldID0ge1xuICAgICAgICBwcmV2aW91czogcHJldmlvdXNba2V5IGFzIGtleW9mIFJlc29sdmVkQ29udGV4dF0sXG4gICAgICAgIGN1cnJlbnQ6IGN1cnJlbnRba2V5IGFzIGtleW9mIFJlc29sdmVkQ29udGV4dF0sXG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gZGlmZlxufVxuXG4vLyBEZWZhdWx0IGNvbnRleHQgdGVtcGxhdGVcbmV4cG9ydCBjb25zdCBERUZBVUxUX1BST0pFQ1RfQ09OVEVYVDogUmVzb2x2ZWRDb250ZXh0ID0ge1xuICBnbG9zc2FyeToge30sXG4gIHN0YWtlaG9sZGVyczogW10sXG4gIGNvbnN0cmFpbnRzOiBbXSxcbiAgbm9uX2Z1bmN0aW9uYWw6IFtdLFxuICBhcGlfY2F0YWxvZzogW10sXG4gIGRhdGFfbW9kZWxzOiBbXSxcbiAgZW52czogWydsb2NhbCcsICdkZXYnLCAndGVzdCcsICdwcm9kJ10sXG4gIGxhYmVsczoge30sXG59XG5cbi8vIENvbnRleHQgbWVyZ2luZyBzZXJ2aWNlXG5leHBvcnQgY2xhc3MgUHJvamVjdENvbnRleHRTZXJ2aWNlIHtcbiAgXG4gIC8vIFJlc29sdmUgZmluYWwgY29udGV4dCBieSBtZXJnaW5nIHByb2plY3QgZGVmYXVsdHMgd2l0aCBmZWF0dXJlIG92ZXJyaWRlc1xuICBhc3luYyByZXNvbHZlQ29udGV4dChwcm9qZWN0SWQ6IHN0cmluZywgZmVhdHVyZUNvbnRleHQ/OiBJbnB1dENvbnRleHQpOiBQcm9taXNlPFJlc29sdmVkQ29udGV4dD4ge1xuICAgIGNvbnN0IGRiU2VydmljZSA9IGF3YWl0IGdldERCU2VydmljZSgpXG4gICAgXG4gICAgLy8gR2V0IGFjdGl2ZSBwcm9qZWN0IGNvbnRleHQgKGRlZmF1bHRzKVxuICAgIGNvbnN0IGFjdGl2ZUNvbnRleHQgPSBhd2FpdCBkYlNlcnZpY2UuZ2V0QWN0aXZlUHJvamVjdENvbnRleHQocHJvamVjdElkKVxuICAgIGNvbnN0IHByb2plY3REZWZhdWx0cyA9IGFjdGl2ZUNvbnRleHQ/LmNvbnRleHRfanNvbiB8fCBERUZBVUxUX1BST0pFQ1RfQ09OVEVYVFxuICAgIFxuICAgIC8vIElmIG5vIGZlYXR1cmUgY29udGV4dCBvciBpbmhlcml0X2Zyb21fcHJvamVjdCBpcyBmYWxzZSwgcmV0dXJuIHByb2plY3QgZGVmYXVsdHNcbiAgICBpZiAoIWZlYXR1cmVDb250ZXh0IHx8ICFmZWF0dXJlQ29udGV4dC5pbmhlcml0X2Zyb21fcHJvamVjdCkge1xuICAgICAgcmV0dXJuIHByb2plY3REZWZhdWx0c1xuICAgIH1cbiAgICBcbiAgICAvLyBNZXJnZSBwcm9qZWN0IGRlZmF1bHRzIHdpdGggZmVhdHVyZSBvdmVycmlkZXNcbiAgICBsZXQgcmVzb2x2ZWRDb250ZXh0ID0geyAuLi5wcm9qZWN0RGVmYXVsdHMgfVxuICAgIFxuICAgIC8vIEFwcGx5IGZlYXR1cmUtbGV2ZWwgY29udGV4dCBmaWVsZHNcbiAgICBpZiAoZmVhdHVyZUNvbnRleHQuc3Rha2Vob2xkZXJzPy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nU3Rha2Vob2xkZXJzID0gcmVzb2x2ZWRDb250ZXh0LnN0YWtlaG9sZGVycy5tYXAocyA9PiBzLm5hbWUpXG4gICAgICBjb25zdCBuZXdTdGFrZWhvbGRlck5hbWVzID0gZmVhdHVyZUNvbnRleHQuc3Rha2Vob2xkZXJzLmZpbHRlcihuYW1lID0+ICFleGlzdGluZ1N0YWtlaG9sZGVycy5pbmNsdWRlcyhuYW1lKSlcbiAgICAgIFxuICAgICAgLy8gQWRkIG5ldyBzdGFrZWhvbGRlcnMgd2l0aCBiYXNpYyBpbmZvXG4gICAgICBjb25zdCBuZXdTdGFrZWhvbGRlcnMgPSBuZXdTdGFrZWhvbGRlck5hbWVzLm1hcChuYW1lID0+ICh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHJvbGU6ICdTdGFrZWhvbGRlcicsXG4gICAgICAgIGludGVyZXN0czogW10sXG4gICAgICB9KSlcbiAgICAgIFxuICAgICAgcmVzb2x2ZWRDb250ZXh0LnN0YWtlaG9sZGVycyA9IFsuLi5yZXNvbHZlZENvbnRleHQuc3Rha2Vob2xkZXJzLCAuLi5uZXdTdGFrZWhvbGRlcnNdXG4gICAgfVxuICAgIFxuICAgIGlmIChmZWF0dXJlQ29udGV4dC5jb25zdHJhaW50cz8ubGVuZ3RoKSB7XG4gICAgICBjb25zdCB1bmlxdWVDb25zdHJhaW50cyA9IG5ldyBTZXQoWy4uLnJlc29sdmVkQ29udGV4dC5jb25zdHJhaW50cywgLi4uZmVhdHVyZUNvbnRleHQuY29uc3RyYWludHNdKVxuICAgICAgcmVzb2x2ZWRDb250ZXh0LmNvbnN0cmFpbnRzID0gQXJyYXkuZnJvbSh1bmlxdWVDb25zdHJhaW50cylcbiAgICB9XG4gICAgXG4gICAgaWYgKGZlYXR1cmVDb250ZXh0Lm5vbl9mdW5jdGlvbmFsPy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHVuaXF1ZU5vbkZ1bmN0aW9uYWwgPSBuZXcgU2V0KFsuLi5yZXNvbHZlZENvbnRleHQubm9uX2Z1bmN0aW9uYWwsIC4uLmZlYXR1cmVDb250ZXh0Lm5vbl9mdW5jdGlvbmFsXSlcbiAgICAgIHJlc29sdmVkQ29udGV4dC5ub25fZnVuY3Rpb25hbCA9IEFycmF5LmZyb20odW5pcXVlTm9uRnVuY3Rpb25hbClcbiAgICB9XG4gICAgXG4gICAgLy8gQXBwbHkgZXhwbGljaXQgb3ZlcnJpZGVzIChmZWF0dXJlIG92ZXJyaWRlcyBhbHdheXMgd2luKVxuICAgIGlmIChmZWF0dXJlQ29udGV4dC5vdmVycmlkZXMpIHtcbiAgICAgIHJlc29sdmVkQ29udGV4dCA9IGRlZXBNZXJnZShyZXNvbHZlZENvbnRleHQsIGZlYXR1cmVDb250ZXh0Lm92ZXJyaWRlcyBhcyBQYXJ0aWFsPFJlc29sdmVkQ29udGV4dD4pXG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXNvbHZlZENvbnRleHRcbiAgfVxuICBcbiAgLy8gQ3JlYXRlIGEgbmV3IHByb2plY3QgY29udGV4dCB2ZXJzaW9uXG4gIGFzeW5jIGNyZWF0ZVByb2plY3RDb250ZXh0KFxuICAgIHByb2plY3RJZDogc3RyaW5nLCBcbiAgICBjb250ZXh0OiBSZXNvbHZlZENvbnRleHQsIFxuICAgIGlzQWN0aXZlOiBib29sZWFuID0gZmFsc2VcbiAgKSB7XG4gICAgY29uc3QgZGJTZXJ2aWNlID0gYXdhaXQgZ2V0REJTZXJ2aWNlKClcbiAgICBcbiAgICAvLyBHZXQgY3VycmVudCB2ZXJzaW9uIG51bWJlclxuICAgIGNvbnN0IGV4aXN0aW5nQ29udGV4dHMgPSBhd2FpdCBkYlNlcnZpY2UuZ2V0UHJvamVjdENvbnRleHRzKHByb2plY3RJZClcbiAgICBjb25zdCBuZXh0VmVyc2lvbiA9IGV4aXN0aW5nQ29udGV4dHMubGVuZ3RoID4gMCBcbiAgICAgID8gTWF0aC5tYXgoLi4uZXhpc3RpbmdDb250ZXh0cy5tYXAoYyA9PiBjLnZlcnNpb24pKSArIDEgXG4gICAgICA6IDFcbiAgICBcbiAgICAvLyBDcmVhdGUgbmV3IGNvbnRleHRcbiAgICBjb25zdCBuZXdDb250ZXh0ID0gYXdhaXQgZGJTZXJ2aWNlLmNyZWF0ZVByb2plY3RDb250ZXh0KHtcbiAgICAgIHByb2plY3RfaWQ6IHByb2plY3RJZCxcbiAgICAgIGNvbnRleHRfanNvbjogY29udGV4dCxcbiAgICAgIHZlcnNpb246IG5leHRWZXJzaW9uLFxuICAgICAgaXNfYWN0aXZlOiBpc0FjdGl2ZSA/IDEgOiAwLFxuICAgIH0pXG4gICAgXG4gICAgLy8gQ3JlYXRlIGRpZmYgaWYgdGhlcmUncyBhIHByZXZpb3VzIHZlcnNpb25cbiAgICBpZiAoZXhpc3RpbmdDb250ZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0NvbnRleHQgPSBleGlzdGluZ0NvbnRleHRzW2V4aXN0aW5nQ29udGV4dHMubGVuZ3RoIC0gMV1cbiAgICAgIGNvbnN0IGRpZmYgPSBjYWxjdWxhdGVEaWZmKHByZXZpb3VzQ29udGV4dC5jb250ZXh0X2pzb24sIGNvbnRleHQpXG4gICAgICBcbiAgICAgIGlmIChPYmplY3Qua2V5cyhkaWZmKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBkaWZmIChpZiBuZWVkZWQgZm9yIGhpc3RvcnkgdHJhY2tpbmcpXG4gICAgICAgIC8vIGF3YWl0IGRiU2VydmljZS5jcmVhdGVQcm9qZWN0Q29udGV4dERpZmYoLi4uKSBcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG5ld0NvbnRleHRcbiAgfVxuICBcbiAgLy8gVXBkYXRlIGFuZCB2ZXJzaW9uIGEgcHJvamVjdCBjb250ZXh0XG4gIGFzeW5jIHVwZGF0ZVByb2plY3RDb250ZXh0KFxuICAgIHByb2plY3RJZDogc3RyaW5nLFxuICAgIHVwZGF0ZXM6IFBhcnRpYWw8UmVzb2x2ZWRDb250ZXh0PixcbiAgICBjcmVhdGVOZXdWZXJzaW9uOiBib29sZWFuID0gdHJ1ZVxuICApIHtcbiAgICBjb25zdCBkYlNlcnZpY2UgPSBhd2FpdCBnZXREQlNlcnZpY2UoKVxuICAgIFxuICAgIC8vIEdldCBjdXJyZW50IGFjdGl2ZSBjb250ZXh0XG4gICAgY29uc3QgYWN0aXZlQ29udGV4dCA9IGF3YWl0IGRiU2VydmljZS5nZXRBY3RpdmVQcm9qZWN0Q29udGV4dChwcm9qZWN0SWQpXG4gICAgaWYgKCFhY3RpdmVDb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBjb250ZXh0IGZvdW5kIGZvciBwcm9qZWN0JylcbiAgICB9XG4gICAgXG4gICAgLy8gTWVyZ2UgdXBkYXRlc1xuICAgIGNvbnN0IHVwZGF0ZWRDb250ZXh0ID0gZGVlcE1lcmdlKGFjdGl2ZUNvbnRleHQuY29udGV4dF9qc29uLCB1cGRhdGVzKVxuICAgIFxuICAgIGlmIChjcmVhdGVOZXdWZXJzaW9uKSB7XG4gICAgICAvLyBDcmVhdGUgbmV3IHZlcnNpb25cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVByb2plY3RDb250ZXh0KHByb2plY3RJZCwgdXBkYXRlZENvbnRleHQsIHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZSBpbiBwbGFjZSAocmFyZSBjYXNlKVxuICAgICAgYWN0aXZlQ29udGV4dC5jb250ZXh0X2pzb24gPSB1cGRhdGVkQ29udGV4dFxuICAgICAgYXdhaXQgZGJTZXJ2aWNlLnVwZGF0ZVByb2plY3QoYWN0aXZlQ29udGV4dC5pZCwgYWN0aXZlQ29udGV4dCBhcyBhbnkpXG4gICAgICByZXR1cm4gYWN0aXZlQ29udGV4dFxuICAgIH1cbiAgfVxuICBcbiAgLy8gR2V0IGNvbnRleHQgaGlzdG9yeSB3aXRoIGRpZmZzXG4gIGFzeW5jIGdldENvbnRleHRIaXN0b3J5KHByb2plY3RJZDogc3RyaW5nKSB7XG4gICAgY29uc3QgZGJTZXJ2aWNlID0gYXdhaXQgZ2V0REJTZXJ2aWNlKClcbiAgICBjb25zdCBjb250ZXh0cyA9IGF3YWl0IGRiU2VydmljZS5nZXRQcm9qZWN0Q29udGV4dHMocHJvamVjdElkKVxuICAgIFxuICAgIC8vIFNvcnQgYnkgdmVyc2lvblxuICAgIGNvbnRleHRzLnNvcnQoKGEsIGIpID0+IGEudmVyc2lvbiAtIGIudmVyc2lvbilcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZGlmZnMgYmV0d2VlbiB2ZXJzaW9uc1xuICAgIGNvbnN0IGhpc3RvcnkgPSBjb250ZXh0cy5tYXAoKGNvbnRleHQsIGluZGV4KSA9PiB7XG4gICAgICBsZXQgZGlmZiA9IHt9XG4gICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgIGRpZmYgPSBjYWxjdWxhdGVEaWZmKGNvbnRleHRzW2luZGV4IC0gMV0uY29udGV4dF9qc29uLCBjb250ZXh0LmNvbnRleHRfanNvbilcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgZGlmZixcbiAgICAgICAgaXNfY3VycmVudDogY29udGV4dC5pc19hY3RpdmUgPT09IDEsXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICByZXR1cm4gaGlzdG9yeVxuICB9XG4gIFxuICAvLyBBY3RpdmF0ZSBhIHNwZWNpZmljIGNvbnRleHQgdmVyc2lvblxuICBhc3luYyBhY3RpdmF0ZUNvbnRleHRWZXJzaW9uKGNvbnRleHRJZDogc3RyaW5nKSB7XG4gICAgY29uc3QgZGJTZXJ2aWNlID0gYXdhaXQgZ2V0REJTZXJ2aWNlKClcbiAgICBhd2FpdCBkYlNlcnZpY2UuYWN0aXZhdGVQcm9qZWN0Q29udGV4dChjb250ZXh0SWQpXG4gIH1cbiAgXG4gIC8vIFByZXZpZXcgcmVzb2x2ZWQgY29udGV4dCB3aXRob3V0IHNhdmluZ1xuICBhc3luYyBwcmV2aWV3UmVzb2x2ZWRDb250ZXh0KFxuICAgIHByb2plY3RJZDogc3RyaW5nLFxuICAgIGZlYXR1cmVDb250ZXh0OiBJbnB1dENvbnRleHRcbiAgKTogUHJvbWlzZTx7XG4gICAgcmVzb2x2ZWQ6IFJlc29sdmVkQ29udGV4dFxuICAgIGluaGVyaXRlZF9mcm9tX3Byb2plY3Q6IFBhcnRpYWw8UmVzb2x2ZWRDb250ZXh0PlxuICAgIGZlYXR1cmVfb3ZlcnJpZGVzOiBQYXJ0aWFsPFJlc29sdmVkQ29udGV4dD5cbiAgfT4ge1xuICAgIGNvbnN0IGRiU2VydmljZSA9IGF3YWl0IGdldERCU2VydmljZSgpXG4gICAgXG4gICAgY29uc3QgYWN0aXZlQ29udGV4dCA9IGF3YWl0IGRiU2VydmljZS5nZXRBY3RpdmVQcm9qZWN0Q29udGV4dChwcm9qZWN0SWQpXG4gICAgY29uc3QgcHJvamVjdERlZmF1bHRzID0gYWN0aXZlQ29udGV4dD8uY29udGV4dF9qc29uIHx8IERFRkFVTFRfUFJPSkVDVF9DT05URVhUXG4gICAgXG4gICAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCB0aGlzLnJlc29sdmVDb250ZXh0KHByb2plY3RJZCwgZmVhdHVyZUNvbnRleHQpXG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHdoYXQgY2FtZSBmcm9tIHdoZXJlIGZvciB0cmFuc3BhcmVuY3lcbiAgICBjb25zdCBpbmhlcml0ZWQgPSB7IC4uLnByb2plY3REZWZhdWx0cyB9XG4gICAgY29uc3Qgb3ZlcnJpZGVzID0gZmVhdHVyZUNvbnRleHQub3ZlcnJpZGVzIHx8IHt9XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc29sdmVkLFxuICAgICAgaW5oZXJpdGVkX2Zyb21fcHJvamVjdDogaW5oZXJpdGVkLFxuICAgICAgZmVhdHVyZV9vdmVycmlkZXM6IG92ZXJyaWRlcyxcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFZhbGlkYXRlIGNvbnRleHQgY29tcGxldGVuZXNzXG4gIHZhbGlkYXRlQ29udGV4dChjb250ZXh0OiBSZXNvbHZlZENvbnRleHQpOiB7XG4gICAgaXNWYWxpZDogYm9vbGVhblxuICAgIHdhcm5pbmdzOiBzdHJpbmdbXVxuICAgIHN1Z2dlc3Rpb25zOiBzdHJpbmdbXVxuICB9IHtcbiAgICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXVxuICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBzdHJpbmdbXSA9IFtdXG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGNvbW1vbiBtaXNzaW5nIGVsZW1lbnRzXG4gICAgaWYgKE9iamVjdC5rZXlzKGNvbnRleHQuZ2xvc3NhcnkpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc3VnZ2VzdGlvbnMucHVzaCgnQ29uc2lkZXIgYWRkaW5nIGRvbWFpbiB0ZXJtcyB0byB0aGUgZ2xvc3NhcnknKVxuICAgIH1cbiAgICBcbiAgICBpZiAoY29udGV4dC5zdGFrZWhvbGRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKCdObyBzdGFrZWhvbGRlcnMgZGVmaW5lZCAtIHRoaXMgbWF5IGxlYWQgdG8gdW5jbGVhciByZXF1aXJlbWVudHMnKVxuICAgIH1cbiAgICBcbiAgICBpZiAoY29udGV4dC5jb25zdHJhaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHN1Z2dlc3Rpb25zLnB1c2goJ0NvbnNpZGVyIGFkZGluZyB0ZWNobmljYWwgb3IgYnVzaW5lc3MgY29uc3RyYWludHMnKVxuICAgIH1cbiAgICBcbiAgICBpZiAoY29udGV4dC5ub25fZnVuY3Rpb25hbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHN1Z2dlc3Rpb25zLnB1c2goJ0NvbnNpZGVyIGFkZGluZyBub24tZnVuY3Rpb25hbCByZXF1aXJlbWVudHMgKHBlcmZvcm1hbmNlLCBzZWN1cml0eSwgZXRjLiknKVxuICAgIH1cbiAgICBcbiAgICBpZiAoY29udGV4dC5hcGlfY2F0YWxvZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHN1Z2dlc3Rpb25zLnB1c2goJ0NvbnNpZGVyIGRvY3VtZW50aW5nIGV4aXN0aW5nIEFQSXMgYW5kIHNlcnZpY2VzJylcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgc3Rha2Vob2xkZXIgY29tcGxldGVuZXNzXG4gICAgY29uc3QgaW5jb21wbGV0ZVN0YWtlaG9sZGVycyA9IGNvbnRleHQuc3Rha2Vob2xkZXJzLmZpbHRlcihzID0+IFxuICAgICAgIXMucm9sZSB8fCBzLmludGVyZXN0cy5sZW5ndGggPT09IDBcbiAgICApXG4gICAgaWYgKGluY29tcGxldGVTdGFrZWhvbGRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgd2FybmluZ3MucHVzaChgJHtpbmNvbXBsZXRlU3Rha2Vob2xkZXJzLmxlbmd0aH0gc3Rha2Vob2xkZXIocykgbWlzc2luZyByb2xlIG9yIGludGVyZXN0c2ApXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGlzVmFsaWQgPSB3YXJuaW5ncy5sZW5ndGggPT09IDBcbiAgICBcbiAgICByZXR1cm4geyBpc1ZhbGlkLCB3YXJuaW5ncywgc3VnZ2VzdGlvbnMgfVxuICB9XG4gIFxuICAvLyBJbXBvcnQgY29udGV4dCBmcm9tIGV4dGVybmFsIHNvdXJjZSAoSmlyYSwgQ29uZmx1ZW5jZSwgZXRjLilcbiAgYXN5bmMgaW1wb3J0Q29udGV4dChcbiAgICBwcm9qZWN0SWQ6IHN0cmluZyxcbiAgICBzb3VyY2U6ICdqaXJhJyB8ICdjb25mbHVlbmNlJyB8ICdqc29uJyxcbiAgICBkYXRhOiBhbnlcbiAgKTogUHJvbWlzZTxSZXNvbHZlZENvbnRleHQ+IHtcbiAgICAvLyBQbGFjZWhvbGRlciBmb3IgZXh0ZXJuYWwgaW50ZWdyYXRpb25zXG4gICAgc3dpdGNoIChzb3VyY2UpIHtcbiAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAvLyBWYWxpZGF0ZSBhbmQgaW1wb3J0IEpTT04gY29udGV4dFxuICAgICAgICBjb25zdCBpbXBvcnRlZCA9IGRhdGEgYXMgUmVzb2x2ZWRDb250ZXh0XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVByb2plY3RDb250ZXh0KHByb2plY3RJZCwgaW1wb3J0ZWQsIGZhbHNlKS50aGVuKGMgPT4gYy5jb250ZXh0X2pzb24pXG4gICAgICBcbiAgICAgIGNhc2UgJ2ppcmEnOlxuICAgICAgICAvLyBFeHRyYWN0IGNvbnRleHQgZnJvbSBKaXJhIHByb2plY3QgbWV0YWRhdGFcbiAgICAgICAgLy8gVGhpcyB3b3VsZCBpbnRlZ3JhdGUgd2l0aCBKaXJhIEFQSSB0byBleHRyYWN0IGNvbXBvbmVudHMsIHVzZXJzLCBldGMuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSmlyYSBpbXBvcnQgbm90IHlldCBpbXBsZW1lbnRlZCcpXG4gICAgICBcbiAgICAgIGNhc2UgJ2NvbmZsdWVuY2UnOlxuICAgICAgICAvLyBFeHRyYWN0IGNvbnRleHQgZnJvbSBDb25mbHVlbmNlIHNwYWNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmx1ZW5jZSBpbXBvcnQgbm90IHlldCBpbXBsZW1lbnRlZCcpXG4gICAgICBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBpbXBvcnQgc291cmNlOiAke3NvdXJjZX1gKVxuICAgIH1cbiAgfVxufVxuXG4vLyBEZWZhdWx0IHNlcnZpY2UgaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBwcm9qZWN0Q29udGV4dFNlcnZpY2UgPSBuZXcgUHJvamVjdENvbnRleHRTZXJ2aWNlKCkiXSwibmFtZXMiOlsiZ2V0REJTZXJ2aWNlIiwiZGVlcE1lcmdlIiwidGFyZ2V0Iiwic291cmNlIiwicmVzdWx0Iiwia2V5IiwidW5kZWZpbmVkIiwiQXJyYXkiLCJpc0FycmF5IiwiY2FsY3VsYXRlRGlmZiIsInByZXZpb3VzIiwiY3VycmVudCIsImRpZmYiLCJKU09OIiwic3RyaW5naWZ5IiwiREVGQVVMVF9QUk9KRUNUX0NPTlRFWFQiLCJnbG9zc2FyeSIsInN0YWtlaG9sZGVycyIsImNvbnN0cmFpbnRzIiwibm9uX2Z1bmN0aW9uYWwiLCJhcGlfY2F0YWxvZyIsImRhdGFfbW9kZWxzIiwiZW52cyIsImxhYmVscyIsIlByb2plY3RDb250ZXh0U2VydmljZSIsInJlc29sdmVDb250ZXh0IiwicHJvamVjdElkIiwiZmVhdHVyZUNvbnRleHQiLCJkYlNlcnZpY2UiLCJhY3RpdmVDb250ZXh0IiwiZ2V0QWN0aXZlUHJvamVjdENvbnRleHQiLCJwcm9qZWN0RGVmYXVsdHMiLCJjb250ZXh0X2pzb24iLCJpbmhlcml0X2Zyb21fcHJvamVjdCIsInJlc29sdmVkQ29udGV4dCIsImxlbmd0aCIsImV4aXN0aW5nU3Rha2Vob2xkZXJzIiwibWFwIiwicyIsIm5hbWUiLCJuZXdTdGFrZWhvbGRlck5hbWVzIiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJuZXdTdGFrZWhvbGRlcnMiLCJyb2xlIiwiaW50ZXJlc3RzIiwidW5pcXVlQ29uc3RyYWludHMiLCJTZXQiLCJmcm9tIiwidW5pcXVlTm9uRnVuY3Rpb25hbCIsIm92ZXJyaWRlcyIsImNyZWF0ZVByb2plY3RDb250ZXh0IiwiY29udGV4dCIsImlzQWN0aXZlIiwiZXhpc3RpbmdDb250ZXh0cyIsImdldFByb2plY3RDb250ZXh0cyIsIm5leHRWZXJzaW9uIiwiTWF0aCIsIm1heCIsImMiLCJ2ZXJzaW9uIiwibmV3Q29udGV4dCIsInByb2plY3RfaWQiLCJpc19hY3RpdmUiLCJwcmV2aW91c0NvbnRleHQiLCJPYmplY3QiLCJrZXlzIiwidXBkYXRlUHJvamVjdENvbnRleHQiLCJ1cGRhdGVzIiwiY3JlYXRlTmV3VmVyc2lvbiIsIkVycm9yIiwidXBkYXRlZENvbnRleHQiLCJ1cGRhdGVQcm9qZWN0IiwiaWQiLCJnZXRDb250ZXh0SGlzdG9yeSIsImNvbnRleHRzIiwic29ydCIsImEiLCJiIiwiaGlzdG9yeSIsImluZGV4IiwiaXNfY3VycmVudCIsImFjdGl2YXRlQ29udGV4dFZlcnNpb24iLCJjb250ZXh0SWQiLCJhY3RpdmF0ZVByb2plY3RDb250ZXh0IiwicHJldmlld1Jlc29sdmVkQ29udGV4dCIsInJlc29sdmVkIiwiaW5oZXJpdGVkIiwiaW5oZXJpdGVkX2Zyb21fcHJvamVjdCIsImZlYXR1cmVfb3ZlcnJpZGVzIiwidmFsaWRhdGVDb250ZXh0Iiwid2FybmluZ3MiLCJzdWdnZXN0aW9ucyIsInB1c2giLCJpbmNvbXBsZXRlU3Rha2Vob2xkZXJzIiwiaXNWYWxpZCIsImltcG9ydENvbnRleHQiLCJkYXRhIiwiaW1wb3J0ZWQiLCJ0aGVuIiwicHJvamVjdENvbnRleHRTZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/projectContext.ts\n"));

/***/ })

}]);